// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/core/grappler/costs/op_performance_data.proto

/*
	Package tensorflow is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/core/grappler/costs/op_performance_data.proto

	It has these top-level messages:
		OpInfo
		OpPerformance
		OpPerformanceList
*/
package tensorflow

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import tensorflow4 "github.com/d4l3k/pok/tensorflow/core/framework"
import tensorflow2 "github.com/d4l3k/pok/tensorflow/core/framework"
import tensorflow3 "github.com/d4l3k/pok/tensorflow/core/framework"
import tensorflow5 "github.com/d4l3k/pok/tensorflow/core/framework"
import tensorflow6 "github.com/d4l3k/pok/tensorflow/core/protobuf"

import fmt "fmt"
import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Description of an operation as well as the parameters expected to impact its
// performance.
type OpInfo struct {
	// The operation name.  There may be custom parameters in attrs.
	Op string `protobuf:"bytes,1,opt,name=op,proto3" json:"op,omitempty"`
	// Custom parameters impacting the behavior of the op.
	Attr   map[string]*tensorflow5.AttrValue `protobuf:"bytes,2,rep,name=attr" json:"attr,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Inputs []*OpInfo_TensorProperties        `protobuf:"bytes,3,rep,name=inputs" json:"inputs,omitempty"`
	// Optional description of the op outputs
	Outputs []*OpInfo_TensorProperties `protobuf:"bytes,5,rep,name=outputs" json:"outputs,omitempty"`
	// Device on which the operation is run.
	Device *tensorflow6.DeviceProperties `protobuf:"bytes,4,opt,name=device" json:"device,omitempty"`
}

func (m *OpInfo) Reset()                    { *m = OpInfo{} }
func (*OpInfo) ProtoMessage()               {}
func (*OpInfo) Descriptor() ([]byte, []int) { return fileDescriptorOpPerformanceData, []int{0} }

func (m *OpInfo) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *OpInfo) GetAttr() map[string]*tensorflow5.AttrValue {
	if m != nil {
		return m.Attr
	}
	return nil
}

func (m *OpInfo) GetInputs() []*OpInfo_TensorProperties {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *OpInfo) GetOutputs() []*OpInfo_TensorProperties {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *OpInfo) GetDevice() *tensorflow6.DeviceProperties {
	if m != nil {
		return m.Device
	}
	return nil
}

// Input data types, shapes and values if known.
type OpInfo_TensorProperties struct {
	Dtype tensorflow3.DataType          `protobuf:"varint,1,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	Shape *tensorflow2.TensorShapeProto `protobuf:"bytes,2,opt,name=shape" json:"shape,omitempty"`
	Value *tensorflow4.TensorProto      `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *OpInfo_TensorProperties) Reset()      { *m = OpInfo_TensorProperties{} }
func (*OpInfo_TensorProperties) ProtoMessage() {}
func (*OpInfo_TensorProperties) Descriptor() ([]byte, []int) {
	return fileDescriptorOpPerformanceData, []int{0, 1}
}

func (m *OpInfo_TensorProperties) GetDtype() tensorflow3.DataType {
	if m != nil {
		return m.Dtype
	}
	return tensorflow3.DT_INVALID
}

func (m *OpInfo_TensorProperties) GetShape() *tensorflow2.TensorShapeProto {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *OpInfo_TensorProperties) GetValue() *tensorflow4.TensorProto {
	if m != nil {
		return m.Value
	}
	return nil
}

// Performance data for tensorflow operations
type OpPerformance struct {
	// The op
	Op *OpInfo `protobuf:"bytes,1,opt,name=op" json:"op,omitempty"`
	// The node name (optional). Makes it easier to associate the performance data
	// with a specific graph node.
	Node string `protobuf:"bytes,5,opt,name=node,proto3" json:"node,omitempty"`
	// Temporary memory used by this node (in bytes).
	TemporaryMemorySize int64 `protobuf:"varint,2,opt,name=temporary_memory_size,json=temporaryMemorySize,proto3" json:"temporary_memory_size,omitempty"`
	// Time it takes to run the op (in nanoseconds).
	ComputeCost int64 `protobuf:"varint,3,opt,name=compute_cost,json=computeCost,proto3" json:"compute_cost,omitempty"`
	// Analytical compute cost (in nanoseconds).
	ComputeTime int64 `protobuf:"varint,6,opt,name=compute_time,json=computeTime,proto3" json:"compute_time,omitempty"`
	// Analytical memory access cost (in nanoseconds).
	MemoryTime int64 `protobuf:"varint,7,opt,name=memory_time,json=memoryTime,proto3" json:"memory_time,omitempty"`
	// Percentage of theoretical compute performance.
	ComputeEfficiency float64 `protobuf:"fixed64,4,opt,name=compute_efficiency,json=computeEfficiency,proto3" json:"compute_efficiency,omitempty"`
	// Percentage of theoretical memory performance.
	MemoryEfficiency float64                 `protobuf:"fixed64,8,opt,name=memory_efficiency,json=memoryEfficiency,proto3" json:"memory_efficiency,omitempty"`
	OpMemory         *OpPerformance_OpMemory `protobuf:"bytes,9,opt,name=op_memory,json=opMemory" json:"op_memory,omitempty"`
}

func (m *OpPerformance) Reset()                    { *m = OpPerformance{} }
func (*OpPerformance) ProtoMessage()               {}
func (*OpPerformance) Descriptor() ([]byte, []int) { return fileDescriptorOpPerformanceData, []int{1} }

func (m *OpPerformance) GetOp() *OpInfo {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *OpPerformance) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *OpPerformance) GetTemporaryMemorySize() int64 {
	if m != nil {
		return m.TemporaryMemorySize
	}
	return 0
}

func (m *OpPerformance) GetComputeCost() int64 {
	if m != nil {
		return m.ComputeCost
	}
	return 0
}

func (m *OpPerformance) GetComputeTime() int64 {
	if m != nil {
		return m.ComputeTime
	}
	return 0
}

func (m *OpPerformance) GetMemoryTime() int64 {
	if m != nil {
		return m.MemoryTime
	}
	return 0
}

func (m *OpPerformance) GetComputeEfficiency() float64 {
	if m != nil {
		return m.ComputeEfficiency
	}
	return 0
}

func (m *OpPerformance) GetMemoryEfficiency() float64 {
	if m != nil {
		return m.MemoryEfficiency
	}
	return 0
}

func (m *OpPerformance) GetOpMemory() *OpPerformance_OpMemory {
	if m != nil {
		return m.OpMemory
	}
	return nil
}

// Memory usage data for a tensorflow operation.
type OpPerformance_OpMemory struct {
	// The output information may have memory usage and output shapes.
	OutputMemory []int64 `protobuf:"varint,1,rep,packed,name=output_memory,json=outputMemory" json:"output_memory,omitempty"`
	// Temporary memory allocated by this node.
	HostTempMemory   int64 `protobuf:"varint,2,opt,name=host_temp_memory,json=hostTempMemory,proto3" json:"host_temp_memory,omitempty"`
	DeviceTempMemory int64 `protobuf:"varint,3,opt,name=device_temp_memory,json=deviceTempMemory,proto3" json:"device_temp_memory,omitempty"`
	// The persisted_memory doesn't include outputs.
	HostPersistentMemory   int64 `protobuf:"varint,4,opt,name=host_persistent_memory,json=hostPersistentMemory,proto3" json:"host_persistent_memory,omitempty"`
	DevicePersistentMemory int64 `protobuf:"varint,5,opt,name=device_persistent_memory,json=devicePersistentMemory,proto3" json:"device_persistent_memory,omitempty"`
}

func (m *OpPerformance_OpMemory) Reset()      { *m = OpPerformance_OpMemory{} }
func (*OpPerformance_OpMemory) ProtoMessage() {}
func (*OpPerformance_OpMemory) Descriptor() ([]byte, []int) {
	return fileDescriptorOpPerformanceData, []int{1, 0}
}

func (m *OpPerformance_OpMemory) GetOutputMemory() []int64 {
	if m != nil {
		return m.OutputMemory
	}
	return nil
}

func (m *OpPerformance_OpMemory) GetHostTempMemory() int64 {
	if m != nil {
		return m.HostTempMemory
	}
	return 0
}

func (m *OpPerformance_OpMemory) GetDeviceTempMemory() int64 {
	if m != nil {
		return m.DeviceTempMemory
	}
	return 0
}

func (m *OpPerformance_OpMemory) GetHostPersistentMemory() int64 {
	if m != nil {
		return m.HostPersistentMemory
	}
	return 0
}

func (m *OpPerformance_OpMemory) GetDevicePersistentMemory() int64 {
	if m != nil {
		return m.DevicePersistentMemory
	}
	return 0
}

// A collection of OpPerformance data points.
type OpPerformanceList struct {
	OpPerformance []*OpPerformance `protobuf:"bytes,1,rep,name=op_performance,json=opPerformance" json:"op_performance,omitempty"`
}

func (m *OpPerformanceList) Reset()      { *m = OpPerformanceList{} }
func (*OpPerformanceList) ProtoMessage() {}
func (*OpPerformanceList) Descriptor() ([]byte, []int) {
	return fileDescriptorOpPerformanceData, []int{2}
}

func (m *OpPerformanceList) GetOpPerformance() []*OpPerformance {
	if m != nil {
		return m.OpPerformance
	}
	return nil
}

func init() {
	proto.RegisterType((*OpInfo)(nil), "tensorflow.OpInfo")
	proto.RegisterType((*OpInfo_TensorProperties)(nil), "tensorflow.OpInfo.TensorProperties")
	proto.RegisterType((*OpPerformance)(nil), "tensorflow.OpPerformance")
	proto.RegisterType((*OpPerformance_OpMemory)(nil), "tensorflow.OpPerformance.OpMemory")
	proto.RegisterType((*OpPerformanceList)(nil), "tensorflow.OpPerformanceList")
}
func (this *OpInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OpInfo)
	if !ok {
		that2, ok := that.(OpInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if len(this.Attr) != len(that1.Attr) {
		return false
	}
	for i := range this.Attr {
		if !this.Attr[i].Equal(that1.Attr[i]) {
			return false
		}
	}
	if len(this.Inputs) != len(that1.Inputs) {
		return false
	}
	for i := range this.Inputs {
		if !this.Inputs[i].Equal(that1.Inputs[i]) {
			return false
		}
	}
	if len(this.Outputs) != len(that1.Outputs) {
		return false
	}
	for i := range this.Outputs {
		if !this.Outputs[i].Equal(that1.Outputs[i]) {
			return false
		}
	}
	if !this.Device.Equal(that1.Device) {
		return false
	}
	return true
}
func (this *OpInfo_TensorProperties) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OpInfo_TensorProperties)
	if !ok {
		that2, ok := that.(OpInfo_TensorProperties)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Dtype != that1.Dtype {
		return false
	}
	if !this.Shape.Equal(that1.Shape) {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *OpPerformance) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OpPerformance)
	if !ok {
		that2, ok := that.(OpPerformance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Op.Equal(that1.Op) {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	if this.TemporaryMemorySize != that1.TemporaryMemorySize {
		return false
	}
	if this.ComputeCost != that1.ComputeCost {
		return false
	}
	if this.ComputeTime != that1.ComputeTime {
		return false
	}
	if this.MemoryTime != that1.MemoryTime {
		return false
	}
	if this.ComputeEfficiency != that1.ComputeEfficiency {
		return false
	}
	if this.MemoryEfficiency != that1.MemoryEfficiency {
		return false
	}
	if !this.OpMemory.Equal(that1.OpMemory) {
		return false
	}
	return true
}
func (this *OpPerformance_OpMemory) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OpPerformance_OpMemory)
	if !ok {
		that2, ok := that.(OpPerformance_OpMemory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.OutputMemory) != len(that1.OutputMemory) {
		return false
	}
	for i := range this.OutputMemory {
		if this.OutputMemory[i] != that1.OutputMemory[i] {
			return false
		}
	}
	if this.HostTempMemory != that1.HostTempMemory {
		return false
	}
	if this.DeviceTempMemory != that1.DeviceTempMemory {
		return false
	}
	if this.HostPersistentMemory != that1.HostPersistentMemory {
		return false
	}
	if this.DevicePersistentMemory != that1.DevicePersistentMemory {
		return false
	}
	return true
}
func (this *OpPerformanceList) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OpPerformanceList)
	if !ok {
		that2, ok := that.(OpPerformanceList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.OpPerformance) != len(that1.OpPerformance) {
		return false
	}
	for i := range this.OpPerformance {
		if !this.OpPerformance[i].Equal(that1.OpPerformance[i]) {
			return false
		}
	}
	return true
}
func (this *OpInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tensorflow.OpInfo{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	keysForAttr := make([]string, 0, len(this.Attr))
	for k, _ := range this.Attr {
		keysForAttr = append(keysForAttr, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttr)
	mapStringForAttr := "map[string]*tensorflow5.AttrValue{"
	for _, k := range keysForAttr {
		mapStringForAttr += fmt.Sprintf("%#v: %#v,", k, this.Attr[k])
	}
	mapStringForAttr += "}"
	if this.Attr != nil {
		s = append(s, "Attr: "+mapStringForAttr+",\n")
	}
	if this.Inputs != nil {
		s = append(s, "Inputs: "+fmt.Sprintf("%#v", this.Inputs)+",\n")
	}
	if this.Outputs != nil {
		s = append(s, "Outputs: "+fmt.Sprintf("%#v", this.Outputs)+",\n")
	}
	if this.Device != nil {
		s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpInfo_TensorProperties) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow.OpInfo_TensorProperties{")
	s = append(s, "Dtype: "+fmt.Sprintf("%#v", this.Dtype)+",\n")
	if this.Shape != nil {
		s = append(s, "Shape: "+fmt.Sprintf("%#v", this.Shape)+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpPerformance) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&tensorflow.OpPerformance{")
	if this.Op != nil {
		s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	}
	s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	s = append(s, "TemporaryMemorySize: "+fmt.Sprintf("%#v", this.TemporaryMemorySize)+",\n")
	s = append(s, "ComputeCost: "+fmt.Sprintf("%#v", this.ComputeCost)+",\n")
	s = append(s, "ComputeTime: "+fmt.Sprintf("%#v", this.ComputeTime)+",\n")
	s = append(s, "MemoryTime: "+fmt.Sprintf("%#v", this.MemoryTime)+",\n")
	s = append(s, "ComputeEfficiency: "+fmt.Sprintf("%#v", this.ComputeEfficiency)+",\n")
	s = append(s, "MemoryEfficiency: "+fmt.Sprintf("%#v", this.MemoryEfficiency)+",\n")
	if this.OpMemory != nil {
		s = append(s, "OpMemory: "+fmt.Sprintf("%#v", this.OpMemory)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpPerformance_OpMemory) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tensorflow.OpPerformance_OpMemory{")
	s = append(s, "OutputMemory: "+fmt.Sprintf("%#v", this.OutputMemory)+",\n")
	s = append(s, "HostTempMemory: "+fmt.Sprintf("%#v", this.HostTempMemory)+",\n")
	s = append(s, "DeviceTempMemory: "+fmt.Sprintf("%#v", this.DeviceTempMemory)+",\n")
	s = append(s, "HostPersistentMemory: "+fmt.Sprintf("%#v", this.HostPersistentMemory)+",\n")
	s = append(s, "DevicePersistentMemory: "+fmt.Sprintf("%#v", this.DevicePersistentMemory)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OpPerformanceList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.OpPerformanceList{")
	if this.OpPerformance != nil {
		s = append(s, "OpPerformance: "+fmt.Sprintf("%#v", this.OpPerformance)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringOpPerformanceData(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *OpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Op) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(len(m.Op)))
		i += copy(dAtA[i:], m.Op)
	}
	if len(m.Attr) > 0 {
		for k, _ := range m.Attr {
			dAtA[i] = 0x12
			i++
			v := m.Attr[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovOpPerformanceData(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovOpPerformanceData(uint64(len(k))) + msgSize
			i = encodeVarintOpPerformanceData(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpPerformanceData(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintOpPerformanceData(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Inputs) > 0 {
		for _, msg := range m.Inputs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintOpPerformanceData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Device != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.Device.Size()))
		n2, err := m.Device.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Outputs) > 0 {
		for _, msg := range m.Outputs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintOpPerformanceData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OpInfo_TensorProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpInfo_TensorProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dtype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.Dtype))
	}
	if m.Shape != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.Shape.Size()))
		n3, err := m.Shape.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Value != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.Value.Size()))
		n4, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *OpPerformance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpPerformance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.Op.Size()))
		n5, err := m.Op.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.TemporaryMemorySize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.TemporaryMemorySize))
	}
	if m.ComputeCost != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.ComputeCost))
	}
	if m.ComputeEfficiency != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64OpPerformanceData(dAtA, i, uint64(math.Float64bits(float64(m.ComputeEfficiency))))
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if m.ComputeTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.ComputeTime))
	}
	if m.MemoryTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.MemoryTime))
	}
	if m.MemoryEfficiency != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64OpPerformanceData(dAtA, i, uint64(math.Float64bits(float64(m.MemoryEfficiency))))
	}
	if m.OpMemory != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.OpMemory.Size()))
		n6, err := m.OpMemory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *OpPerformance_OpMemory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpPerformance_OpMemory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OutputMemory) > 0 {
		dAtA8 := make([]byte, len(m.OutputMemory)*10)
		var j7 int
		for _, num1 := range m.OutputMemory {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.HostTempMemory != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.HostTempMemory))
	}
	if m.DeviceTempMemory != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.DeviceTempMemory))
	}
	if m.HostPersistentMemory != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.HostPersistentMemory))
	}
	if m.DevicePersistentMemory != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOpPerformanceData(dAtA, i, uint64(m.DevicePersistentMemory))
	}
	return i, nil
}

func (m *OpPerformanceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpPerformanceList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OpPerformance) > 0 {
		for _, msg := range m.OpPerformance {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOpPerformanceData(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64OpPerformanceData(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32OpPerformanceData(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintOpPerformanceData(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *OpInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovOpPerformanceData(uint64(l))
	}
	if len(m.Attr) > 0 {
		for k, v := range m.Attr {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovOpPerformanceData(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovOpPerformanceData(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovOpPerformanceData(uint64(mapEntrySize))
		}
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovOpPerformanceData(uint64(l))
		}
	}
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovOpPerformanceData(uint64(l))
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovOpPerformanceData(uint64(l))
		}
	}
	return n
}

func (m *OpInfo_TensorProperties) Size() (n int) {
	var l int
	_ = l
	if m.Dtype != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.Dtype))
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovOpPerformanceData(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovOpPerformanceData(uint64(l))
	}
	return n
}

func (m *OpPerformance) Size() (n int) {
	var l int
	_ = l
	if m.Op != nil {
		l = m.Op.Size()
		n += 1 + l + sovOpPerformanceData(uint64(l))
	}
	if m.TemporaryMemorySize != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.TemporaryMemorySize))
	}
	if m.ComputeCost != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.ComputeCost))
	}
	if m.ComputeEfficiency != 0 {
		n += 9
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovOpPerformanceData(uint64(l))
	}
	if m.ComputeTime != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.ComputeTime))
	}
	if m.MemoryTime != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.MemoryTime))
	}
	if m.MemoryEfficiency != 0 {
		n += 9
	}
	if m.OpMemory != nil {
		l = m.OpMemory.Size()
		n += 1 + l + sovOpPerformanceData(uint64(l))
	}
	return n
}

func (m *OpPerformance_OpMemory) Size() (n int) {
	var l int
	_ = l
	if len(m.OutputMemory) > 0 {
		l = 0
		for _, e := range m.OutputMemory {
			l += sovOpPerformanceData(uint64(e))
		}
		n += 1 + sovOpPerformanceData(uint64(l)) + l
	}
	if m.HostTempMemory != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.HostTempMemory))
	}
	if m.DeviceTempMemory != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.DeviceTempMemory))
	}
	if m.HostPersistentMemory != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.HostPersistentMemory))
	}
	if m.DevicePersistentMemory != 0 {
		n += 1 + sovOpPerformanceData(uint64(m.DevicePersistentMemory))
	}
	return n
}

func (m *OpPerformanceList) Size() (n int) {
	var l int
	_ = l
	if len(m.OpPerformance) > 0 {
		for _, e := range m.OpPerformance {
			l = e.Size()
			n += 1 + l + sovOpPerformanceData(uint64(l))
		}
	}
	return n
}

func sovOpPerformanceData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOpPerformanceData(x uint64) (n int) {
	return sovOpPerformanceData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *OpInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForAttr := make([]string, 0, len(this.Attr))
	for k, _ := range this.Attr {
		keysForAttr = append(keysForAttr, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAttr)
	mapStringForAttr := "map[string]*tensorflow5.AttrValue{"
	for _, k := range keysForAttr {
		mapStringForAttr += fmt.Sprintf("%v: %v,", k, this.Attr[k])
	}
	mapStringForAttr += "}"
	s := strings.Join([]string{`&OpInfo{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Attr:` + mapStringForAttr + `,`,
		`Inputs:` + strings.Replace(fmt.Sprintf("%v", this.Inputs), "OpInfo_TensorProperties", "OpInfo_TensorProperties", 1) + `,`,
		`Device:` + strings.Replace(fmt.Sprintf("%v", this.Device), "DeviceProperties", "tensorflow6.DeviceProperties", 1) + `,`,
		`Outputs:` + strings.Replace(fmt.Sprintf("%v", this.Outputs), "OpInfo_TensorProperties", "OpInfo_TensorProperties", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpInfo_TensorProperties) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpInfo_TensorProperties{`,
		`Dtype:` + fmt.Sprintf("%v", this.Dtype) + `,`,
		`Shape:` + strings.Replace(fmt.Sprintf("%v", this.Shape), "TensorShapeProto", "tensorflow2.TensorShapeProto", 1) + `,`,
		`Value:` + strings.Replace(fmt.Sprintf("%v", this.Value), "TensorProto", "tensorflow4.TensorProto", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpPerformance) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpPerformance{`,
		`Op:` + strings.Replace(fmt.Sprintf("%v", this.Op), "OpInfo", "OpInfo", 1) + `,`,
		`TemporaryMemorySize:` + fmt.Sprintf("%v", this.TemporaryMemorySize) + `,`,
		`ComputeCost:` + fmt.Sprintf("%v", this.ComputeCost) + `,`,
		`ComputeEfficiency:` + fmt.Sprintf("%v", this.ComputeEfficiency) + `,`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`ComputeTime:` + fmt.Sprintf("%v", this.ComputeTime) + `,`,
		`MemoryTime:` + fmt.Sprintf("%v", this.MemoryTime) + `,`,
		`MemoryEfficiency:` + fmt.Sprintf("%v", this.MemoryEfficiency) + `,`,
		`OpMemory:` + strings.Replace(fmt.Sprintf("%v", this.OpMemory), "OpPerformance_OpMemory", "OpPerformance_OpMemory", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpPerformance_OpMemory) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpPerformance_OpMemory{`,
		`OutputMemory:` + fmt.Sprintf("%v", this.OutputMemory) + `,`,
		`HostTempMemory:` + fmt.Sprintf("%v", this.HostTempMemory) + `,`,
		`DeviceTempMemory:` + fmt.Sprintf("%v", this.DeviceTempMemory) + `,`,
		`HostPersistentMemory:` + fmt.Sprintf("%v", this.HostPersistentMemory) + `,`,
		`DevicePersistentMemory:` + fmt.Sprintf("%v", this.DevicePersistentMemory) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpPerformanceList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpPerformanceList{`,
		`OpPerformance:` + strings.Replace(fmt.Sprintf("%v", this.OpPerformance), "OpPerformance", "OpPerformance", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringOpPerformanceData(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *OpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpPerformanceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attr == nil {
				m.Attr = make(map[string]*tensorflow5.AttrValue)
			}
			var mapkey string
			var mapvalue *tensorflow5.AttrValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpPerformanceData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpPerformanceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOpPerformanceData
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpPerformanceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthOpPerformanceData
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthOpPerformanceData
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &tensorflow5.AttrValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOpPerformanceData(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthOpPerformanceData
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attr[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &OpInfo_TensorProperties{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &tensorflow6.DeviceProperties{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &OpInfo_TensorProperties{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpPerformanceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpInfo_TensorProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpPerformanceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= (tensorflow3.DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &tensorflow2.TensorShapeProto{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &tensorflow4.TensorProto{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpPerformanceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpPerformance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpPerformanceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpPerformance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpPerformance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Op == nil {
				m.Op = &OpInfo{}
			}
			if err := m.Op.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryMemorySize", wireType)
			}
			m.TemporaryMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemporaryMemorySize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeCost", wireType)
			}
			m.ComputeCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputeCost |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeEfficiency", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.ComputeEfficiency = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeTime", wireType)
			}
			m.ComputeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputeTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryTime", wireType)
			}
			m.MemoryTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryEfficiency", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MemoryEfficiency = float64(math.Float64frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpMemory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpMemory == nil {
				m.OpMemory = &OpPerformance_OpMemory{}
			}
			if err := m.OpMemory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpPerformanceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpPerformance_OpMemory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpPerformanceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpMemory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpMemory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpPerformanceData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputMemory = append(m.OutputMemory, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOpPerformanceData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOpPerformanceData
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOpPerformanceData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputMemory = append(m.OutputMemory, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputMemory", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostTempMemory", wireType)
			}
			m.HostTempMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostTempMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceTempMemory", wireType)
			}
			m.DeviceTempMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceTempMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPersistentMemory", wireType)
			}
			m.HostPersistentMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPersistentMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevicePersistentMemory", wireType)
			}
			m.DevicePersistentMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevicePersistentMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOpPerformanceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpPerformanceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOpPerformanceData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpPerformanceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpPerformanceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpPerformance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpPerformance = append(m.OpPerformance, &OpPerformance{})
			if err := m.OpPerformance[len(m.OpPerformance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOpPerformanceData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpPerformanceData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOpPerformanceData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOpPerformanceData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOpPerformanceData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOpPerformanceData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOpPerformanceData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOpPerformanceData(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOpPerformanceData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOpPerformanceData   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/core/grappler/costs/op_performance_data.proto", fileDescriptorOpPerformanceData)
}

var fileDescriptorOpPerformanceData = []byte{
	// 732 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xcf, 0x6e, 0xd3, 0x4a,
	0x14, 0xc6, 0x33, 0x71, 0x92, 0x36, 0x27, 0x6d, 0x94, 0xce, 0x6d, 0x7b, 0x7d, 0xa3, 0x2b, 0xdf,
	0xdc, 0x54, 0xa0, 0xa8, 0x7f, 0x92, 0x2a, 0x74, 0x51, 0x81, 0x10, 0x14, 0xe8, 0x02, 0x09, 0x68,
	0xe4, 0x06, 0xb6, 0x96, 0x9b, 0x4c, 0xa8, 0xd5, 0xda, 0x33, 0x1a, 0x4f, 0x5a, 0xa5, 0x2b, 0x1e,
	0x81, 0x57, 0x60, 0xc7, 0xa3, 0xb0, 0xec, 0x92, 0x25, 0x0d, 0x1b, 0x96, 0xdd, 0x01, 0x3b, 0xe4,
	0x99, 0xb1, 0xeb, 0xa4, 0x14, 0xd8, 0x39, 0xe7, 0xfb, 0x7d, 0xe7, 0x9c, 0x7c, 0x33, 0x36, 0xec,
	0x30, 0x4e, 0x05, 0x3d, 0x18, 0x0e, 0x5a, 0x82, 0x04, 0x21, 0xe5, 0x83, 0x63, 0x7a, 0xda, 0xea,
	0x51, 0x4e, 0x5a, 0xaf, 0xb9, 0xcb, 0xd8, 0x31, 0xe1, 0xad, 0x1e, 0x0d, 0x45, 0xd8, 0xa2, 0xcc,
	0x61, 0x84, 0x0f, 0x28, 0xf7, 0xdd, 0xa0, 0x47, 0x9c, 0xbe, 0x2b, 0xdc, 0xa6, 0xf4, 0x62, 0xb8,
	0x72, 0x56, 0x6f, 0x4f, 0x77, 0x19, 0x70, 0xd7, 0x27, 0xa7, 0x94, 0x1f, 0xe9, 0xfe, 0xca, 0x53,
	0x5d, 0xff, 0x1d, 0xe7, 0x84, 0x87, 0x2e, 0x23, 0x9a, 0xbe, 0xf5, 0x0b, 0x7a, 0xc4, 0x48, 0xa8,
	0xb1, 0xd5, 0x9b, 0x31, 0x57, 0x08, 0xee, 0x9c, 0xb8, 0xc7, 0xc3, 0xb8, 0xe5, 0xe6, 0x34, 0x9b,
	0xe4, 0xd0, 0x27, 0x27, 0x5e, 0x8f, 0x38, 0x8c, 0x53, 0x46, 0xb8, 0xf0, 0xe2, 0xee, 0xf5, 0x4b,
	0x03, 0x0a, 0x7b, 0xec, 0x69, 0x30, 0xa0, 0xb8, 0x0c, 0x59, 0xca, 0x4c, 0x54, 0x43, 0x8d, 0xa2,
	0x9d, 0xa5, 0x0c, 0x6f, 0x42, 0x2e, 0x1a, 0x60, 0x66, 0x6b, 0x46, 0xa3, 0xd4, 0xfe, 0xb7, 0x79,
	0xd5, 0xbb, 0xa9, 0x1c, 0xcd, 0x1d, 0x21, 0xf8, 0x6e, 0x20, 0xf8, 0xc8, 0x96, 0x24, 0xbe, 0x07,
	0x05, 0x2f, 0x60, 0x43, 0x11, 0x9a, 0x86, 0xf4, 0xac, 0xfc, 0xc4, 0xd3, 0x95, 0x95, 0x4e, 0xb2,
	0x87, 0xad, 0x2d, 0x78, 0x0b, 0x0a, 0x6a, 0x49, 0x33, 0x57, 0x43, 0xd3, 0x03, 0x9f, 0x48, 0x25,
	0xed, 0x52, 0x2c, 0xbe, 0x0f, 0x33, 0x74, 0x28, 0xe4, 0xcc, 0xfc, 0x9f, 0xcf, 0x8c, 0x3d, 0xd5,
	0x17, 0x50, 0x4c, 0xfe, 0x04, 0xae, 0x80, 0x71, 0x44, 0x46, 0x3a, 0x81, 0xe8, 0x11, 0xaf, 0x41,
	0x5e, 0xc6, 0x6b, 0x66, 0xe5, 0x4a, 0x4b, 0xe9, 0xde, 0x91, 0xef, 0x55, 0x24, 0xda, 0x8a, 0xb9,
	0x9b, 0xdd, 0x46, 0xd5, 0x77, 0x08, 0x2a, 0xd3, 0xd3, 0xf0, 0x2a, 0xe4, 0xfb, 0xd1, 0x89, 0xca,
	0xce, 0xe5, 0xf6, 0xe2, 0xc4, 0x1f, 0x73, 0x85, 0xdb, 0x1d, 0x31, 0x62, 0x2b, 0x04, 0xb7, 0x21,
	0x2f, 0xef, 0x88, 0x9e, 0x38, 0x11, 0x82, 0x6a, 0xbc, 0x1f, 0xc9, 0x9d, 0xe8, 0xf0, 0x6c, 0x85,
	0xe2, 0x8d, 0x78, 0x4b, 0x43, 0x7a, 0xfe, 0xbe, 0xee, 0xd1, 0xb8, 0xa4, 0xea, 0xdf, 0x73, 0x30,
	0xbf, 0xc7, 0x3a, 0x57, 0xd7, 0x1e, 0xd7, 0x93, 0x93, 0x2f, 0xb5, 0xf1, 0xf5, 0xfc, 0xe4, 0x6d,
	0x68, 0xc3, 0x92, 0x20, 0x3e, 0xa3, 0xdc, 0xe5, 0x23, 0xc7, 0x27, 0x3e, 0xe5, 0x23, 0x27, 0xf4,
	0xce, 0xd4, 0xa2, 0x86, 0xfd, 0x57, 0x22, 0x3e, 0x97, 0xda, 0xbe, 0x77, 0x46, 0xf0, 0xff, 0x30,
	0xd7, 0xa3, 0x3e, 0x1b, 0x0a, 0xe2, 0x44, 0xaf, 0x9b, 0xdc, 0xcf, 0xb0, 0x4b, 0xba, 0xf6, 0x98,
	0x86, 0x02, 0x6f, 0x00, 0x8e, 0x11, 0x32, 0x18, 0x78, 0x3d, 0x8f, 0x04, 0xbd, 0x91, 0xbc, 0x01,
	0xc8, 0x5e, 0xd0, 0xca, 0x6e, 0x22, 0x60, 0x0c, 0xb9, 0x80, 0xf6, 0x89, 0x99, 0x97, 0x67, 0x24,
	0x9f, 0xd3, 0x53, 0x84, 0xe7, 0x13, 0xb3, 0x30, 0x31, 0xa5, 0xeb, 0xf9, 0x04, 0xff, 0x07, 0x25,
	0xbd, 0xb2, 0x24, 0x66, 0x24, 0x01, 0xaa, 0x24, 0x81, 0x35, 0x58, 0xd0, 0x40, 0x6a, 0x8b, 0x59,
	0xb9, 0x45, 0x45, 0x09, 0xa9, 0x25, 0x1e, 0x40, 0x91, 0x32, 0x9d, 0x81, 0x59, 0x94, 0xa9, 0xd5,
	0x27, 0x53, 0x4b, 0x85, 0xdb, 0xdc, 0x63, 0x2a, 0x11, 0x7b, 0x96, 0xea, 0xa7, 0xea, 0x57, 0x04,
	0xb3, 0x71, 0x19, 0xaf, 0xc0, 0xbc, 0xba, 0x8d, 0x71, 0x47, 0x54, 0x33, 0x1a, 0x86, 0x3d, 0xa7,
	0x8a, 0x1a, 0x6a, 0x40, 0xe5, 0x90, 0x86, 0xc2, 0x89, 0x52, 0x8e, 0x39, 0x15, 0x7c, 0x39, 0xaa,
	0x77, 0x89, 0x1f, 0xb7, 0x5b, 0x07, 0xac, 0xdf, 0xf5, 0x34, 0xab, 0x92, 0xaf, 0x28, 0x25, 0x45,
	0x6f, 0xc1, 0xb2, 0xec, 0xcb, 0x08, 0x0f, 0xbd, 0x50, 0x90, 0x20, 0xd9, 0x22, 0x27, 0x1d, 0x8b,
	0x91, 0xda, 0x49, 0x44, 0xed, 0xda, 0x06, 0x33, 0xfe, 0x9e, 0x5c, 0xf3, 0xe5, 0xa5, 0x6f, 0x59,
	0xe9, 0xd3, 0xce, 0xfa, 0x4b, 0x58, 0x98, 0x48, 0xe7, 0x99, 0x17, 0x0a, 0xfc, 0x10, 0xca, 0x93,
	0xdf, 0x61, 0x19, 0x41, 0xa9, 0xfd, 0xcf, 0x8d, 0xa1, 0xda, 0xf3, 0x34, 0xfd, 0xf3, 0x51, 0xeb,
	0xfc, 0xc2, 0xca, 0x7c, 0xbc, 0xb0, 0x32, 0x97, 0x17, 0x16, 0x7a, 0x33, 0xb6, 0xd0, 0xfb, 0xb1,
	0x85, 0x3e, 0x8c, 0x2d, 0x74, 0x3e, 0xb6, 0xd0, 0xa7, 0xb1, 0x85, 0xbe, 0x8c, 0xad, 0xcc, 0xe5,
	0xd8, 0x42, 0x6f, 0x3f, 0x5b, 0x99, 0x6f, 0x08, 0x1d, 0x14, 0xe4, 0xd7, 0xef, 0xce, 0x8f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x6e, 0xd2, 0xe4, 0x6a, 0x29, 0x06, 0x00, 0x00,
}
