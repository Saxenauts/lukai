// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/core/util/test_log.proto

/*
	Package tensorflow is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/core/util/test_log.proto

	It has these top-level messages:
		EntryValue
		BenchmarkEntry
		BenchmarkEntries
		BuildConfiguration
		CommitId
		CPUInfo
		MemoryInfo
		GPUInfo
		PlatformInfo
		AvailableDeviceInfo
		MachineConfiguration
		RunConfiguration
		TestResults
*/
package tensorflow

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"

import strconv "strconv"

import fmt "fmt"
import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// The type of benchmark.
type TestResults_BenchmarkType int32

const (
	UNKNOWN            TestResults_BenchmarkType = 0
	CPP_MICROBENCHMARK TestResults_BenchmarkType = 1
	PYTHON_BENCHMARK   TestResults_BenchmarkType = 2
	ANDROID_BENCHMARK  TestResults_BenchmarkType = 3
)

var TestResults_BenchmarkType_name = map[int32]string{
	0: "UNKNOWN",
	1: "CPP_MICROBENCHMARK",
	2: "PYTHON_BENCHMARK",
	3: "ANDROID_BENCHMARK",
}
var TestResults_BenchmarkType_value = map[string]int32{
	"UNKNOWN":            0,
	"CPP_MICROBENCHMARK": 1,
	"PYTHON_BENCHMARK":   2,
	"ANDROID_BENCHMARK":  3,
}

func (TestResults_BenchmarkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTestLog, []int{12, 0}
}

type EntryValue struct {
	// Types that are valid to be assigned to Kind:
	//	*EntryValue_DoubleValue
	//	*EntryValue_StringValue
	Kind isEntryValue_Kind `protobuf_oneof:"kind"`
}

func (m *EntryValue) Reset()                    { *m = EntryValue{} }
func (*EntryValue) ProtoMessage()               {}
func (*EntryValue) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{0} }

type isEntryValue_Kind interface {
	isEntryValue_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type EntryValue_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,1,opt,name=double_value,json=doubleValue,proto3,oneof"`
}
type EntryValue_StringValue struct {
	StringValue string `protobuf:"bytes,2,opt,name=string_value,json=stringValue,proto3,oneof"`
}

func (*EntryValue_DoubleValue) isEntryValue_Kind() {}
func (*EntryValue_StringValue) isEntryValue_Kind() {}

func (m *EntryValue) GetKind() isEntryValue_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *EntryValue) GetDoubleValue() float64 {
	if x, ok := m.GetKind().(*EntryValue_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *EntryValue) GetStringValue() string {
	if x, ok := m.GetKind().(*EntryValue_StringValue); ok {
		return x.StringValue
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EntryValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EntryValue_OneofMarshaler, _EntryValue_OneofUnmarshaler, _EntryValue_OneofSizer, []interface{}{
		(*EntryValue_DoubleValue)(nil),
		(*EntryValue_StringValue)(nil),
	}
}

func _EntryValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EntryValue)
	// kind
	switch x := m.Kind.(type) {
	case *EntryValue_DoubleValue:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.DoubleValue))
	case *EntryValue_StringValue:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.StringValue)
	case nil:
	default:
		return fmt.Errorf("EntryValue.Kind has unexpected type %T", x)
	}
	return nil
}

func _EntryValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EntryValue)
	switch tag {
	case 1: // kind.double_value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Kind = &EntryValue_DoubleValue{math.Float64frombits(x)}
		return true, err
	case 2: // kind.string_value
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Kind = &EntryValue_StringValue{x}
		return true, err
	default:
		return false, nil
	}
}

func _EntryValue_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EntryValue)
	// kind
	switch x := m.Kind.(type) {
	case *EntryValue_DoubleValue:
		n += proto.SizeVarint(1<<3 | proto.WireFixed64)
		n += 8
	case *EntryValue_StringValue:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.StringValue)))
		n += len(x.StringValue)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Each unit test or benchmark in a test or benchmark run provides
// some set of information.  Here we provide some reasonable keys
// one would expect to see, with optional key/value pairs for things
// we haven't considered.
//
// This BenchmarkEntry should be emitted by each unit test or benchmark
// reporter.
type BenchmarkEntry struct {
	// The name of the specific benchmark or test
	// (e.g. BM_AdjustContrast_gpu_B_W_H)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If a benchmark, how many iterations it was run for
	Iters int64 `protobuf:"varint,2,opt,name=iters,proto3" json:"iters,omitempty"`
	// Total cpu time used for all iterations (in seconds)
	CpuTime float64 `protobuf:"fixed64,3,opt,name=cpu_time,json=cpuTime,proto3" json:"cpu_time,omitempty"`
	// Total wall time used for all iterations (in seconds)
	WallTime float64 `protobuf:"fixed64,4,opt,name=wall_time,json=wallTime,proto3" json:"wall_time,omitempty"`
	// Throughput (in MB/s)
	Throughput float64 `protobuf:"fixed64,5,opt,name=throughput,proto3" json:"throughput,omitempty"`
	// Generic map from result key to value.
	Extras map[string]*EntryValue `protobuf:"bytes,6,rep,name=extras" json:"extras,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BenchmarkEntry) Reset()                    { *m = BenchmarkEntry{} }
func (*BenchmarkEntry) ProtoMessage()               {}
func (*BenchmarkEntry) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{1} }

func (m *BenchmarkEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BenchmarkEntry) GetIters() int64 {
	if m != nil {
		return m.Iters
	}
	return 0
}

func (m *BenchmarkEntry) GetCpuTime() float64 {
	if m != nil {
		return m.CpuTime
	}
	return 0
}

func (m *BenchmarkEntry) GetWallTime() float64 {
	if m != nil {
		return m.WallTime
	}
	return 0
}

func (m *BenchmarkEntry) GetThroughput() float64 {
	if m != nil {
		return m.Throughput
	}
	return 0
}

func (m *BenchmarkEntry) GetExtras() map[string]*EntryValue {
	if m != nil {
		return m.Extras
	}
	return nil
}

type BenchmarkEntries struct {
	Entry []*BenchmarkEntry `protobuf:"bytes,1,rep,name=entry" json:"entry,omitempty"`
}

func (m *BenchmarkEntries) Reset()                    { *m = BenchmarkEntries{} }
func (*BenchmarkEntries) ProtoMessage()               {}
func (*BenchmarkEntries) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{2} }

func (m *BenchmarkEntries) GetEntry() []*BenchmarkEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type BuildConfiguration struct {
	Mode    string   `protobuf:"bytes,1,opt,name=mode,proto3" json:"mode,omitempty"`
	CcFlags []string `protobuf:"bytes,2,rep,name=cc_flags,json=ccFlags" json:"cc_flags,omitempty"`
	Opts    []string `protobuf:"bytes,3,rep,name=opts" json:"opts,omitempty"`
}

func (m *BuildConfiguration) Reset()                    { *m = BuildConfiguration{} }
func (*BuildConfiguration) ProtoMessage()               {}
func (*BuildConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{3} }

func (m *BuildConfiguration) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *BuildConfiguration) GetCcFlags() []string {
	if m != nil {
		return m.CcFlags
	}
	return nil
}

func (m *BuildConfiguration) GetOpts() []string {
	if m != nil {
		return m.Opts
	}
	return nil
}

type CommitId struct {
	// Types that are valid to be assigned to Kind:
	//	*CommitId_Changelist
	//	*CommitId_Hash
	Kind isCommitId_Kind `protobuf_oneof:"kind"`
	// Hash of intermediate change between hash/changelist and what was tested.
	// Not used if the build is from a commit without modifications.
	Snapshot string `protobuf:"bytes,3,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *CommitId) Reset()                    { *m = CommitId{} }
func (*CommitId) ProtoMessage()               {}
func (*CommitId) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{4} }

type isCommitId_Kind interface {
	isCommitId_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommitId_Changelist struct {
	Changelist int64 `protobuf:"varint,1,opt,name=changelist,proto3,oneof"`
}
type CommitId_Hash struct {
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3,oneof"`
}

func (*CommitId_Changelist) isCommitId_Kind() {}
func (*CommitId_Hash) isCommitId_Kind()       {}

func (m *CommitId) GetKind() isCommitId_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *CommitId) GetChangelist() int64 {
	if x, ok := m.GetKind().(*CommitId_Changelist); ok {
		return x.Changelist
	}
	return 0
}

func (m *CommitId) GetHash() string {
	if x, ok := m.GetKind().(*CommitId_Hash); ok {
		return x.Hash
	}
	return ""
}

func (m *CommitId) GetSnapshot() string {
	if m != nil {
		return m.Snapshot
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommitId) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommitId_OneofMarshaler, _CommitId_OneofUnmarshaler, _CommitId_OneofSizer, []interface{}{
		(*CommitId_Changelist)(nil),
		(*CommitId_Hash)(nil),
	}
}

func _CommitId_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommitId)
	// kind
	switch x := m.Kind.(type) {
	case *CommitId_Changelist:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Changelist))
	case *CommitId_Hash:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Hash)
	case nil:
	default:
		return fmt.Errorf("CommitId.Kind has unexpected type %T", x)
	}
	return nil
}

func _CommitId_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommitId)
	switch tag {
	case 1: // kind.changelist
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Kind = &CommitId_Changelist{int64(x)}
		return true, err
	case 2: // kind.hash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Kind = &CommitId_Hash{x}
		return true, err
	default:
		return false, nil
	}
}

func _CommitId_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommitId)
	// kind
	switch x := m.Kind.(type) {
	case *CommitId_Changelist:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Changelist))
	case *CommitId_Hash:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Hash)))
		n += len(x.Hash)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CPUInfo struct {
	NumCores        int64 `protobuf:"varint,1,opt,name=num_cores,json=numCores,proto3" json:"num_cores,omitempty"`
	NumCoresAllowed int64 `protobuf:"varint,2,opt,name=num_cores_allowed,json=numCoresAllowed,proto3" json:"num_cores_allowed,omitempty"`
	// How fast are these cpus?
	MhzPerCpu float64 `protobuf:"fixed64,3,opt,name=mhz_per_cpu,json=mhzPerCpu,proto3" json:"mhz_per_cpu,omitempty"`
	// Additional cpu information. For example,
	// Intel Ivybridge with HyperThreading (24 cores) dL1:32KB dL2:256KB dL3:30MB
	CpuInfo string `protobuf:"bytes,4,opt,name=cpu_info,json=cpuInfo,proto3" json:"cpu_info,omitempty"`
	// What kind of cpu scaling is enabled on the host.
	// Examples include "performance", "ondemand", "conservative", "mixed".
	CpuGovernor string `protobuf:"bytes,5,opt,name=cpu_governor,json=cpuGovernor,proto3" json:"cpu_governor,omitempty"`
	// Cache sizes (in bytes), e.g. "L2": 262144 (for 256KB)
	CacheSize map[string]int64 `protobuf:"bytes,6,rep,name=cache_size,json=cacheSize" json:"cache_size,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *CPUInfo) Reset()                    { *m = CPUInfo{} }
func (*CPUInfo) ProtoMessage()               {}
func (*CPUInfo) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{5} }

func (m *CPUInfo) GetNumCores() int64 {
	if m != nil {
		return m.NumCores
	}
	return 0
}

func (m *CPUInfo) GetNumCoresAllowed() int64 {
	if m != nil {
		return m.NumCoresAllowed
	}
	return 0
}

func (m *CPUInfo) GetMhzPerCpu() float64 {
	if m != nil {
		return m.MhzPerCpu
	}
	return 0
}

func (m *CPUInfo) GetCpuInfo() string {
	if m != nil {
		return m.CpuInfo
	}
	return ""
}

func (m *CPUInfo) GetCpuGovernor() string {
	if m != nil {
		return m.CpuGovernor
	}
	return ""
}

func (m *CPUInfo) GetCacheSize() map[string]int64 {
	if m != nil {
		return m.CacheSize
	}
	return nil
}

type MemoryInfo struct {
	Total     int64 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Available int64 `protobuf:"varint,2,opt,name=available,proto3" json:"available,omitempty"`
}

func (m *MemoryInfo) Reset()                    { *m = MemoryInfo{} }
func (*MemoryInfo) ProtoMessage()               {}
func (*MemoryInfo) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{6} }

func (m *MemoryInfo) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *MemoryInfo) GetAvailable() int64 {
	if m != nil {
		return m.Available
	}
	return 0
}

type GPUInfo struct {
	Model string `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	Uuid  string `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	BusId string `protobuf:"bytes,3,opt,name=bus_id,json=busId,proto3" json:"bus_id,omitempty"`
}

func (m *GPUInfo) Reset()                    { *m = GPUInfo{} }
func (*GPUInfo) ProtoMessage()               {}
func (*GPUInfo) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{7} }

func (m *GPUInfo) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *GPUInfo) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *GPUInfo) GetBusId() string {
	if m != nil {
		return m.BusId
	}
	return ""
}

type PlatformInfo struct {
	Bits    string `protobuf:"bytes,1,opt,name=bits,proto3" json:"bits,omitempty"`
	Linkage string `protobuf:"bytes,2,opt,name=linkage,proto3" json:"linkage,omitempty"`
	Machine string `protobuf:"bytes,3,opt,name=machine,proto3" json:"machine,omitempty"`
	Release string `protobuf:"bytes,4,opt,name=release,proto3" json:"release,omitempty"`
	System  string `protobuf:"bytes,5,opt,name=system,proto3" json:"system,omitempty"`
	Version string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *PlatformInfo) Reset()                    { *m = PlatformInfo{} }
func (*PlatformInfo) ProtoMessage()               {}
func (*PlatformInfo) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{8} }

func (m *PlatformInfo) GetBits() string {
	if m != nil {
		return m.Bits
	}
	return ""
}

func (m *PlatformInfo) GetLinkage() string {
	if m != nil {
		return m.Linkage
	}
	return ""
}

func (m *PlatformInfo) GetMachine() string {
	if m != nil {
		return m.Machine
	}
	return ""
}

func (m *PlatformInfo) GetRelease() string {
	if m != nil {
		return m.Release
	}
	return ""
}

func (m *PlatformInfo) GetSystem() string {
	if m != nil {
		return m.System
	}
	return ""
}

func (m *PlatformInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type AvailableDeviceInfo struct {
	Name                string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	MemoryLimit         int64  `protobuf:"varint,3,opt,name=memory_limit,json=memoryLimit,proto3" json:"memory_limit,omitempty"`
	PhysicalDescription string `protobuf:"bytes,4,opt,name=physical_description,json=physicalDescription,proto3" json:"physical_description,omitempty"`
}

func (m *AvailableDeviceInfo) Reset()                    { *m = AvailableDeviceInfo{} }
func (*AvailableDeviceInfo) ProtoMessage()               {}
func (*AvailableDeviceInfo) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{9} }

func (m *AvailableDeviceInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AvailableDeviceInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AvailableDeviceInfo) GetMemoryLimit() int64 {
	if m != nil {
		return m.MemoryLimit
	}
	return 0
}

func (m *AvailableDeviceInfo) GetPhysicalDescription() string {
	if m != nil {
		return m.PhysicalDescription
	}
	return ""
}

type MachineConfiguration struct {
	// Host name of machine that ran the benchmark.
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Unique serial number of the machine.
	SerialIdentifier string `protobuf:"bytes,7,opt,name=serial_identifier,json=serialIdentifier,proto3" json:"serial_identifier,omitempty"`
	// Additional platform information.
	PlatformInfo *PlatformInfo `protobuf:"bytes,2,opt,name=platform_info,json=platformInfo" json:"platform_info,omitempty"`
	// CPU Information.
	CpuInfo *CPUInfo `protobuf:"bytes,3,opt,name=cpu_info,json=cpuInfo" json:"cpu_info,omitempty"`
	// Other devices that are attached and relevant (e.g. GPUInfo).
	DeviceInfo []*google_protobuf.Any `protobuf:"bytes,4,rep,name=device_info,json=deviceInfo" json:"device_info,omitempty"`
	// Devices accessible to the test (e.g. as given by list_local_devices).
	AvailableDeviceInfo []*AvailableDeviceInfo `protobuf:"bytes,5,rep,name=available_device_info,json=availableDeviceInfo" json:"available_device_info,omitempty"`
	MemoryInfo          *MemoryInfo            `protobuf:"bytes,6,opt,name=memory_info,json=memoryInfo" json:"memory_info,omitempty"`
}

func (m *MachineConfiguration) Reset()                    { *m = MachineConfiguration{} }
func (*MachineConfiguration) ProtoMessage()               {}
func (*MachineConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{10} }

func (m *MachineConfiguration) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *MachineConfiguration) GetSerialIdentifier() string {
	if m != nil {
		return m.SerialIdentifier
	}
	return ""
}

func (m *MachineConfiguration) GetPlatformInfo() *PlatformInfo {
	if m != nil {
		return m.PlatformInfo
	}
	return nil
}

func (m *MachineConfiguration) GetCpuInfo() *CPUInfo {
	if m != nil {
		return m.CpuInfo
	}
	return nil
}

func (m *MachineConfiguration) GetDeviceInfo() []*google_protobuf.Any {
	if m != nil {
		return m.DeviceInfo
	}
	return nil
}

func (m *MachineConfiguration) GetAvailableDeviceInfo() []*AvailableDeviceInfo {
	if m != nil {
		return m.AvailableDeviceInfo
	}
	return nil
}

func (m *MachineConfiguration) GetMemoryInfo() *MemoryInfo {
	if m != nil {
		return m.MemoryInfo
	}
	return nil
}

// Run-specific items such as arguments to the test / benchmark.
type RunConfiguration struct {
	Argument []string `protobuf:"bytes,1,rep,name=argument" json:"argument,omitempty"`
}

func (m *RunConfiguration) Reset()                    { *m = RunConfiguration{} }
func (*RunConfiguration) ProtoMessage()               {}
func (*RunConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{11} }

func (m *RunConfiguration) GetArgument() []string {
	if m != nil {
		return m.Argument
	}
	return nil
}

// The output of one benchmark / test run.  Each run contains a list of
// tests or benchmarks, stored as BenchmarkEntry messages.
//
// This message should be emitted by the reporter (which runs the
// test / BM in a subprocess and then reads the emitted BenchmarkEntry messages;
// usually from a serialized json file, finally collecting them along
// with additional information about the test run.
type TestResults struct {
	// The target of the run, e.g.:
	//  //tensorflow/core:kernels_adjust_contrast_op_benchmark_test
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// The list of tests or benchmarks in this run.
	Entries *BenchmarkEntries `protobuf:"bytes,2,opt,name=entries" json:"entries,omitempty"`
	// The configuration of the build (compiled opt? with cuda? any copts?)
	BuildConfiguration *BuildConfiguration `protobuf:"bytes,3,opt,name=build_configuration,json=buildConfiguration" json:"build_configuration,omitempty"`
	// The commit id (git hash or changelist)
	CommitId *CommitId `protobuf:"bytes,4,opt,name=commit_id,json=commitId" json:"commit_id,omitempty"`
	// The time the run started (in seconds of UTC time since Unix epoch)
	StartTime int64 `protobuf:"varint,5,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// The amount of time the total run took (wall time in seconds)
	RunTime float64 `protobuf:"fixed64,6,opt,name=run_time,json=runTime,proto3" json:"run_time,omitempty"`
	// Machine-specific parameters (Platform and CPU info)
	MachineConfiguration *MachineConfiguration `protobuf:"bytes,7,opt,name=machine_configuration,json=machineConfiguration" json:"machine_configuration,omitempty"`
	// Run-specific parameters (arguments, etc)
	RunConfiguration *RunConfiguration `protobuf:"bytes,8,opt,name=run_configuration,json=runConfiguration" json:"run_configuration,omitempty"`
	// Benchmark target identifier.
	Name          string                    `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	BenchmarkType TestResults_BenchmarkType `protobuf:"varint,10,opt,name=benchmark_type,json=benchmarkType,proto3,enum=tensorflow.TestResults_BenchmarkType" json:"benchmark_type,omitempty"`
	// Used for differentiating between continuous and debug builds.
	RunMode string `protobuf:"bytes,11,opt,name=run_mode,json=runMode,proto3" json:"run_mode,omitempty"`
}

func (m *TestResults) Reset()                    { *m = TestResults{} }
func (*TestResults) ProtoMessage()               {}
func (*TestResults) Descriptor() ([]byte, []int) { return fileDescriptorTestLog, []int{12} }

func (m *TestResults) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *TestResults) GetEntries() *BenchmarkEntries {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *TestResults) GetBuildConfiguration() *BuildConfiguration {
	if m != nil {
		return m.BuildConfiguration
	}
	return nil
}

func (m *TestResults) GetCommitId() *CommitId {
	if m != nil {
		return m.CommitId
	}
	return nil
}

func (m *TestResults) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *TestResults) GetRunTime() float64 {
	if m != nil {
		return m.RunTime
	}
	return 0
}

func (m *TestResults) GetMachineConfiguration() *MachineConfiguration {
	if m != nil {
		return m.MachineConfiguration
	}
	return nil
}

func (m *TestResults) GetRunConfiguration() *RunConfiguration {
	if m != nil {
		return m.RunConfiguration
	}
	return nil
}

func (m *TestResults) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TestResults) GetBenchmarkType() TestResults_BenchmarkType {
	if m != nil {
		return m.BenchmarkType
	}
	return UNKNOWN
}

func (m *TestResults) GetRunMode() string {
	if m != nil {
		return m.RunMode
	}
	return ""
}

func init() {
	proto.RegisterType((*EntryValue)(nil), "tensorflow.EntryValue")
	proto.RegisterType((*BenchmarkEntry)(nil), "tensorflow.BenchmarkEntry")
	proto.RegisterType((*BenchmarkEntries)(nil), "tensorflow.BenchmarkEntries")
	proto.RegisterType((*BuildConfiguration)(nil), "tensorflow.BuildConfiguration")
	proto.RegisterType((*CommitId)(nil), "tensorflow.CommitId")
	proto.RegisterType((*CPUInfo)(nil), "tensorflow.CPUInfo")
	proto.RegisterType((*MemoryInfo)(nil), "tensorflow.MemoryInfo")
	proto.RegisterType((*GPUInfo)(nil), "tensorflow.GPUInfo")
	proto.RegisterType((*PlatformInfo)(nil), "tensorflow.PlatformInfo")
	proto.RegisterType((*AvailableDeviceInfo)(nil), "tensorflow.AvailableDeviceInfo")
	proto.RegisterType((*MachineConfiguration)(nil), "tensorflow.MachineConfiguration")
	proto.RegisterType((*RunConfiguration)(nil), "tensorflow.RunConfiguration")
	proto.RegisterType((*TestResults)(nil), "tensorflow.TestResults")
	proto.RegisterEnum("tensorflow.TestResults_BenchmarkType", TestResults_BenchmarkType_name, TestResults_BenchmarkType_value)
}
func (x TestResults_BenchmarkType) String() string {
	s, ok := TestResults_BenchmarkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *EntryValue) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EntryValue)
	if !ok {
		that2, ok := that.(EntryValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *EntryValue_DoubleValue) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EntryValue_DoubleValue)
	if !ok {
		that2, ok := that.(EntryValue_DoubleValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.DoubleValue != that1.DoubleValue {
		return false
	}
	return true
}
func (this *EntryValue_StringValue) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EntryValue_StringValue)
	if !ok {
		that2, ok := that.(EntryValue_StringValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.StringValue != that1.StringValue {
		return false
	}
	return true
}
func (this *BenchmarkEntry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BenchmarkEntry)
	if !ok {
		that2, ok := that.(BenchmarkEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Iters != that1.Iters {
		return false
	}
	if this.CpuTime != that1.CpuTime {
		return false
	}
	if this.WallTime != that1.WallTime {
		return false
	}
	if this.Throughput != that1.Throughput {
		return false
	}
	if len(this.Extras) != len(that1.Extras) {
		return false
	}
	for i := range this.Extras {
		if !this.Extras[i].Equal(that1.Extras[i]) {
			return false
		}
	}
	return true
}
func (this *BenchmarkEntries) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BenchmarkEntries)
	if !ok {
		that2, ok := that.(BenchmarkEntries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Entry) != len(that1.Entry) {
		return false
	}
	for i := range this.Entry {
		if !this.Entry[i].Equal(that1.Entry[i]) {
			return false
		}
	}
	return true
}
func (this *BuildConfiguration) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BuildConfiguration)
	if !ok {
		that2, ok := that.(BuildConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if len(this.CcFlags) != len(that1.CcFlags) {
		return false
	}
	for i := range this.CcFlags {
		if this.CcFlags[i] != that1.CcFlags[i] {
			return false
		}
	}
	if len(this.Opts) != len(that1.Opts) {
		return false
	}
	for i := range this.Opts {
		if this.Opts[i] != that1.Opts[i] {
			return false
		}
	}
	return true
}
func (this *CommitId) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CommitId)
	if !ok {
		that2, ok := that.(CommitId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	if this.Snapshot != that1.Snapshot {
		return false
	}
	return true
}
func (this *CommitId_Changelist) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CommitId_Changelist)
	if !ok {
		that2, ok := that.(CommitId_Changelist)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Changelist != that1.Changelist {
		return false
	}
	return true
}
func (this *CommitId_Hash) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CommitId_Hash)
	if !ok {
		that2, ok := that.(CommitId_Hash)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Hash != that1.Hash {
		return false
	}
	return true
}
func (this *CPUInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CPUInfo)
	if !ok {
		that2, ok := that.(CPUInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NumCores != that1.NumCores {
		return false
	}
	if this.NumCoresAllowed != that1.NumCoresAllowed {
		return false
	}
	if this.MhzPerCpu != that1.MhzPerCpu {
		return false
	}
	if this.CpuInfo != that1.CpuInfo {
		return false
	}
	if this.CpuGovernor != that1.CpuGovernor {
		return false
	}
	if len(this.CacheSize) != len(that1.CacheSize) {
		return false
	}
	for i := range this.CacheSize {
		if this.CacheSize[i] != that1.CacheSize[i] {
			return false
		}
	}
	return true
}
func (this *MemoryInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MemoryInfo)
	if !ok {
		that2, ok := that.(MemoryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	if this.Available != that1.Available {
		return false
	}
	return true
}
func (this *GPUInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GPUInfo)
	if !ok {
		that2, ok := that.(GPUInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.Uuid != that1.Uuid {
		return false
	}
	if this.BusId != that1.BusId {
		return false
	}
	return true
}
func (this *PlatformInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PlatformInfo)
	if !ok {
		that2, ok := that.(PlatformInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Bits != that1.Bits {
		return false
	}
	if this.Linkage != that1.Linkage {
		return false
	}
	if this.Machine != that1.Machine {
		return false
	}
	if this.Release != that1.Release {
		return false
	}
	if this.System != that1.System {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}
func (this *AvailableDeviceInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AvailableDeviceInfo)
	if !ok {
		that2, ok := that.(AvailableDeviceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.MemoryLimit != that1.MemoryLimit {
		return false
	}
	if this.PhysicalDescription != that1.PhysicalDescription {
		return false
	}
	return true
}
func (this *MachineConfiguration) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MachineConfiguration)
	if !ok {
		that2, ok := that.(MachineConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.SerialIdentifier != that1.SerialIdentifier {
		return false
	}
	if !this.PlatformInfo.Equal(that1.PlatformInfo) {
		return false
	}
	if !this.CpuInfo.Equal(that1.CpuInfo) {
		return false
	}
	if len(this.DeviceInfo) != len(that1.DeviceInfo) {
		return false
	}
	for i := range this.DeviceInfo {
		if !this.DeviceInfo[i].Equal(that1.DeviceInfo[i]) {
			return false
		}
	}
	if len(this.AvailableDeviceInfo) != len(that1.AvailableDeviceInfo) {
		return false
	}
	for i := range this.AvailableDeviceInfo {
		if !this.AvailableDeviceInfo[i].Equal(that1.AvailableDeviceInfo[i]) {
			return false
		}
	}
	if !this.MemoryInfo.Equal(that1.MemoryInfo) {
		return false
	}
	return true
}
func (this *RunConfiguration) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RunConfiguration)
	if !ok {
		that2, ok := that.(RunConfiguration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Argument) != len(that1.Argument) {
		return false
	}
	for i := range this.Argument {
		if this.Argument[i] != that1.Argument[i] {
			return false
		}
	}
	return true
}
func (this *TestResults) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestResults)
	if !ok {
		that2, ok := that.(TestResults)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Target != that1.Target {
		return false
	}
	if !this.Entries.Equal(that1.Entries) {
		return false
	}
	if !this.BuildConfiguration.Equal(that1.BuildConfiguration) {
		return false
	}
	if !this.CommitId.Equal(that1.CommitId) {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.RunTime != that1.RunTime {
		return false
	}
	if !this.MachineConfiguration.Equal(that1.MachineConfiguration) {
		return false
	}
	if !this.RunConfiguration.Equal(that1.RunConfiguration) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.BenchmarkType != that1.BenchmarkType {
		return false
	}
	if this.RunMode != that1.RunMode {
		return false
	}
	return true
}
func (this *EntryValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow.EntryValue{")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EntryValue_DoubleValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow.EntryValue_DoubleValue{` +
		`DoubleValue:` + fmt.Sprintf("%#v", this.DoubleValue) + `}`}, ", ")
	return s
}
func (this *EntryValue_StringValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow.EntryValue_StringValue{` +
		`StringValue:` + fmt.Sprintf("%#v", this.StringValue) + `}`}, ", ")
	return s
}
func (this *BenchmarkEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tensorflow.BenchmarkEntry{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Iters: "+fmt.Sprintf("%#v", this.Iters)+",\n")
	s = append(s, "CpuTime: "+fmt.Sprintf("%#v", this.CpuTime)+",\n")
	s = append(s, "WallTime: "+fmt.Sprintf("%#v", this.WallTime)+",\n")
	s = append(s, "Throughput: "+fmt.Sprintf("%#v", this.Throughput)+",\n")
	keysForExtras := make([]string, 0, len(this.Extras))
	for k, _ := range this.Extras {
		keysForExtras = append(keysForExtras, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForExtras)
	mapStringForExtras := "map[string]*EntryValue{"
	for _, k := range keysForExtras {
		mapStringForExtras += fmt.Sprintf("%#v: %#v,", k, this.Extras[k])
	}
	mapStringForExtras += "}"
	if this.Extras != nil {
		s = append(s, "Extras: "+mapStringForExtras+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BenchmarkEntries) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.BenchmarkEntries{")
	if this.Entry != nil {
		s = append(s, "Entry: "+fmt.Sprintf("%#v", this.Entry)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BuildConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow.BuildConfiguration{")
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	s = append(s, "CcFlags: "+fmt.Sprintf("%#v", this.CcFlags)+",\n")
	s = append(s, "Opts: "+fmt.Sprintf("%#v", this.Opts)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CommitId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow.CommitId{")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "Snapshot: "+fmt.Sprintf("%#v", this.Snapshot)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CommitId_Changelist) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow.CommitId_Changelist{` +
		`Changelist:` + fmt.Sprintf("%#v", this.Changelist) + `}`}, ", ")
	return s
}
func (this *CommitId_Hash) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow.CommitId_Hash{` +
		`Hash:` + fmt.Sprintf("%#v", this.Hash) + `}`}, ", ")
	return s
}
func (this *CPUInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tensorflow.CPUInfo{")
	s = append(s, "NumCores: "+fmt.Sprintf("%#v", this.NumCores)+",\n")
	s = append(s, "NumCoresAllowed: "+fmt.Sprintf("%#v", this.NumCoresAllowed)+",\n")
	s = append(s, "MhzPerCpu: "+fmt.Sprintf("%#v", this.MhzPerCpu)+",\n")
	s = append(s, "CpuInfo: "+fmt.Sprintf("%#v", this.CpuInfo)+",\n")
	s = append(s, "CpuGovernor: "+fmt.Sprintf("%#v", this.CpuGovernor)+",\n")
	keysForCacheSize := make([]string, 0, len(this.CacheSize))
	for k, _ := range this.CacheSize {
		keysForCacheSize = append(keysForCacheSize, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCacheSize)
	mapStringForCacheSize := "map[string]int64{"
	for _, k := range keysForCacheSize {
		mapStringForCacheSize += fmt.Sprintf("%#v: %#v,", k, this.CacheSize[k])
	}
	mapStringForCacheSize += "}"
	if this.CacheSize != nil {
		s = append(s, "CacheSize: "+mapStringForCacheSize+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MemoryInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow.MemoryInfo{")
	s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	s = append(s, "Available: "+fmt.Sprintf("%#v", this.Available)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GPUInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow.GPUInfo{")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Uuid: "+fmt.Sprintf("%#v", this.Uuid)+",\n")
	s = append(s, "BusId: "+fmt.Sprintf("%#v", this.BusId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlatformInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tensorflow.PlatformInfo{")
	s = append(s, "Bits: "+fmt.Sprintf("%#v", this.Bits)+",\n")
	s = append(s, "Linkage: "+fmt.Sprintf("%#v", this.Linkage)+",\n")
	s = append(s, "Machine: "+fmt.Sprintf("%#v", this.Machine)+",\n")
	s = append(s, "Release: "+fmt.Sprintf("%#v", this.Release)+",\n")
	s = append(s, "System: "+fmt.Sprintf("%#v", this.System)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AvailableDeviceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow.AvailableDeviceInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "MemoryLimit: "+fmt.Sprintf("%#v", this.MemoryLimit)+",\n")
	s = append(s, "PhysicalDescription: "+fmt.Sprintf("%#v", this.PhysicalDescription)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MachineConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&tensorflow.MachineConfiguration{")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "SerialIdentifier: "+fmt.Sprintf("%#v", this.SerialIdentifier)+",\n")
	if this.PlatformInfo != nil {
		s = append(s, "PlatformInfo: "+fmt.Sprintf("%#v", this.PlatformInfo)+",\n")
	}
	if this.CpuInfo != nil {
		s = append(s, "CpuInfo: "+fmt.Sprintf("%#v", this.CpuInfo)+",\n")
	}
	if this.DeviceInfo != nil {
		s = append(s, "DeviceInfo: "+fmt.Sprintf("%#v", this.DeviceInfo)+",\n")
	}
	if this.AvailableDeviceInfo != nil {
		s = append(s, "AvailableDeviceInfo: "+fmt.Sprintf("%#v", this.AvailableDeviceInfo)+",\n")
	}
	if this.MemoryInfo != nil {
		s = append(s, "MemoryInfo: "+fmt.Sprintf("%#v", this.MemoryInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RunConfiguration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.RunConfiguration{")
	s = append(s, "Argument: "+fmt.Sprintf("%#v", this.Argument)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TestResults) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&tensorflow.TestResults{")
	s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	if this.Entries != nil {
		s = append(s, "Entries: "+fmt.Sprintf("%#v", this.Entries)+",\n")
	}
	if this.BuildConfiguration != nil {
		s = append(s, "BuildConfiguration: "+fmt.Sprintf("%#v", this.BuildConfiguration)+",\n")
	}
	if this.CommitId != nil {
		s = append(s, "CommitId: "+fmt.Sprintf("%#v", this.CommitId)+",\n")
	}
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "RunTime: "+fmt.Sprintf("%#v", this.RunTime)+",\n")
	if this.MachineConfiguration != nil {
		s = append(s, "MachineConfiguration: "+fmt.Sprintf("%#v", this.MachineConfiguration)+",\n")
	}
	if this.RunConfiguration != nil {
		s = append(s, "RunConfiguration: "+fmt.Sprintf("%#v", this.RunConfiguration)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "BenchmarkType: "+fmt.Sprintf("%#v", this.BenchmarkType)+",\n")
	s = append(s, "RunMode: "+fmt.Sprintf("%#v", this.RunMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTestLog(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *EntryValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		nn1, err := m.Kind.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *EntryValue_DoubleValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x9
	i++
	i = encodeFixed64TestLog(dAtA, i, uint64(math.Float64bits(float64(m.DoubleValue))))
	return i, nil
}
func (m *EntryValue_StringValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTestLog(dAtA, i, uint64(len(m.StringValue)))
	i += copy(dAtA[i:], m.StringValue)
	return i, nil
}
func (m *BenchmarkEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BenchmarkEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Iters != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.Iters))
	}
	if m.CpuTime != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64TestLog(dAtA, i, uint64(math.Float64bits(float64(m.CpuTime))))
	}
	if m.WallTime != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64TestLog(dAtA, i, uint64(math.Float64bits(float64(m.WallTime))))
	}
	if m.Throughput != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64TestLog(dAtA, i, uint64(math.Float64bits(float64(m.Throughput))))
	}
	if len(m.Extras) > 0 {
		for k, _ := range m.Extras {
			dAtA[i] = 0x32
			i++
			v := m.Extras[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTestLog(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTestLog(uint64(len(k))) + msgSize
			i = encodeVarintTestLog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTestLog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTestLog(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	return i, nil
}

func (m *BenchmarkEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BenchmarkEntries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entry) > 0 {
		for _, msg := range m.Entry {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTestLog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuildConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mode) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if len(m.CcFlags) > 0 {
		for _, s := range m.CcFlags {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Opts) > 0 {
		for _, s := range m.Opts {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CommitId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		nn3, err := m.Kind.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if len(m.Snapshot) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Snapshot)))
		i += copy(dAtA[i:], m.Snapshot)
	}
	return i, nil
}

func (m *CommitId_Changelist) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintTestLog(dAtA, i, uint64(m.Changelist))
	return i, nil
}
func (m *CommitId_Hash) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintTestLog(dAtA, i, uint64(len(m.Hash)))
	i += copy(dAtA[i:], m.Hash)
	return i, nil
}
func (m *CPUInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumCores != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.NumCores))
	}
	if m.NumCoresAllowed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.NumCoresAllowed))
	}
	if m.MhzPerCpu != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64TestLog(dAtA, i, uint64(math.Float64bits(float64(m.MhzPerCpu))))
	}
	if len(m.CpuInfo) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.CpuInfo)))
		i += copy(dAtA[i:], m.CpuInfo)
	}
	if len(m.CpuGovernor) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.CpuGovernor)))
		i += copy(dAtA[i:], m.CpuGovernor)
	}
	if len(m.CacheSize) > 0 {
		for k, _ := range m.CacheSize {
			dAtA[i] = 0x32
			i++
			v := m.CacheSize[k]
			mapSize := 1 + len(k) + sovTestLog(uint64(len(k))) + 1 + sovTestLog(uint64(v))
			i = encodeVarintTestLog(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTestLog(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTestLog(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *MemoryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.Total))
	}
	if m.Available != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.Available))
	}
	return i, nil
}

func (m *GPUInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Model) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.BusId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.BusId)))
		i += copy(dAtA[i:], m.BusId)
	}
	return i, nil
}

func (m *PlatformInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatformInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Bits) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Bits)))
		i += copy(dAtA[i:], m.Bits)
	}
	if len(m.Linkage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Linkage)))
		i += copy(dAtA[i:], m.Linkage)
	}
	if len(m.Machine) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Machine)))
		i += copy(dAtA[i:], m.Machine)
	}
	if len(m.Release) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Release)))
		i += copy(dAtA[i:], m.Release)
	}
	if len(m.System) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.System)))
		i += copy(dAtA[i:], m.System)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *AvailableDeviceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvailableDeviceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.MemoryLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.MemoryLimit))
	}
	if len(m.PhysicalDescription) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.PhysicalDescription)))
		i += copy(dAtA[i:], m.PhysicalDescription)
	}
	return i, nil
}

func (m *MachineConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.PlatformInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.PlatformInfo.Size()))
		n4, err := m.PlatformInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.CpuInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.CpuInfo.Size()))
		n5, err := m.CpuInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.DeviceInfo) > 0 {
		for _, msg := range m.DeviceInfo {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTestLog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AvailableDeviceInfo) > 0 {
		for _, msg := range m.AvailableDeviceInfo {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTestLog(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MemoryInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.MemoryInfo.Size()))
		n6, err := m.MemoryInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.SerialIdentifier) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.SerialIdentifier)))
		i += copy(dAtA[i:], m.SerialIdentifier)
	}
	return i, nil
}

func (m *RunConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Argument) > 0 {
		for _, s := range m.Argument {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *TestResults) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestResults) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.Entries != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.Entries.Size()))
		n7, err := m.Entries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.BuildConfiguration != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.BuildConfiguration.Size()))
		n8, err := m.BuildConfiguration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CommitId != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.CommitId.Size()))
		n9, err := m.CommitId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.StartTime))
	}
	if m.RunTime != 0 {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64TestLog(dAtA, i, uint64(math.Float64bits(float64(m.RunTime))))
	}
	if m.MachineConfiguration != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.MachineConfiguration.Size()))
		n10, err := m.MachineConfiguration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.RunConfiguration != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.RunConfiguration.Size()))
		n11, err := m.RunConfiguration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.BenchmarkType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(m.BenchmarkType))
	}
	if len(m.RunMode) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTestLog(dAtA, i, uint64(len(m.RunMode)))
		i += copy(dAtA[i:], m.RunMode)
	}
	return i, nil
}

func encodeFixed64TestLog(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32TestLog(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTestLog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EntryValue) Size() (n int) {
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *EntryValue_DoubleValue) Size() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *EntryValue_StringValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovTestLog(uint64(l))
	return n
}
func (m *BenchmarkEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.Iters != 0 {
		n += 1 + sovTestLog(uint64(m.Iters))
	}
	if m.CpuTime != 0 {
		n += 9
	}
	if m.WallTime != 0 {
		n += 9
	}
	if m.Throughput != 0 {
		n += 9
	}
	if len(m.Extras) > 0 {
		for k, v := range m.Extras {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTestLog(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTestLog(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTestLog(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BenchmarkEntries) Size() (n int) {
	var l int
	_ = l
	if len(m.Entry) > 0 {
		for _, e := range m.Entry {
			l = e.Size()
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	return n
}

func (m *BuildConfiguration) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if len(m.CcFlags) > 0 {
		for _, s := range m.CcFlags {
			l = len(s)
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	if len(m.Opts) > 0 {
		for _, s := range m.Opts {
			l = len(s)
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	return n
}

func (m *CommitId) Size() (n int) {
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	l = len(m.Snapshot)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *CommitId_Changelist) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTestLog(uint64(m.Changelist))
	return n
}
func (m *CommitId_Hash) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hash)
	n += 1 + l + sovTestLog(uint64(l))
	return n
}
func (m *CPUInfo) Size() (n int) {
	var l int
	_ = l
	if m.NumCores != 0 {
		n += 1 + sovTestLog(uint64(m.NumCores))
	}
	if m.NumCoresAllowed != 0 {
		n += 1 + sovTestLog(uint64(m.NumCoresAllowed))
	}
	if m.MhzPerCpu != 0 {
		n += 9
	}
	l = len(m.CpuInfo)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.CpuGovernor)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if len(m.CacheSize) > 0 {
		for k, v := range m.CacheSize {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTestLog(uint64(len(k))) + 1 + sovTestLog(uint64(v))
			n += mapEntrySize + 1 + sovTestLog(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MemoryInfo) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovTestLog(uint64(m.Total))
	}
	if m.Available != 0 {
		n += 1 + sovTestLog(uint64(m.Available))
	}
	return n
}

func (m *GPUInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.BusId)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *PlatformInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Bits)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Linkage)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Machine)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Release)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.System)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *AvailableDeviceInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovTestLog(uint64(m.MemoryLimit))
	}
	l = len(m.PhysicalDescription)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *MachineConfiguration) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.PlatformInfo != nil {
		l = m.PlatformInfo.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.CpuInfo != nil {
		l = m.CpuInfo.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if len(m.DeviceInfo) > 0 {
		for _, e := range m.DeviceInfo {
			l = e.Size()
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	if len(m.AvailableDeviceInfo) > 0 {
		for _, e := range m.AvailableDeviceInfo {
			l = e.Size()
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	if m.MemoryInfo != nil {
		l = m.MemoryInfo.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.SerialIdentifier)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func (m *RunConfiguration) Size() (n int) {
	var l int
	_ = l
	if len(m.Argument) > 0 {
		for _, s := range m.Argument {
			l = len(s)
			n += 1 + l + sovTestLog(uint64(l))
		}
	}
	return n
}

func (m *TestResults) Size() (n int) {
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.Entries != nil {
		l = m.Entries.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.BuildConfiguration != nil {
		l = m.BuildConfiguration.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.CommitId != nil {
		l = m.CommitId.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovTestLog(uint64(m.StartTime))
	}
	if m.RunTime != 0 {
		n += 9
	}
	if m.MachineConfiguration != nil {
		l = m.MachineConfiguration.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.RunConfiguration != nil {
		l = m.RunConfiguration.Size()
		n += 1 + l + sovTestLog(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	if m.BenchmarkType != 0 {
		n += 1 + sovTestLog(uint64(m.BenchmarkType))
	}
	l = len(m.RunMode)
	if l > 0 {
		n += 1 + l + sovTestLog(uint64(l))
	}
	return n
}

func sovTestLog(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTestLog(x uint64) (n int) {
	return sovTestLog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EntryValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EntryValue{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EntryValue_DoubleValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EntryValue_DoubleValue{`,
		`DoubleValue:` + fmt.Sprintf("%v", this.DoubleValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EntryValue_StringValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EntryValue_StringValue{`,
		`StringValue:` + fmt.Sprintf("%v", this.StringValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BenchmarkEntry) String() string {
	if this == nil {
		return "nil"
	}
	keysForExtras := make([]string, 0, len(this.Extras))
	for k, _ := range this.Extras {
		keysForExtras = append(keysForExtras, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForExtras)
	mapStringForExtras := "map[string]*EntryValue{"
	for _, k := range keysForExtras {
		mapStringForExtras += fmt.Sprintf("%v: %v,", k, this.Extras[k])
	}
	mapStringForExtras += "}"
	s := strings.Join([]string{`&BenchmarkEntry{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Iters:` + fmt.Sprintf("%v", this.Iters) + `,`,
		`CpuTime:` + fmt.Sprintf("%v", this.CpuTime) + `,`,
		`WallTime:` + fmt.Sprintf("%v", this.WallTime) + `,`,
		`Throughput:` + fmt.Sprintf("%v", this.Throughput) + `,`,
		`Extras:` + mapStringForExtras + `,`,
		`}`,
	}, "")
	return s
}
func (this *BenchmarkEntries) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BenchmarkEntries{`,
		`Entry:` + strings.Replace(fmt.Sprintf("%v", this.Entry), "BenchmarkEntry", "BenchmarkEntry", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BuildConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BuildConfiguration{`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`CcFlags:` + fmt.Sprintf("%v", this.CcFlags) + `,`,
		`Opts:` + fmt.Sprintf("%v", this.Opts) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CommitId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CommitId{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Snapshot:` + fmt.Sprintf("%v", this.Snapshot) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CommitId_Changelist) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CommitId_Changelist{`,
		`Changelist:` + fmt.Sprintf("%v", this.Changelist) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CommitId_Hash) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CommitId_Hash{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPUInfo) String() string {
	if this == nil {
		return "nil"
	}
	keysForCacheSize := make([]string, 0, len(this.CacheSize))
	for k, _ := range this.CacheSize {
		keysForCacheSize = append(keysForCacheSize, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCacheSize)
	mapStringForCacheSize := "map[string]int64{"
	for _, k := range keysForCacheSize {
		mapStringForCacheSize += fmt.Sprintf("%v: %v,", k, this.CacheSize[k])
	}
	mapStringForCacheSize += "}"
	s := strings.Join([]string{`&CPUInfo{`,
		`NumCores:` + fmt.Sprintf("%v", this.NumCores) + `,`,
		`NumCoresAllowed:` + fmt.Sprintf("%v", this.NumCoresAllowed) + `,`,
		`MhzPerCpu:` + fmt.Sprintf("%v", this.MhzPerCpu) + `,`,
		`CpuInfo:` + fmt.Sprintf("%v", this.CpuInfo) + `,`,
		`CpuGovernor:` + fmt.Sprintf("%v", this.CpuGovernor) + `,`,
		`CacheSize:` + mapStringForCacheSize + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemoryInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemoryInfo{`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`Available:` + fmt.Sprintf("%v", this.Available) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GPUInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GPUInfo{`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Uuid:` + fmt.Sprintf("%v", this.Uuid) + `,`,
		`BusId:` + fmt.Sprintf("%v", this.BusId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlatformInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlatformInfo{`,
		`Bits:` + fmt.Sprintf("%v", this.Bits) + `,`,
		`Linkage:` + fmt.Sprintf("%v", this.Linkage) + `,`,
		`Machine:` + fmt.Sprintf("%v", this.Machine) + `,`,
		`Release:` + fmt.Sprintf("%v", this.Release) + `,`,
		`System:` + fmt.Sprintf("%v", this.System) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AvailableDeviceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AvailableDeviceInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`MemoryLimit:` + fmt.Sprintf("%v", this.MemoryLimit) + `,`,
		`PhysicalDescription:` + fmt.Sprintf("%v", this.PhysicalDescription) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MachineConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MachineConfiguration{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`PlatformInfo:` + strings.Replace(fmt.Sprintf("%v", this.PlatformInfo), "PlatformInfo", "PlatformInfo", 1) + `,`,
		`CpuInfo:` + strings.Replace(fmt.Sprintf("%v", this.CpuInfo), "CPUInfo", "CPUInfo", 1) + `,`,
		`DeviceInfo:` + strings.Replace(fmt.Sprintf("%v", this.DeviceInfo), "Any", "google_protobuf.Any", 1) + `,`,
		`AvailableDeviceInfo:` + strings.Replace(fmt.Sprintf("%v", this.AvailableDeviceInfo), "AvailableDeviceInfo", "AvailableDeviceInfo", 1) + `,`,
		`MemoryInfo:` + strings.Replace(fmt.Sprintf("%v", this.MemoryInfo), "MemoryInfo", "MemoryInfo", 1) + `,`,
		`SerialIdentifier:` + fmt.Sprintf("%v", this.SerialIdentifier) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RunConfiguration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RunConfiguration{`,
		`Argument:` + fmt.Sprintf("%v", this.Argument) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestResults) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestResults{`,
		`Target:` + fmt.Sprintf("%v", this.Target) + `,`,
		`Entries:` + strings.Replace(fmt.Sprintf("%v", this.Entries), "BenchmarkEntries", "BenchmarkEntries", 1) + `,`,
		`BuildConfiguration:` + strings.Replace(fmt.Sprintf("%v", this.BuildConfiguration), "BuildConfiguration", "BuildConfiguration", 1) + `,`,
		`CommitId:` + strings.Replace(fmt.Sprintf("%v", this.CommitId), "CommitId", "CommitId", 1) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`RunTime:` + fmt.Sprintf("%v", this.RunTime) + `,`,
		`MachineConfiguration:` + strings.Replace(fmt.Sprintf("%v", this.MachineConfiguration), "MachineConfiguration", "MachineConfiguration", 1) + `,`,
		`RunConfiguration:` + strings.Replace(fmt.Sprintf("%v", this.RunConfiguration), "RunConfiguration", "RunConfiguration", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`BenchmarkType:` + fmt.Sprintf("%v", this.BenchmarkType) + `,`,
		`RunMode:` + fmt.Sprintf("%v", this.RunMode) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTestLog(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EntryValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Kind = &EntryValue_DoubleValue{float64(math.Float64frombits(v))}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = &EntryValue_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BenchmarkEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BenchmarkEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BenchmarkEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iters", wireType)
			}
			m.Iters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iters |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CpuTime = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.WallTime = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Throughput", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Throughput = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extras", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extras == nil {
				m.Extras = make(map[string]*EntryValue)
			}
			var mapkey string
			var mapvalue *EntryValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTestLog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTestLog
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTestLog
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EntryValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTestLog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTestLog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Extras[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BenchmarkEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BenchmarkEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BenchmarkEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entry = append(m.Entry, &BenchmarkEntry{})
			if err := m.Entry[len(m.Entry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcFlags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CcFlags = append(m.CcFlags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Opts = append(m.Opts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changelist", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kind = &CommitId_Changelist{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = &CommitId_Hash{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snapshot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCores", wireType)
			}
			m.NumCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCores |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCoresAllowed", wireType)
			}
			m.NumCoresAllowed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCoresAllowed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MhzPerCpu", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MhzPerCpu = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuGovernor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuGovernor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheSize == nil {
				m.CacheSize = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTestLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTestLog
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTestLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTestLog(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTestLog
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CacheSize[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BusId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatformInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatformInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatformInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bits = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linkage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Linkage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machine = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Release = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.System = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvailableDeviceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvailableDeviceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvailableDeviceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryLimit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MachineConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MachineConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlatformInfo == nil {
				m.PlatformInfo = &PlatformInfo{}
			}
			if err := m.PlatformInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuInfo == nil {
				m.CpuInfo = &CPUInfo{}
			}
			if err := m.CpuInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceInfo = append(m.DeviceInfo, &google_protobuf.Any{})
			if err := m.DeviceInfo[len(m.DeviceInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableDeviceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableDeviceInfo = append(m.AvailableDeviceInfo, &AvailableDeviceInfo{})
			if err := m.AvailableDeviceInfo[len(m.AvailableDeviceInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryInfo == nil {
				m.MemoryInfo = &MemoryInfo{}
			}
			if err := m.MemoryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argument = append(m.Argument, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestResults) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestResults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestResults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = &BenchmarkEntries{}
			}
			if err := m.Entries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildConfiguration == nil {
				m.BuildConfiguration = &BuildConfiguration{}
			}
			if err := m.BuildConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitId == nil {
				m.CommitId = &CommitId{}
			}
			if err := m.CommitId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.RunTime = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MachineConfiguration == nil {
				m.MachineConfiguration = &MachineConfiguration{}
			}
			if err := m.MachineConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunConfiguration == nil {
				m.RunConfiguration = &RunConfiguration{}
			}
			if err := m.RunConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BenchmarkType", wireType)
			}
			m.BenchmarkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BenchmarkType |= (TestResults_BenchmarkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTestLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTestLog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTestLog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTestLog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTestLog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTestLog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTestLog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTestLog   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("protobuf/tensorflow/core/util/test_log.proto", fileDescriptorTestLog) }

var fileDescriptorTestLog = []byte{
	// 1323 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x56, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xc6, 0xf1, 0xd7, 0x73, 0x12, 0x9c, 0x89, 0x53, 0xb9, 0x69, 0x31, 0xc1, 0x08, 0x14,
	0x41, 0xe5, 0xd0, 0x22, 0x3e, 0x84, 0x00, 0x91, 0x38, 0xa5, 0x09, 0x6d, 0x12, 0x33, 0x4d, 0xa9,
	0x38, 0xc0, 0x6a, 0xbd, 0x1e, 0xaf, 0x47, 0xd9, 0xdd, 0x59, 0xcd, 0xcc, 0xa6, 0x38, 0x27, 0xfe,
	0x04, 0xa4, 0x9e, 0xb9, 0x20, 0x21, 0x71, 0xe5, 0xbf, 0xe0, 0xd8, 0x23, 0x47, 0x6a, 0x2e, 0x1c,
	0x7b, 0xe4, 0x88, 0xe6, 0x63, 0xed, 0x75, 0x93, 0xde, 0xe6, 0x7d, 0xec, 0x9b, 0x37, 0xef, 0xf7,
	0x7b, 0xef, 0x2d, 0xdc, 0x4a, 0x38, 0x93, 0xac, 0x9f, 0x0e, 0x77, 0x24, 0x89, 0x05, 0xe3, 0xc3,
	0x90, 0x3d, 0xd9, 0xf1, 0x19, 0x27, 0x3b, 0xa9, 0xa4, 0xe1, 0x8e, 0x24, 0x42, 0xba, 0x21, 0x0b,
	0x3a, 0xda, 0x0d, 0xc1, 0xcc, 0x69, 0xf3, 0x7a, 0xc0, 0x58, 0x10, 0x92, 0x9d, 0x69, 0x00, 0x2f,
	0x1e, 0x1b, 0xb7, 0xf6, 0x0f, 0x00, 0x77, 0x63, 0xc9, 0xc7, 0xdf, 0x7a, 0x61, 0x4a, 0xd0, 0x5b,
	0xb0, 0x3c, 0x60, 0x69, 0x3f, 0x24, 0xee, 0xb9, 0x92, 0x9b, 0xce, 0x96, 0xb3, 0xed, 0x1c, 0x2c,
	0xe0, 0x9a, 0xd1, 0x4e, 0x9d, 0x84, 0xe4, 0x34, 0x0e, 0xac, 0xd3, 0xe2, 0x96, 0xb3, 0x5d, 0x55,
	0x4e, 0x46, 0xab, 0x9d, 0xf6, 0x4a, 0xb0, 0x74, 0x46, 0xe3, 0x41, 0xfb, 0xb7, 0x45, 0x58, 0xdd,
	0x23, 0xb1, 0x3f, 0x8a, 0x3c, 0x7e, 0xa6, 0x6f, 0x42, 0x08, 0x96, 0x62, 0x2f, 0x32, 0xc1, 0xab,
	0x58, 0x9f, 0x51, 0x03, 0x8a, 0x54, 0x12, 0x2e, 0x74, 0xb0, 0x02, 0x36, 0x02, 0xba, 0x0e, 0x15,
	0x3f, 0x49, 0x5d, 0x49, 0x23, 0xd2, 0x2c, 0xa8, 0x54, 0x70, 0xd9, 0x4f, 0xd2, 0x53, 0x1a, 0x11,
	0x74, 0x03, 0xaa, 0x4f, 0xbc, 0x30, 0x34, 0xb6, 0x25, 0x6d, 0xab, 0x28, 0x85, 0x36, 0xb6, 0x00,
	0xe4, 0x88, 0xb3, 0x34, 0x18, 0x25, 0xa9, 0x6c, 0x16, 0xb5, 0x35, 0xa7, 0x41, 0x5f, 0x40, 0x89,
	0xfc, 0x28, 0xb9, 0x27, 0x9a, 0xa5, 0xad, 0xc2, 0x76, 0xed, 0xce, 0x3b, 0x9d, 0x59, 0xb1, 0x3a,
	0xf3, 0xd9, 0x76, 0xee, 0x6a, 0x47, 0x7d, 0xc6, 0xf6, 0xab, 0xcd, 0x6f, 0xa0, 0x96, 0x53, 0xa3,
	0x3a, 0x14, 0xce, 0xc8, 0xd8, 0xbe, 0x47, 0x1d, 0xd1, 0x2d, 0x28, 0xce, 0x6a, 0x53, 0xbb, 0x73,
	0x2d, 0x1f, 0x7f, 0x56, 0x6e, 0x6c, 0x9c, 0x3e, 0x5d, 0xfc, 0xc4, 0x69, 0xef, 0x43, 0x7d, 0xee,
	0x62, 0x4a, 0x04, 0x7a, 0x1f, 0x8a, 0x44, 0x39, 0x37, 0x1d, 0x9d, 0xe5, 0xe6, 0xab, 0xb3, 0xc4,
	0xc6, 0xb1, 0xfd, 0x18, 0xd0, 0x5e, 0x4a, 0xc3, 0x41, 0x97, 0xc5, 0x43, 0x1a, 0xa4, 0xdc, 0x93,
	0x94, 0xc5, 0xaa, 0xe0, 0x11, 0x1b, 0x4c, 0x0b, 0xae, 0xce, 0xba, 0xb4, 0xbe, 0x3b, 0x0c, 0xbd,
	0x40, 0xd5, 0xbc, 0xb0, 0x5d, 0xc5, 0x65, 0xdf, 0xff, 0x4a, 0x89, 0xca, 0x9d, 0x25, 0x52, 0x34,
	0x0b, 0x5a, 0xad, 0xcf, 0xed, 0x21, 0x54, 0xba, 0x2c, 0x8a, 0xa8, 0x3c, 0x1c, 0xa0, 0x2d, 0x00,
	0x7f, 0xe4, 0xc5, 0x01, 0x09, 0xa9, 0x90, 0x3a, 0x68, 0xe1, 0x60, 0x01, 0xe7, 0x74, 0xa8, 0x01,
	0x4b, 0x23, 0x4f, 0x8c, 0xa6, 0xcc, 0xd0, 0x12, 0xda, 0x84, 0x8a, 0x88, 0xbd, 0x44, 0x8c, 0x98,
	0xd4, 0x68, 0x56, 0xf1, 0x54, 0x9e, 0xd2, 0xe5, 0x8f, 0x45, 0x28, 0x77, 0x7b, 0x8f, 0x0e, 0xe3,
	0x21, 0x53, 0x10, 0xc7, 0x69, 0xe4, 0x2a, 0x86, 0x0b, 0x73, 0x0d, 0xae, 0xc4, 0x69, 0xd4, 0x55,
	0x32, 0x7a, 0x17, 0xd6, 0xa6, 0x46, 0xd7, 0x0b, 0x43, 0xf6, 0x84, 0x0c, 0x2c, 0x79, 0x5e, 0xcb,
	0x9c, 0x76, 0x8d, 0x1a, 0xb5, 0xa0, 0x16, 0x8d, 0x2e, 0xdc, 0x84, 0x70, 0xd7, 0x4f, 0x52, 0xcb,
	0xa4, 0x6a, 0x34, 0xba, 0xe8, 0x11, 0xde, 0x4d, 0xd2, 0x8c, 0x66, 0x34, 0x1e, 0x32, 0x4d, 0xa5,
	0xaa, 0xa6, 0x99, 0xce, 0xe1, 0x4d, 0x58, 0x56, 0xa6, 0x80, 0x9d, 0x13, 0x1e, 0x33, 0xae, 0xb9,
	0x54, 0xc5, 0x35, 0x3f, 0x49, 0xef, 0x59, 0x15, 0xda, 0x05, 0xf0, 0x3d, 0x7f, 0x44, 0x5c, 0x41,
	0x2f, 0x88, 0x25, 0x54, 0x3b, 0x0f, 0x95, 0x7d, 0x4f, 0xa7, 0xab, 0xbc, 0x1e, 0xd2, 0x0b, 0x62,
	0x20, 0xab, 0xfa, 0x99, 0xbc, 0xf9, 0x19, 0xac, 0xce, 0x1b, 0xaf, 0xa0, 0x54, 0x23, 0x4f, 0xa9,
	0x42, 0x9e, 0x3a, 0x5f, 0x02, 0x1c, 0x91, 0x88, 0xf1, 0xb1, 0xce, 0xb8, 0x01, 0x45, 0xc9, 0xa4,
	0x17, 0xda, 0x8a, 0x19, 0x01, 0xdd, 0x84, 0xaa, 0x77, 0xee, 0xd1, 0xd0, 0xeb, 0x87, 0x59, 0x84,
	0x99, 0xa2, 0xfd, 0x35, 0x94, 0xef, 0xd9, 0xa2, 0x37, 0xa0, 0xa8, 0xf8, 0x11, 0xda, 0xab, 0x8d,
	0xa0, 0x28, 0x91, 0xa6, 0xd4, 0x14, 0xb8, 0x8a, 0xf5, 0x19, 0x6d, 0x40, 0xa9, 0x9f, 0x0a, 0x97,
	0x0e, 0x2c, 0x98, 0xc5, 0x7e, 0x2a, 0x0e, 0x07, 0xed, 0x5f, 0x1d, 0x58, 0xee, 0x85, 0x9e, 0x1c,
	0x32, 0x1e, 0xe9, 0x88, 0x08, 0x96, 0xfa, 0x54, 0x8a, 0x8c, 0x7d, 0xea, 0x8c, 0x9a, 0x50, 0x0e,
	0x69, 0x7c, 0xe6, 0x05, 0x76, 0x7a, 0xe0, 0x4c, 0x54, 0x96, 0xc8, 0xf3, 0x47, 0x34, 0x26, 0x36,
	0x6c, 0x26, 0x2a, 0x0b, 0x27, 0x21, 0xf1, 0x04, 0xc9, 0x40, 0xb2, 0x22, 0xba, 0x06, 0x25, 0x31,
	0x16, 0x92, 0x44, 0x16, 0x1e, 0x2b, 0xa9, 0x2f, 0xce, 0x09, 0x17, 0x94, 0xc5, 0xcd, 0x92, 0xf9,
	0xc2, 0x8a, 0xed, 0xa7, 0x0e, 0xac, 0xef, 0x66, 0xcf, 0xdf, 0x27, 0xe7, 0xd4, 0x27, 0x59, 0xae,
	0x97, 0x46, 0x13, 0x82, 0x25, 0x39, 0x4e, 0xb2, 0x44, 0xf5, 0x59, 0xd1, 0x22, 0xd2, 0x25, 0x77,
	0x43, 0x1a, 0x51, 0x43, 0xe7, 0x02, 0xae, 0x19, 0xdd, 0x03, 0xa5, 0x42, 0xb7, 0xa1, 0x91, 0x8c,
	0xc6, 0x82, 0xfa, 0x5e, 0xe8, 0x0e, 0x88, 0xf0, 0x39, 0x4d, 0x54, 0x33, 0xda, 0xdc, 0xd7, 0x33,
	0xdb, 0xfe, 0xcc, 0xd4, 0x7e, 0x5a, 0x80, 0xc6, 0x91, 0x79, 0xed, 0x7c, 0x03, 0x6f, 0x42, 0x65,
	0xc4, 0x84, 0xcc, 0xa5, 0x36, 0x95, 0xd1, 0xe7, 0xb0, 0x92, 0xd8, 0x72, 0x1b, 0x06, 0x9b, 0x91,
	0xd3, 0xcc, 0x33, 0x30, 0x8f, 0x07, 0x5e, 0x4e, 0xf2, 0xe8, 0x74, 0x72, 0xdc, 0x2f, 0xe8, 0x2f,
	0xd7, 0xaf, 0xe0, 0xee, 0xac, 0x21, 0x3e, 0x84, 0xda, 0x40, 0xd7, 0x2b, 0x6b, 0x17, 0x45, 0xf7,
	0x46, 0xc7, 0x2c, 0x98, 0x4e, 0xb6, 0x60, 0x3a, 0xbb, 0xf1, 0x18, 0xc3, 0x60, 0x56, 0xd8, 0x87,
	0xb0, 0x31, 0xa5, 0x9b, 0x9b, 0x0f, 0x50, 0xd4, 0x01, 0xde, 0xc8, 0xdf, 0x79, 0x05, 0x30, 0x78,
	0xdd, 0xbb, 0x02, 0xad, 0x8f, 0xc1, 0x56, 0xdc, 0x84, 0x2a, 0x5d, 0x9e, 0xb5, 0xb3, 0xbe, 0xc0,
	0x10, 0xcd, 0x7a, 0xe4, 0x3d, 0x58, 0x13, 0x84, 0x53, 0x2f, 0x74, 0xe9, 0x80, 0xc4, 0x92, 0x0e,
	0x29, 0xe1, 0xcd, 0xb2, 0x2e, 0x6c, 0xdd, 0x18, 0x0e, 0xa7, 0xfa, 0x76, 0x07, 0xea, 0x38, 0x8d,
	0x2f, 0x01, 0xe2, 0xf1, 0x20, 0x8d, 0x48, 0x2c, 0xf5, 0x70, 0xae, 0xe2, 0xa9, 0xdc, 0xfe, 0xa5,
	0x08, 0xb5, 0x53, 0x22, 0x24, 0x26, 0x22, 0x0d, 0xa5, 0x50, 0xec, 0x94, 0x1e, 0x0f, 0x88, 0xb4,
	0xd0, 0x59, 0x09, 0x7d, 0x04, 0x65, 0x62, 0x06, 0xbd, 0x85, 0xec, 0xe6, 0x2b, 0xe7, 0x3b, 0x25,
	0x02, 0x67, 0xce, 0xe8, 0x04, 0xd6, 0xfb, 0x6a, 0xc6, 0xbb, 0x7e, 0x3e, 0x25, 0x0b, 0x5e, 0x6b,
	0x2e, 0xc6, 0xa5, 0x55, 0x80, 0x51, 0xff, 0xf2, 0x7a, 0xb8, 0x0d, 0x55, 0x5f, 0xcf, 0x76, 0xd5,
	0xcb, 0x4b, 0x3a, 0x4c, 0x63, 0x8e, 0x03, 0x76, 0xf0, 0xe3, 0x8a, 0x9f, 0xad, 0x80, 0xd7, 0x01,
	0x84, 0xf4, 0xb8, 0x34, 0xeb, 0xb7, 0x68, 0xe6, 0x89, 0xd6, 0xe8, 0xfd, 0x7b, 0x1d, 0x2a, 0x3c,
	0x8d, 0x8d, 0xb1, 0x64, 0xf6, 0x36, 0x4f, 0x63, 0x6d, 0x7a, 0x04, 0x1b, 0xb6, 0xa1, 0x5f, 0xca,
	0xbf, 0xac, 0x2f, 0xde, 0x9a, 0x43, 0xef, 0x8a, 0x5e, 0xc0, 0x8d, 0xe8, 0xaa, 0x0e, 0x39, 0x84,
	0x35, 0x75, 0xe3, 0x7c, 0xc8, 0xca, 0xe5, 0xb2, 0xbe, 0x8c, 0x24, 0xae, 0xf3, 0x97, 0xb1, 0xcd,
	0x66, 0x40, 0x35, 0x37, 0x03, 0x1e, 0xc0, 0x6a, 0x3f, 0x03, 0xc4, 0xd5, 0xd3, 0x00, 0xb6, 0x9c,
	0xed, 0xd5, 0x3b, 0x6f, 0xe7, 0x63, 0xe7, 0x40, 0x9f, 0xc1, 0x77, 0x3a, 0x4e, 0x08, 0x5e, 0xe9,
	0xe7, 0xc5, 0xac, 0x3c, 0x7a, 0x27, 0xd7, 0xec, 0x28, 0x4b, 0xe3, 0x23, 0x36, 0x20, 0x6d, 0x0f,
	0x56, 0xe6, 0x3e, 0x45, 0x35, 0x28, 0x3f, 0x3a, 0xbe, 0x7f, 0x7c, 0xf2, 0xf8, 0xb8, 0xbe, 0x80,
	0xae, 0x01, 0xea, 0xf6, 0x7a, 0xee, 0xd1, 0x61, 0x17, 0x9f, 0xec, 0xdd, 0x3d, 0xee, 0x1e, 0x1c,
	0xed, 0xe2, 0xfb, 0x75, 0x07, 0x35, 0xa0, 0xde, 0xfb, 0xee, 0xf4, 0xe0, 0xe4, 0xd8, 0x9d, 0x69,
	0x17, 0xd1, 0x06, 0xac, 0xed, 0x1e, 0xef, 0xe3, 0x93, 0xc3, 0xfd, 0x9c, 0xba, 0xb0, 0xf7, 0xfd,
	0xb3, 0xe7, 0xad, 0x85, 0xbf, 0x9e, 0xb7, 0x16, 0x5e, 0x3c, 0x6f, 0x39, 0x3f, 0x4d, 0x5a, 0xce,
	0xef, 0x93, 0x96, 0xf3, 0xe7, 0xa4, 0xe5, 0x3c, 0x9b, 0xb4, 0x9c, 0xbf, 0x27, 0x2d, 0xe7, 0xdf,
	0x49, 0x6b, 0xe1, 0xc5, 0xa4, 0xe5, 0xfc, 0xfc, 0x4f, 0x6b, 0x01, 0x6e, 0x30, 0x1e, 0xe4, 0x1f,
	0xa9, 0x7e, 0x35, 0x3b, 0xea, 0x57, 0x33, 0x64, 0xc1, 0xde, 0x8a, 0x7a, 0xf2, 0x03, 0x16, 0xf4,
	0x54, 0xdb, 0x8b, 0x9e, 0xf3, 0x9f, 0xe3, 0xf4, 0x4b, 0x7a, 0x06, 0x7c, 0xf0, 0x7f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x6e, 0x25, 0xa6, 0x11, 0xae, 0x0a, 0x00, 0x00,
}
