// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/core/protobuf/worker.proto

/*
	Package tensorflow is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/core/protobuf/worker.proto

	It has these top-level messages:
		GetStatusRequest
		GetStatusResponse
		CreateWorkerSessionRequest
		CreateWorkerSessionResponse
		RegisterGraphRequest
		RegisterGraphResponse
		DeregisterGraphRequest
		DeregisterGraphResponse
		CleanupAllRequest
		CleanupAllResponse
		ExecutorOpts
		RunGraphRequest
		RunGraphResponse
		CleanupGraphRequest
		CleanupGraphResponse
		RecvTensorRequest
		RecvTensorResponse
		LoggingRequest
		LabeledStepStats
		LoggingResponse
		TraceOpts
		TracingRequest
		TracingResponse
*/
package tensorflow

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"
import tensorflow3 "github.com/d4l3k/pok/protobuf/tensorflow/core/framework"
import tensorflow6 "github.com/d4l3k/pok/protobuf/tensorflow/core/framework"
import tensorflow7 "github.com/d4l3k/pok/protobuf/tensorflow/core/framework"
import tensorflow15 "github.com/d4l3k/pok/protobuf/tensorflow/core/framework"
import tensorflow9 "github.com/d4l3k/pok/protobuf/tensorflow/core/framework"
import tensorflow19 "github.com/d4l3k/pok/protobuf/tensorflow/core/protobuf"
import tensorflow16 "github.com/d4l3k/pok/protobuf/tensorflow/core/protobuf"
import tensorflow20 "github.com/d4l3k/pok/protobuf/tensorflow/core/protobuf"
import tensorflow21 "github.com/d4l3k/pok/protobuf/tensorflow/core/protobuf"

import fmt "fmt"
import strings "strings"
import reflect "reflect"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GetStatusRequest struct {
}

func (m *GetStatusRequest) Reset()                    { *m = GetStatusRequest{} }
func (*GetStatusRequest) ProtoMessage()               {}
func (*GetStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{0} }

type GetStatusResponse struct {
	DeviceAttributes []*tensorflow7.DeviceAttributes `protobuf:"bytes,1,rep,name=device_attributes,json=deviceAttributes" json:"device_attributes,omitempty"`
}

func (m *GetStatusResponse) Reset()                    { *m = GetStatusResponse{} }
func (*GetStatusResponse) ProtoMessage()               {}
func (*GetStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{1} }

func (m *GetStatusResponse) GetDeviceAttributes() []*tensorflow7.DeviceAttributes {
	if m != nil {
		return m.DeviceAttributes
	}
	return nil
}

type CreateWorkerSessionRequest struct {
	// Sessions are identified by a given handle.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Defines the configuration of a TensorFlow worker.
	ServerDef *tensorflow21.ServerDef `protobuf:"bytes,2,opt,name=server_def,json=serverDef" json:"server_def,omitempty"`
}

func (m *CreateWorkerSessionRequest) Reset()                    { *m = CreateWorkerSessionRequest{} }
func (*CreateWorkerSessionRequest) ProtoMessage()               {}
func (*CreateWorkerSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{2} }

func (m *CreateWorkerSessionRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *CreateWorkerSessionRequest) GetServerDef() *tensorflow21.ServerDef {
	if m != nil {
		return m.ServerDef
	}
	return nil
}

type CreateWorkerSessionResponse struct {
}

func (m *CreateWorkerSessionResponse) Reset()      { *m = CreateWorkerSessionResponse{} }
func (*CreateWorkerSessionResponse) ProtoMessage() {}
func (*CreateWorkerSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorWorker, []int{3}
}

type RegisterGraphRequest struct {
	// Subgraphs are scoped within one session.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// "graph_def" has the subgraph of nodes for this worker, with each node
	// having its device_name filled in.
	GraphDef *tensorflow15.GraphDef `protobuf:"bytes,2,opt,name=graph_def,json=graphDef" json:"graph_def,omitempty"`
	// True iff the graph (before partitioning) contains control flow nodes.
	//
	// As of 01/11/2015, this is no longer set by clients.
	HasControlFlow bool `protobuf:"varint,3,opt,name=has_control_flow,json=hasControlFlow,proto3" json:"has_control_flow,omitempty"`
	// Configuration options for the session in which this graph was created.
	GraphOptions *tensorflow19.GraphOptions `protobuf:"bytes,4,opt,name=graph_options,json=graphOptions" json:"graph_options,omitempty"`
	// Field(s) used by TensorFlow Debugger (tfdbg).
	DebugOptions *tensorflow16.DebugOptions `protobuf:"bytes,5,opt,name=debug_options,json=debugOptions" json:"debug_options,omitempty"`
}

func (m *RegisterGraphRequest) Reset()                    { *m = RegisterGraphRequest{} }
func (*RegisterGraphRequest) ProtoMessage()               {}
func (*RegisterGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{4} }

func (m *RegisterGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *RegisterGraphRequest) GetGraphDef() *tensorflow15.GraphDef {
	if m != nil {
		return m.GraphDef
	}
	return nil
}

func (m *RegisterGraphRequest) GetHasControlFlow() bool {
	if m != nil {
		return m.HasControlFlow
	}
	return false
}

func (m *RegisterGraphRequest) GetGraphOptions() *tensorflow19.GraphOptions {
	if m != nil {
		return m.GraphOptions
	}
	return nil
}

func (m *RegisterGraphRequest) GetDebugOptions() *tensorflow16.DebugOptions {
	if m != nil {
		return m.DebugOptions
	}
	return nil
}

type RegisterGraphResponse struct {
	// If the registration succeeds, returns an opaque graph_handle to
	// the master. The master calls RunGraph with graph_handle to
	// compute different steps.
	GraphHandle string `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
}

func (m *RegisterGraphResponse) Reset()                    { *m = RegisterGraphResponse{} }
func (*RegisterGraphResponse) ProtoMessage()               {}
func (*RegisterGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{5} }

func (m *RegisterGraphResponse) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

type DeregisterGraphRequest struct {
	// The session_handle used when registering the graph. If session_handle is
	// empty, a single global namespace is used.
	SessionHandle string `protobuf:"bytes,2,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// REQUIRED: graph_handle must be returned by a RegisterGraph call
	// to the same WorkerService.
	GraphHandle string `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
}

func (m *DeregisterGraphRequest) Reset()                    { *m = DeregisterGraphRequest{} }
func (*DeregisterGraphRequest) ProtoMessage()               {}
func (*DeregisterGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{6} }

func (m *DeregisterGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *DeregisterGraphRequest) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

type DeregisterGraphResponse struct {
}

func (m *DeregisterGraphResponse) Reset()                    { *m = DeregisterGraphResponse{} }
func (*DeregisterGraphResponse) ProtoMessage()               {}
func (*DeregisterGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{7} }

type CleanupAllRequest struct {
	// A list of container names.
	//
	// If 'container' is not empty, releases resources in the given
	// containers in all devices.
	//
	// If 'container' is empty, releases resources in the default
	// container in all devices.
	Container []string `protobuf:"bytes,1,rep,name=container" json:"container,omitempty"`
}

func (m *CleanupAllRequest) Reset()                    { *m = CleanupAllRequest{} }
func (*CleanupAllRequest) ProtoMessage()               {}
func (*CleanupAllRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{8} }

func (m *CleanupAllRequest) GetContainer() []string {
	if m != nil {
		return m.Container
	}
	return nil
}

type CleanupAllResponse struct {
}

func (m *CleanupAllResponse) Reset()                    { *m = CleanupAllResponse{} }
func (*CleanupAllResponse) ProtoMessage()               {}
func (*CleanupAllResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{9} }

// Options specific to the execution of a single step.
type ExecutorOpts struct {
	RecordCosts           bool `protobuf:"varint,1,opt,name=record_costs,json=recordCosts,proto3" json:"record_costs,omitempty"`
	RecordTimeline        bool `protobuf:"varint,3,opt,name=record_timeline,json=recordTimeline,proto3" json:"record_timeline,omitempty"`
	RecordPartitionGraphs bool `protobuf:"varint,4,opt,name=record_partition_graphs,json=recordPartitionGraphs,proto3" json:"record_partition_graphs,omitempty"`
}

func (m *ExecutorOpts) Reset()                    { *m = ExecutorOpts{} }
func (*ExecutorOpts) ProtoMessage()               {}
func (*ExecutorOpts) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{10} }

func (m *ExecutorOpts) GetRecordCosts() bool {
	if m != nil {
		return m.RecordCosts
	}
	return false
}

func (m *ExecutorOpts) GetRecordTimeline() bool {
	if m != nil {
		return m.RecordTimeline
	}
	return false
}

func (m *ExecutorOpts) GetRecordPartitionGraphs() bool {
	if m != nil {
		return m.RecordPartitionGraphs
	}
	return false
}

type RunGraphRequest struct {
	// session_handle is the master-generated unique id for this session.
	// If session_handle is non-empty, it must be the same as used when
	// registering the graph. If it is empty, a single global namespace is used to
	// search for the graph_handle.
	SessionHandle string `protobuf:"bytes,8,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// REQUIRED: graph_handle must be returned by a RegisterGraph call
	// to the same WorkerService.
	GraphHandle string `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
	// A unique ID to distinguish different runs of the same graph.
	//
	// The master generates a global unique `step_id` to distinguish
	// different runs of the graph computation. Subgraphs communicate
	// (e.g., send/recv ops) with each other using `step_id` to
	// distinguish tensors generated by different runs.
	StepId int64 `protobuf:"varint,2,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	// Options for this step.
	ExecOpts *ExecutorOpts `protobuf:"bytes,5,opt,name=exec_opts,json=execOpts" json:"exec_opts,omitempty"`
	// Runs the graph.
	//
	// Sends the tensors in "send" into the graph before the run and
	// fetches the keys into `RunGraphResponse.recv` after the run.
	Send    []*tensorflow20.NamedTensorProto `protobuf:"bytes,3,rep,name=send" json:"send,omitempty"`
	RecvKey []string                         `protobuf:"bytes,4,rep,name=recv_key,json=recvKey" json:"recv_key,omitempty"`
	// True if the RunGraphRequest is a partial run request.
	IsPartial bool `protobuf:"varint,6,opt,name=is_partial,json=isPartial,proto3" json:"is_partial,omitempty"`
	// True if this is the last partial run request in a sequence of requests.
	IsLastPartialRun bool `protobuf:"varint,7,opt,name=is_last_partial_run,json=isLastPartialRun,proto3" json:"is_last_partial_run,omitempty"`
}

func (m *RunGraphRequest) Reset()                    { *m = RunGraphRequest{} }
func (*RunGraphRequest) ProtoMessage()               {}
func (*RunGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{11} }

func (m *RunGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *RunGraphRequest) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

func (m *RunGraphRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *RunGraphRequest) GetExecOpts() *ExecutorOpts {
	if m != nil {
		return m.ExecOpts
	}
	return nil
}

func (m *RunGraphRequest) GetSend() []*tensorflow20.NamedTensorProto {
	if m != nil {
		return m.Send
	}
	return nil
}

func (m *RunGraphRequest) GetRecvKey() []string {
	if m != nil {
		return m.RecvKey
	}
	return nil
}

func (m *RunGraphRequest) GetIsPartial() bool {
	if m != nil {
		return m.IsPartial
	}
	return false
}

func (m *RunGraphRequest) GetIsLastPartialRun() bool {
	if m != nil {
		return m.IsLastPartialRun
	}
	return false
}

type RunGraphResponse struct {
	// A list of tensors corresponding to those requested by
	// `RunGraphRequest.recv_key`.
	Recv []*tensorflow20.NamedTensorProto `protobuf:"bytes,1,rep,name=recv" json:"recv,omitempty"`
	// If the request asked for execution stats, the cost graph, or the partition
	// graphs, these are returned here.
	// TODO(suharshs): Package these in a RunMetadata instead.
	StepStats      *tensorflow6.StepStats    `protobuf:"bytes,2,opt,name=step_stats,json=stepStats" json:"step_stats,omitempty"`
	CostGraph      *tensorflow3.CostGraphDef `protobuf:"bytes,3,opt,name=cost_graph,json=costGraph" json:"cost_graph,omitempty"`
	PartitionGraph []*tensorflow15.GraphDef  `protobuf:"bytes,4,rep,name=partition_graph,json=partitionGraph" json:"partition_graph,omitempty"`
}

func (m *RunGraphResponse) Reset()                    { *m = RunGraphResponse{} }
func (*RunGraphResponse) ProtoMessage()               {}
func (*RunGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{12} }

func (m *RunGraphResponse) GetRecv() []*tensorflow20.NamedTensorProto {
	if m != nil {
		return m.Recv
	}
	return nil
}

func (m *RunGraphResponse) GetStepStats() *tensorflow6.StepStats {
	if m != nil {
		return m.StepStats
	}
	return nil
}

func (m *RunGraphResponse) GetCostGraph() *tensorflow3.CostGraphDef {
	if m != nil {
		return m.CostGraph
	}
	return nil
}

func (m *RunGraphResponse) GetPartitionGraph() []*tensorflow15.GraphDef {
	if m != nil {
		return m.PartitionGraph
	}
	return nil
}

type CleanupGraphRequest struct {
	StepId int64 `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
}

func (m *CleanupGraphRequest) Reset()                    { *m = CleanupGraphRequest{} }
func (*CleanupGraphRequest) ProtoMessage()               {}
func (*CleanupGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{13} }

func (m *CleanupGraphRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

type CleanupGraphResponse struct {
}

func (m *CleanupGraphResponse) Reset()                    { *m = CleanupGraphResponse{} }
func (*CleanupGraphResponse) ProtoMessage()               {}
func (*CleanupGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{14} }

type RecvTensorRequest struct {
	// The step in which the tensor will be produced.
	//
	// REQUIRED: This must eventually correspond to the `step_id` passed
	// into a RunGraph call on the same WorkerService.
	StepId int64 `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	// A key that identifies the tensor to be received.
	RendezvousKey string `protobuf:"bytes,2,opt,name=rendezvous_key,json=rendezvousKey,proto3" json:"rendezvous_key,omitempty"`
	// If true, use an out-of-band DMA mechanism to transfer the
	// received tensor.
	DmaOk bool `protobuf:"varint,3,opt,name=dma_ok,json=dmaOk,proto3" json:"dma_ok,omitempty"`
	// Optional information on client-side device locality.
	ClientLocality *tensorflow7.DeviceLocality `protobuf:"bytes,4,opt,name=client_locality,json=clientLocality" json:"client_locality,omitempty"`
	// Optional information on server-side device locality.
	ServerLocality *tensorflow7.DeviceLocality `protobuf:"bytes,5,opt,name=server_locality,json=serverLocality" json:"server_locality,omitempty"`
	// Optional information needed by the RPC subsystem.
	TransportOptions *google_protobuf.Any `protobuf:"bytes,6,opt,name=transport_options,json=transportOptions" json:"transport_options,omitempty"`
}

func (m *RecvTensorRequest) Reset()                    { *m = RecvTensorRequest{} }
func (*RecvTensorRequest) ProtoMessage()               {}
func (*RecvTensorRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{15} }

func (m *RecvTensorRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *RecvTensorRequest) GetRendezvousKey() string {
	if m != nil {
		return m.RendezvousKey
	}
	return ""
}

func (m *RecvTensorRequest) GetDmaOk() bool {
	if m != nil {
		return m.DmaOk
	}
	return false
}

func (m *RecvTensorRequest) GetClientLocality() *tensorflow7.DeviceLocality {
	if m != nil {
		return m.ClientLocality
	}
	return nil
}

func (m *RecvTensorRequest) GetServerLocality() *tensorflow7.DeviceLocality {
	if m != nil {
		return m.ServerLocality
	}
	return nil
}

func (m *RecvTensorRequest) GetTransportOptions() *google_protobuf.Any {
	if m != nil {
		return m.TransportOptions
	}
	return nil
}

type RecvTensorResponse struct {
	// The tensor as a proto.
	Tensor *tensorflow9.TensorProto `protobuf:"bytes,1,opt,name=tensor" json:"tensor,omitempty"`
	// If true, this tensor was the output of a dead node, and the
	// content is invalid.
	IsDead bool `protobuf:"varint,2,opt,name=is_dead,json=isDead,proto3" json:"is_dead,omitempty"`
	// The time at which tensor was available and started to be returned.
	SendStartMicros int64 `protobuf:"varint,3,opt,name=send_start_micros,json=sendStartMicros,proto3" json:"send_start_micros,omitempty"`
	// Optional additional information about how to receive the tensor,
	// e.g. in the event that `RecvTensorRequest.dma_ok` was true.
	TransportOptions *google_protobuf.Any `protobuf:"bytes,4,opt,name=transport_options,json=transportOptions" json:"transport_options,omitempty"`
}

func (m *RecvTensorResponse) Reset()                    { *m = RecvTensorResponse{} }
func (*RecvTensorResponse) ProtoMessage()               {}
func (*RecvTensorResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{16} }

func (m *RecvTensorResponse) GetTensor() *tensorflow9.TensorProto {
	if m != nil {
		return m.Tensor
	}
	return nil
}

func (m *RecvTensorResponse) GetIsDead() bool {
	if m != nil {
		return m.IsDead
	}
	return false
}

func (m *RecvTensorResponse) GetSendStartMicros() int64 {
	if m != nil {
		return m.SendStartMicros
	}
	return 0
}

func (m *RecvTensorResponse) GetTransportOptions() *google_protobuf.Any {
	if m != nil {
		return m.TransportOptions
	}
	return nil
}

// Out-of-band request to begin or end logging, or
// to retrieve logs for particular steps.
type LoggingRequest struct {
	// If true, RPC logging will be activated.
	RpcLogging bool `protobuf:"varint,1,opt,name=rpc_logging,json=rpcLogging,proto3" json:"rpc_logging,omitempty"`
	// If true, discard any saved logging data (for all steps).
	Clear bool `protobuf:"varint,2,opt,name=clear,proto3" json:"clear,omitempty"`
	// When set, requests all saved log data pertaining to the step.
	// Any log data retrieved is eliminated from the store and cannot be
	// retrieved again.
	FetchStepId []int64 `protobuf:"varint,3,rep,packed,name=fetch_step_id,json=fetchStepId" json:"fetch_step_id,omitempty"`
}

func (m *LoggingRequest) Reset()                    { *m = LoggingRequest{} }
func (*LoggingRequest) ProtoMessage()               {}
func (*LoggingRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{17} }

func (m *LoggingRequest) GetRpcLogging() bool {
	if m != nil {
		return m.RpcLogging
	}
	return false
}

func (m *LoggingRequest) GetClear() bool {
	if m != nil {
		return m.Clear
	}
	return false
}

func (m *LoggingRequest) GetFetchStepId() []int64 {
	if m != nil {
		return m.FetchStepId
	}
	return nil
}

type LabeledStepStats struct {
	StepId    int64                  `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	StepStats *tensorflow6.StepStats `protobuf:"bytes,2,opt,name=step_stats,json=stepStats" json:"step_stats,omitempty"`
}

func (m *LabeledStepStats) Reset()                    { *m = LabeledStepStats{} }
func (*LabeledStepStats) ProtoMessage()               {}
func (*LabeledStepStats) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{18} }

func (m *LabeledStepStats) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *LabeledStepStats) GetStepStats() *tensorflow6.StepStats {
	if m != nil {
		return m.StepStats
	}
	return nil
}

type LoggingResponse struct {
	Step []*LabeledStepStats `protobuf:"bytes,1,rep,name=step" json:"step,omitempty"`
}

func (m *LoggingResponse) Reset()                    { *m = LoggingResponse{} }
func (*LoggingResponse) ProtoMessage()               {}
func (*LoggingResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{19} }

func (m *LoggingResponse) GetStep() []*LabeledStepStats {
	if m != nil {
		return m.Step
	}
	return nil
}

type TraceOpts struct {
	// Length of the trace to be taken, in seconds.
	Duration float64 `protobuf:"fixed64,1,opt,name=duration,proto3" json:"duration,omitempty"`
	// If true, capture step profile locally in each worker. Currently
	// unimplemented.
	UseStepProfiler bool `protobuf:"varint,2,opt,name=use_step_profiler,json=useStepProfiler,proto3" json:"use_step_profiler,omitempty"`
	// If true, capture kernel events from each worker.
	UseKernelProfiler bool `protobuf:"varint,3,opt,name=use_kernel_profiler,json=useKernelProfiler,proto3" json:"use_kernel_profiler,omitempty"`
	// If true, capture extended profiling events from TensorFlow process.
	UseExtendedProfiler bool `protobuf:"varint,4,opt,name=use_extended_profiler,json=useExtendedProfiler,proto3" json:"use_extended_profiler,omitempty"`
	// If true, capture GPU profiling events locally on each
	// machine. Currently unimplemented.
	UseGpuProfiler bool `protobuf:"varint,5,opt,name=use_gpu_profiler,json=useGpuProfiler,proto3" json:"use_gpu_profiler,omitempty"`
	// If true, collect sampled profile events. Currently unimplemented.
	UseSampleProfiler bool `protobuf:"varint,6,opt,name=use_sample_profiler,json=useSampleProfiler,proto3" json:"use_sample_profiler,omitempty"`
}

func (m *TraceOpts) Reset()                    { *m = TraceOpts{} }
func (*TraceOpts) ProtoMessage()               {}
func (*TraceOpts) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{20} }

func (m *TraceOpts) GetDuration() float64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *TraceOpts) GetUseStepProfiler() bool {
	if m != nil {
		return m.UseStepProfiler
	}
	return false
}

func (m *TraceOpts) GetUseKernelProfiler() bool {
	if m != nil {
		return m.UseKernelProfiler
	}
	return false
}

func (m *TraceOpts) GetUseExtendedProfiler() bool {
	if m != nil {
		return m.UseExtendedProfiler
	}
	return false
}

func (m *TraceOpts) GetUseGpuProfiler() bool {
	if m != nil {
		return m.UseGpuProfiler
	}
	return false
}

func (m *TraceOpts) GetUseSampleProfiler() bool {
	if m != nil {
		return m.UseSampleProfiler
	}
	return false
}

// Out-of-band request to configure distributed tracing.
type TracingRequest struct {
	Options *TraceOpts `protobuf:"bytes,1,opt,name=options" json:"options,omitempty"`
}

func (m *TracingRequest) Reset()                    { *m = TracingRequest{} }
func (*TracingRequest) ProtoMessage()               {}
func (*TracingRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{21} }

func (m *TracingRequest) GetOptions() *TraceOpts {
	if m != nil {
		return m.Options
	}
	return nil
}

type TracingResponse struct {
}

func (m *TracingResponse) Reset()                    { *m = TracingResponse{} }
func (*TracingResponse) ProtoMessage()               {}
func (*TracingResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{22} }

func init() {
	proto.RegisterType((*GetStatusRequest)(nil), "tensorflow.GetStatusRequest")
	proto.RegisterType((*GetStatusResponse)(nil), "tensorflow.GetStatusResponse")
	proto.RegisterType((*CreateWorkerSessionRequest)(nil), "tensorflow.CreateWorkerSessionRequest")
	proto.RegisterType((*CreateWorkerSessionResponse)(nil), "tensorflow.CreateWorkerSessionResponse")
	proto.RegisterType((*RegisterGraphRequest)(nil), "tensorflow.RegisterGraphRequest")
	proto.RegisterType((*RegisterGraphResponse)(nil), "tensorflow.RegisterGraphResponse")
	proto.RegisterType((*DeregisterGraphRequest)(nil), "tensorflow.DeregisterGraphRequest")
	proto.RegisterType((*DeregisterGraphResponse)(nil), "tensorflow.DeregisterGraphResponse")
	proto.RegisterType((*CleanupAllRequest)(nil), "tensorflow.CleanupAllRequest")
	proto.RegisterType((*CleanupAllResponse)(nil), "tensorflow.CleanupAllResponse")
	proto.RegisterType((*ExecutorOpts)(nil), "tensorflow.ExecutorOpts")
	proto.RegisterType((*RunGraphRequest)(nil), "tensorflow.RunGraphRequest")
	proto.RegisterType((*RunGraphResponse)(nil), "tensorflow.RunGraphResponse")
	proto.RegisterType((*CleanupGraphRequest)(nil), "tensorflow.CleanupGraphRequest")
	proto.RegisterType((*CleanupGraphResponse)(nil), "tensorflow.CleanupGraphResponse")
	proto.RegisterType((*RecvTensorRequest)(nil), "tensorflow.RecvTensorRequest")
	proto.RegisterType((*RecvTensorResponse)(nil), "tensorflow.RecvTensorResponse")
	proto.RegisterType((*LoggingRequest)(nil), "tensorflow.LoggingRequest")
	proto.RegisterType((*LabeledStepStats)(nil), "tensorflow.LabeledStepStats")
	proto.RegisterType((*LoggingResponse)(nil), "tensorflow.LoggingResponse")
	proto.RegisterType((*TraceOpts)(nil), "tensorflow.TraceOpts")
	proto.RegisterType((*TracingRequest)(nil), "tensorflow.TracingRequest")
	proto.RegisterType((*TracingResponse)(nil), "tensorflow.TracingResponse")
}
func (this *GetStatusRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetStatusRequest)
	if !ok {
		that2, ok := that.(GetStatusRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetStatusResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetStatusResponse)
	if !ok {
		that2, ok := that.(GetStatusResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.DeviceAttributes) != len(that1.DeviceAttributes) {
		return false
	}
	for i := range this.DeviceAttributes {
		if !this.DeviceAttributes[i].Equal(that1.DeviceAttributes[i]) {
			return false
		}
	}
	return true
}
func (this *CreateWorkerSessionRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateWorkerSessionRequest)
	if !ok {
		that2, ok := that.(CreateWorkerSessionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SessionHandle != that1.SessionHandle {
		return false
	}
	if !this.ServerDef.Equal(that1.ServerDef) {
		return false
	}
	return true
}
func (this *CreateWorkerSessionResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateWorkerSessionResponse)
	if !ok {
		that2, ok := that.(CreateWorkerSessionResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *RegisterGraphRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegisterGraphRequest)
	if !ok {
		that2, ok := that.(RegisterGraphRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SessionHandle != that1.SessionHandle {
		return false
	}
	if !this.GraphDef.Equal(that1.GraphDef) {
		return false
	}
	if this.HasControlFlow != that1.HasControlFlow {
		return false
	}
	if !this.GraphOptions.Equal(that1.GraphOptions) {
		return false
	}
	if !this.DebugOptions.Equal(that1.DebugOptions) {
		return false
	}
	return true
}
func (this *RegisterGraphResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RegisterGraphResponse)
	if !ok {
		that2, ok := that.(RegisterGraphResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.GraphHandle != that1.GraphHandle {
		return false
	}
	return true
}
func (this *DeregisterGraphRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeregisterGraphRequest)
	if !ok {
		that2, ok := that.(DeregisterGraphRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SessionHandle != that1.SessionHandle {
		return false
	}
	if this.GraphHandle != that1.GraphHandle {
		return false
	}
	return true
}
func (this *DeregisterGraphResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeregisterGraphResponse)
	if !ok {
		that2, ok := that.(DeregisterGraphResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *CleanupAllRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CleanupAllRequest)
	if !ok {
		that2, ok := that.(CleanupAllRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Container) != len(that1.Container) {
		return false
	}
	for i := range this.Container {
		if this.Container[i] != that1.Container[i] {
			return false
		}
	}
	return true
}
func (this *CleanupAllResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CleanupAllResponse)
	if !ok {
		that2, ok := that.(CleanupAllResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *ExecutorOpts) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ExecutorOpts)
	if !ok {
		that2, ok := that.(ExecutorOpts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.RecordCosts != that1.RecordCosts {
		return false
	}
	if this.RecordTimeline != that1.RecordTimeline {
		return false
	}
	if this.RecordPartitionGraphs != that1.RecordPartitionGraphs {
		return false
	}
	return true
}
func (this *RunGraphRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RunGraphRequest)
	if !ok {
		that2, ok := that.(RunGraphRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SessionHandle != that1.SessionHandle {
		return false
	}
	if this.GraphHandle != that1.GraphHandle {
		return false
	}
	if this.StepId != that1.StepId {
		return false
	}
	if !this.ExecOpts.Equal(that1.ExecOpts) {
		return false
	}
	if len(this.Send) != len(that1.Send) {
		return false
	}
	for i := range this.Send {
		if !this.Send[i].Equal(that1.Send[i]) {
			return false
		}
	}
	if len(this.RecvKey) != len(that1.RecvKey) {
		return false
	}
	for i := range this.RecvKey {
		if this.RecvKey[i] != that1.RecvKey[i] {
			return false
		}
	}
	if this.IsPartial != that1.IsPartial {
		return false
	}
	if this.IsLastPartialRun != that1.IsLastPartialRun {
		return false
	}
	return true
}
func (this *RunGraphResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RunGraphResponse)
	if !ok {
		that2, ok := that.(RunGraphResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Recv) != len(that1.Recv) {
		return false
	}
	for i := range this.Recv {
		if !this.Recv[i].Equal(that1.Recv[i]) {
			return false
		}
	}
	if !this.StepStats.Equal(that1.StepStats) {
		return false
	}
	if !this.CostGraph.Equal(that1.CostGraph) {
		return false
	}
	if len(this.PartitionGraph) != len(that1.PartitionGraph) {
		return false
	}
	for i := range this.PartitionGraph {
		if !this.PartitionGraph[i].Equal(that1.PartitionGraph[i]) {
			return false
		}
	}
	return true
}
func (this *CleanupGraphRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CleanupGraphRequest)
	if !ok {
		that2, ok := that.(CleanupGraphRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.StepId != that1.StepId {
		return false
	}
	return true
}
func (this *CleanupGraphResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CleanupGraphResponse)
	if !ok {
		that2, ok := that.(CleanupGraphResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *RecvTensorRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RecvTensorRequest)
	if !ok {
		that2, ok := that.(RecvTensorRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.StepId != that1.StepId {
		return false
	}
	if this.RendezvousKey != that1.RendezvousKey {
		return false
	}
	if this.DmaOk != that1.DmaOk {
		return false
	}
	if !this.ClientLocality.Equal(that1.ClientLocality) {
		return false
	}
	if !this.ServerLocality.Equal(that1.ServerLocality) {
		return false
	}
	if !this.TransportOptions.Equal(that1.TransportOptions) {
		return false
	}
	return true
}
func (this *RecvTensorResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RecvTensorResponse)
	if !ok {
		that2, ok := that.(RecvTensorResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Tensor.Equal(that1.Tensor) {
		return false
	}
	if this.IsDead != that1.IsDead {
		return false
	}
	if this.SendStartMicros != that1.SendStartMicros {
		return false
	}
	if !this.TransportOptions.Equal(that1.TransportOptions) {
		return false
	}
	return true
}
func (this *LoggingRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LoggingRequest)
	if !ok {
		that2, ok := that.(LoggingRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.RpcLogging != that1.RpcLogging {
		return false
	}
	if this.Clear != that1.Clear {
		return false
	}
	if len(this.FetchStepId) != len(that1.FetchStepId) {
		return false
	}
	for i := range this.FetchStepId {
		if this.FetchStepId[i] != that1.FetchStepId[i] {
			return false
		}
	}
	return true
}
func (this *LabeledStepStats) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LabeledStepStats)
	if !ok {
		that2, ok := that.(LabeledStepStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.StepId != that1.StepId {
		return false
	}
	if !this.StepStats.Equal(that1.StepStats) {
		return false
	}
	return true
}
func (this *LoggingResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LoggingResponse)
	if !ok {
		that2, ok := that.(LoggingResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Step) != len(that1.Step) {
		return false
	}
	for i := range this.Step {
		if !this.Step[i].Equal(that1.Step[i]) {
			return false
		}
	}
	return true
}
func (this *TraceOpts) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TraceOpts)
	if !ok {
		that2, ok := that.(TraceOpts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.UseStepProfiler != that1.UseStepProfiler {
		return false
	}
	if this.UseKernelProfiler != that1.UseKernelProfiler {
		return false
	}
	if this.UseExtendedProfiler != that1.UseExtendedProfiler {
		return false
	}
	if this.UseGpuProfiler != that1.UseGpuProfiler {
		return false
	}
	if this.UseSampleProfiler != that1.UseSampleProfiler {
		return false
	}
	return true
}
func (this *TracingRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TracingRequest)
	if !ok {
		that2, ok := that.(TracingRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *TracingResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TracingResponse)
	if !ok {
		that2, ok := that.(TracingResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetStatusRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&tensorflow.GetStatusRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetStatusResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.GetStatusResponse{")
	if this.DeviceAttributes != nil {
		s = append(s, "DeviceAttributes: "+fmt.Sprintf("%#v", this.DeviceAttributes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateWorkerSessionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow.CreateWorkerSessionRequest{")
	s = append(s, "SessionHandle: "+fmt.Sprintf("%#v", this.SessionHandle)+",\n")
	if this.ServerDef != nil {
		s = append(s, "ServerDef: "+fmt.Sprintf("%#v", this.ServerDef)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateWorkerSessionResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&tensorflow.CreateWorkerSessionResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegisterGraphRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tensorflow.RegisterGraphRequest{")
	s = append(s, "SessionHandle: "+fmt.Sprintf("%#v", this.SessionHandle)+",\n")
	if this.GraphDef != nil {
		s = append(s, "GraphDef: "+fmt.Sprintf("%#v", this.GraphDef)+",\n")
	}
	s = append(s, "HasControlFlow: "+fmt.Sprintf("%#v", this.HasControlFlow)+",\n")
	if this.GraphOptions != nil {
		s = append(s, "GraphOptions: "+fmt.Sprintf("%#v", this.GraphOptions)+",\n")
	}
	if this.DebugOptions != nil {
		s = append(s, "DebugOptions: "+fmt.Sprintf("%#v", this.DebugOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegisterGraphResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.RegisterGraphResponse{")
	s = append(s, "GraphHandle: "+fmt.Sprintf("%#v", this.GraphHandle)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeregisterGraphRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow.DeregisterGraphRequest{")
	s = append(s, "SessionHandle: "+fmt.Sprintf("%#v", this.SessionHandle)+",\n")
	s = append(s, "GraphHandle: "+fmt.Sprintf("%#v", this.GraphHandle)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeregisterGraphResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&tensorflow.DeregisterGraphResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CleanupAllRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.CleanupAllRequest{")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CleanupAllResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&tensorflow.CleanupAllResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutorOpts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow.ExecutorOpts{")
	s = append(s, "RecordCosts: "+fmt.Sprintf("%#v", this.RecordCosts)+",\n")
	s = append(s, "RecordTimeline: "+fmt.Sprintf("%#v", this.RecordTimeline)+",\n")
	s = append(s, "RecordPartitionGraphs: "+fmt.Sprintf("%#v", this.RecordPartitionGraphs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RunGraphRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tensorflow.RunGraphRequest{")
	s = append(s, "SessionHandle: "+fmt.Sprintf("%#v", this.SessionHandle)+",\n")
	s = append(s, "GraphHandle: "+fmt.Sprintf("%#v", this.GraphHandle)+",\n")
	s = append(s, "StepId: "+fmt.Sprintf("%#v", this.StepId)+",\n")
	if this.ExecOpts != nil {
		s = append(s, "ExecOpts: "+fmt.Sprintf("%#v", this.ExecOpts)+",\n")
	}
	if this.Send != nil {
		s = append(s, "Send: "+fmt.Sprintf("%#v", this.Send)+",\n")
	}
	s = append(s, "RecvKey: "+fmt.Sprintf("%#v", this.RecvKey)+",\n")
	s = append(s, "IsPartial: "+fmt.Sprintf("%#v", this.IsPartial)+",\n")
	s = append(s, "IsLastPartialRun: "+fmt.Sprintf("%#v", this.IsLastPartialRun)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RunGraphResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow.RunGraphResponse{")
	if this.Recv != nil {
		s = append(s, "Recv: "+fmt.Sprintf("%#v", this.Recv)+",\n")
	}
	if this.StepStats != nil {
		s = append(s, "StepStats: "+fmt.Sprintf("%#v", this.StepStats)+",\n")
	}
	if this.CostGraph != nil {
		s = append(s, "CostGraph: "+fmt.Sprintf("%#v", this.CostGraph)+",\n")
	}
	if this.PartitionGraph != nil {
		s = append(s, "PartitionGraph: "+fmt.Sprintf("%#v", this.PartitionGraph)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CleanupGraphRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.CleanupGraphRequest{")
	s = append(s, "StepId: "+fmt.Sprintf("%#v", this.StepId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CleanupGraphResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&tensorflow.CleanupGraphResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecvTensorRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tensorflow.RecvTensorRequest{")
	s = append(s, "StepId: "+fmt.Sprintf("%#v", this.StepId)+",\n")
	s = append(s, "RendezvousKey: "+fmt.Sprintf("%#v", this.RendezvousKey)+",\n")
	s = append(s, "DmaOk: "+fmt.Sprintf("%#v", this.DmaOk)+",\n")
	if this.ClientLocality != nil {
		s = append(s, "ClientLocality: "+fmt.Sprintf("%#v", this.ClientLocality)+",\n")
	}
	if this.ServerLocality != nil {
		s = append(s, "ServerLocality: "+fmt.Sprintf("%#v", this.ServerLocality)+",\n")
	}
	if this.TransportOptions != nil {
		s = append(s, "TransportOptions: "+fmt.Sprintf("%#v", this.TransportOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecvTensorResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow.RecvTensorResponse{")
	if this.Tensor != nil {
		s = append(s, "Tensor: "+fmt.Sprintf("%#v", this.Tensor)+",\n")
	}
	s = append(s, "IsDead: "+fmt.Sprintf("%#v", this.IsDead)+",\n")
	s = append(s, "SendStartMicros: "+fmt.Sprintf("%#v", this.SendStartMicros)+",\n")
	if this.TransportOptions != nil {
		s = append(s, "TransportOptions: "+fmt.Sprintf("%#v", this.TransportOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoggingRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow.LoggingRequest{")
	s = append(s, "RpcLogging: "+fmt.Sprintf("%#v", this.RpcLogging)+",\n")
	s = append(s, "Clear: "+fmt.Sprintf("%#v", this.Clear)+",\n")
	s = append(s, "FetchStepId: "+fmt.Sprintf("%#v", this.FetchStepId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabeledStepStats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow.LabeledStepStats{")
	s = append(s, "StepId: "+fmt.Sprintf("%#v", this.StepId)+",\n")
	if this.StepStats != nil {
		s = append(s, "StepStats: "+fmt.Sprintf("%#v", this.StepStats)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoggingResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.LoggingResponse{")
	if this.Step != nil {
		s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TraceOpts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&tensorflow.TraceOpts{")
	s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	s = append(s, "UseStepProfiler: "+fmt.Sprintf("%#v", this.UseStepProfiler)+",\n")
	s = append(s, "UseKernelProfiler: "+fmt.Sprintf("%#v", this.UseKernelProfiler)+",\n")
	s = append(s, "UseExtendedProfiler: "+fmt.Sprintf("%#v", this.UseExtendedProfiler)+",\n")
	s = append(s, "UseGpuProfiler: "+fmt.Sprintf("%#v", this.UseGpuProfiler)+",\n")
	s = append(s, "UseSampleProfiler: "+fmt.Sprintf("%#v", this.UseSampleProfiler)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TracingRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.TracingRequest{")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TracingResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&tensorflow.TracingResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringWorker(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GetStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DeviceAttributes) > 0 {
		for _, msg := range m.DeviceAttributes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintWorker(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateWorkerSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWorkerSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SessionHandle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i += copy(dAtA[i:], m.SessionHandle)
	}
	if m.ServerDef != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.ServerDef.Size()))
		n1, err := m.ServerDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *CreateWorkerSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWorkerSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RegisterGraphRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterGraphRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SessionHandle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i += copy(dAtA[i:], m.SessionHandle)
	}
	if m.GraphDef != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.GraphDef.Size()))
		n2, err := m.GraphDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.HasControlFlow {
		dAtA[i] = 0x18
		i++
		if m.HasControlFlow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GraphOptions != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.GraphOptions.Size()))
		n3, err := m.GraphOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DebugOptions != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.DebugOptions.Size()))
		n4, err := m.DebugOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *RegisterGraphResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterGraphResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GraphHandle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorker(dAtA, i, uint64(len(m.GraphHandle)))
		i += copy(dAtA[i:], m.GraphHandle)
	}
	return i, nil
}

func (m *DeregisterGraphRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeregisterGraphRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GraphHandle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorker(dAtA, i, uint64(len(m.GraphHandle)))
		i += copy(dAtA[i:], m.GraphHandle)
	}
	if len(m.SessionHandle) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i += copy(dAtA[i:], m.SessionHandle)
	}
	return i, nil
}

func (m *DeregisterGraphResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeregisterGraphResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CleanupAllRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupAllRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Container) > 0 {
		for _, s := range m.Container {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CleanupAllResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupAllResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ExecutorOpts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorOpts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecordCosts {
		dAtA[i] = 0x8
		i++
		if m.RecordCosts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RecordTimeline {
		dAtA[i] = 0x18
		i++
		if m.RecordTimeline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RecordPartitionGraphs {
		dAtA[i] = 0x20
		i++
		if m.RecordPartitionGraphs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RunGraphRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunGraphRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GraphHandle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorker(dAtA, i, uint64(len(m.GraphHandle)))
		i += copy(dAtA[i:], m.GraphHandle)
	}
	if m.StepId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
	}
	if len(m.Send) > 0 {
		for _, msg := range m.Send {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintWorker(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RecvKey) > 0 {
		for _, s := range m.RecvKey {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ExecOpts != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.ExecOpts.Size()))
		n5, err := m.ExecOpts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.IsPartial {
		dAtA[i] = 0x30
		i++
		if m.IsPartial {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLastPartialRun {
		dAtA[i] = 0x38
		i++
		if m.IsLastPartialRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SessionHandle) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWorker(dAtA, i, uint64(len(m.SessionHandle)))
		i += copy(dAtA[i:], m.SessionHandle)
	}
	return i, nil
}

func (m *RunGraphResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunGraphResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Recv) > 0 {
		for _, msg := range m.Recv {
			dAtA[i] = 0xa
			i++
			i = encodeVarintWorker(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StepStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.StepStats.Size()))
		n6, err := m.StepStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CostGraph != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.CostGraph.Size()))
		n7, err := m.CostGraph.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.PartitionGraph) > 0 {
		for _, msg := range m.PartitionGraph {
			dAtA[i] = 0x22
			i++
			i = encodeVarintWorker(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CleanupGraphRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupGraphRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StepId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
	}
	return i, nil
}

func (m *CleanupGraphResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupGraphResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RecvTensorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvTensorRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StepId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
	}
	if len(m.RendezvousKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWorker(dAtA, i, uint64(len(m.RendezvousKey)))
		i += copy(dAtA[i:], m.RendezvousKey)
	}
	if m.DmaOk {
		dAtA[i] = 0x18
		i++
		if m.DmaOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ClientLocality != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.ClientLocality.Size()))
		n8, err := m.ClientLocality.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ServerLocality != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.ServerLocality.Size()))
		n9, err := m.ServerLocality.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.TransportOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.TransportOptions.Size()))
		n10, err := m.TransportOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *RecvTensorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvTensorResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tensor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.Tensor.Size()))
		n11, err := m.Tensor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.IsDead {
		dAtA[i] = 0x10
		i++
		if m.IsDead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendStartMicros != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.SendStartMicros))
	}
	if m.TransportOptions != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.TransportOptions.Size()))
		n12, err := m.TransportOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *LoggingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggingRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RpcLogging {
		dAtA[i] = 0x8
		i++
		if m.RpcLogging {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Clear {
		dAtA[i] = 0x10
		i++
		if m.Clear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FetchStepId) > 0 {
		dAtA14 := make([]byte, len(m.FetchStepId)*10)
		var j13 int
		for _, num1 := range m.FetchStepId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWorker(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *LabeledStepStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabeledStepStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StepId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.StepId))
	}
	if m.StepStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.StepStats.Size()))
		n15, err := m.StepStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *LoggingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoggingResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Step) > 0 {
		for _, msg := range m.Step {
			dAtA[i] = 0xa
			i++
			i = encodeVarintWorker(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TraceOpts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceOpts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Duration != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Worker(dAtA, i, uint64(math.Float64bits(float64(m.Duration))))
	}
	if m.UseStepProfiler {
		dAtA[i] = 0x10
		i++
		if m.UseStepProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseKernelProfiler {
		dAtA[i] = 0x18
		i++
		if m.UseKernelProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseExtendedProfiler {
		dAtA[i] = 0x20
		i++
		if m.UseExtendedProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseGpuProfiler {
		dAtA[i] = 0x28
		i++
		if m.UseGpuProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseSampleProfiler {
		dAtA[i] = 0x30
		i++
		if m.UseSampleProfiler {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TracingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWorker(dAtA, i, uint64(m.Options.Size()))
		n16, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *TracingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracingResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Worker(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Worker(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintWorker(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetStatusRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetStatusResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.DeviceAttributes) > 0 {
		for _, e := range m.DeviceAttributes {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	return n
}

func (m *CreateWorkerSessionRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.ServerDef != nil {
		l = m.ServerDef.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *CreateWorkerSessionResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RegisterGraphRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.GraphDef != nil {
		l = m.GraphDef.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.HasControlFlow {
		n += 2
	}
	if m.GraphOptions != nil {
		l = m.GraphOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.DebugOptions != nil {
		l = m.DebugOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *RegisterGraphResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.GraphHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *DeregisterGraphRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.GraphHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *DeregisterGraphResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CleanupAllRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Container) > 0 {
		for _, s := range m.Container {
			l = len(s)
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	return n
}

func (m *CleanupAllResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ExecutorOpts) Size() (n int) {
	var l int
	_ = l
	if m.RecordCosts {
		n += 2
	}
	if m.RecordTimeline {
		n += 2
	}
	if m.RecordPartitionGraphs {
		n += 2
	}
	return n
}

func (m *RunGraphRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.GraphHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	if len(m.Send) > 0 {
		for _, e := range m.Send {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if len(m.RecvKey) > 0 {
		for _, s := range m.RecvKey {
			l = len(s)
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.ExecOpts != nil {
		l = m.ExecOpts.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.IsPartial {
		n += 2
	}
	if m.IsLastPartialRun {
		n += 2
	}
	l = len(m.SessionHandle)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *RunGraphResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Recv) > 0 {
		for _, e := range m.Recv {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	if m.StepStats != nil {
		l = m.StepStats.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.CostGraph != nil {
		l = m.CostGraph.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if len(m.PartitionGraph) > 0 {
		for _, e := range m.PartitionGraph {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	return n
}

func (m *CleanupGraphRequest) Size() (n int) {
	var l int
	_ = l
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	return n
}

func (m *CleanupGraphResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RecvTensorRequest) Size() (n int) {
	var l int
	_ = l
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	l = len(m.RendezvousKey)
	if l > 0 {
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.DmaOk {
		n += 2
	}
	if m.ClientLocality != nil {
		l = m.ClientLocality.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.ServerLocality != nil {
		l = m.ServerLocality.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.TransportOptions != nil {
		l = m.TransportOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *RecvTensorResponse) Size() (n int) {
	var l int
	_ = l
	if m.Tensor != nil {
		l = m.Tensor.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	if m.IsDead {
		n += 2
	}
	if m.SendStartMicros != 0 {
		n += 1 + sovWorker(uint64(m.SendStartMicros))
	}
	if m.TransportOptions != nil {
		l = m.TransportOptions.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *LoggingRequest) Size() (n int) {
	var l int
	_ = l
	if m.RpcLogging {
		n += 2
	}
	if m.Clear {
		n += 2
	}
	if len(m.FetchStepId) > 0 {
		l = 0
		for _, e := range m.FetchStepId {
			l += sovWorker(uint64(e))
		}
		n += 1 + sovWorker(uint64(l)) + l
	}
	return n
}

func (m *LabeledStepStats) Size() (n int) {
	var l int
	_ = l
	if m.StepId != 0 {
		n += 1 + sovWorker(uint64(m.StepId))
	}
	if m.StepStats != nil {
		l = m.StepStats.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *LoggingResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Step) > 0 {
		for _, e := range m.Step {
			l = e.Size()
			n += 1 + l + sovWorker(uint64(l))
		}
	}
	return n
}

func (m *TraceOpts) Size() (n int) {
	var l int
	_ = l
	if m.Duration != 0 {
		n += 9
	}
	if m.UseStepProfiler {
		n += 2
	}
	if m.UseKernelProfiler {
		n += 2
	}
	if m.UseExtendedProfiler {
		n += 2
	}
	if m.UseGpuProfiler {
		n += 2
	}
	if m.UseSampleProfiler {
		n += 2
	}
	return n
}

func (m *TracingRequest) Size() (n int) {
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovWorker(uint64(l))
	}
	return n
}

func (m *TracingResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovWorker(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWorker(x uint64) (n int) {
	return sovWorker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GetStatusRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetStatusRequest{`,
		`}`,
	}, "")
	return s
}
func (this *GetStatusResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetStatusResponse{`,
		`DeviceAttributes:` + strings.Replace(fmt.Sprintf("%v", this.DeviceAttributes), "DeviceAttributes", "tensorflow7.DeviceAttributes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateWorkerSessionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateWorkerSessionRequest{`,
		`SessionHandle:` + fmt.Sprintf("%v", this.SessionHandle) + `,`,
		`ServerDef:` + strings.Replace(fmt.Sprintf("%v", this.ServerDef), "ServerDef", "tensorflow21.ServerDef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateWorkerSessionResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateWorkerSessionResponse{`,
		`}`,
	}, "")
	return s
}
func (this *RegisterGraphRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegisterGraphRequest{`,
		`SessionHandle:` + fmt.Sprintf("%v", this.SessionHandle) + `,`,
		`GraphDef:` + strings.Replace(fmt.Sprintf("%v", this.GraphDef), "GraphDef", "tensorflow15.GraphDef", 1) + `,`,
		`HasControlFlow:` + fmt.Sprintf("%v", this.HasControlFlow) + `,`,
		`GraphOptions:` + strings.Replace(fmt.Sprintf("%v", this.GraphOptions), "GraphOptions", "tensorflow19.GraphOptions", 1) + `,`,
		`DebugOptions:` + strings.Replace(fmt.Sprintf("%v", this.DebugOptions), "DebugOptions", "tensorflow16.DebugOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegisterGraphResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegisterGraphResponse{`,
		`GraphHandle:` + fmt.Sprintf("%v", this.GraphHandle) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeregisterGraphRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeregisterGraphRequest{`,
		`GraphHandle:` + fmt.Sprintf("%v", this.GraphHandle) + `,`,
		`SessionHandle:` + fmt.Sprintf("%v", this.SessionHandle) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeregisterGraphResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeregisterGraphResponse{`,
		`}`,
	}, "")
	return s
}
func (this *CleanupAllRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CleanupAllRequest{`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CleanupAllResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CleanupAllResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ExecutorOpts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutorOpts{`,
		`RecordCosts:` + fmt.Sprintf("%v", this.RecordCosts) + `,`,
		`RecordTimeline:` + fmt.Sprintf("%v", this.RecordTimeline) + `,`,
		`RecordPartitionGraphs:` + fmt.Sprintf("%v", this.RecordPartitionGraphs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RunGraphRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RunGraphRequest{`,
		`GraphHandle:` + fmt.Sprintf("%v", this.GraphHandle) + `,`,
		`StepId:` + fmt.Sprintf("%v", this.StepId) + `,`,
		`Send:` + strings.Replace(fmt.Sprintf("%v", this.Send), "NamedTensorProto", "tensorflow20.NamedTensorProto", 1) + `,`,
		`RecvKey:` + fmt.Sprintf("%v", this.RecvKey) + `,`,
		`ExecOpts:` + strings.Replace(fmt.Sprintf("%v", this.ExecOpts), "ExecutorOpts", "ExecutorOpts", 1) + `,`,
		`IsPartial:` + fmt.Sprintf("%v", this.IsPartial) + `,`,
		`IsLastPartialRun:` + fmt.Sprintf("%v", this.IsLastPartialRun) + `,`,
		`SessionHandle:` + fmt.Sprintf("%v", this.SessionHandle) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RunGraphResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RunGraphResponse{`,
		`Recv:` + strings.Replace(fmt.Sprintf("%v", this.Recv), "NamedTensorProto", "tensorflow20.NamedTensorProto", 1) + `,`,
		`StepStats:` + strings.Replace(fmt.Sprintf("%v", this.StepStats), "StepStats", "tensorflow6.StepStats", 1) + `,`,
		`CostGraph:` + strings.Replace(fmt.Sprintf("%v", this.CostGraph), "CostGraphDef", "tensorflow3.CostGraphDef", 1) + `,`,
		`PartitionGraph:` + strings.Replace(fmt.Sprintf("%v", this.PartitionGraph), "GraphDef", "tensorflow15.GraphDef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CleanupGraphRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CleanupGraphRequest{`,
		`StepId:` + fmt.Sprintf("%v", this.StepId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CleanupGraphResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CleanupGraphResponse{`,
		`}`,
	}, "")
	return s
}
func (this *RecvTensorRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecvTensorRequest{`,
		`StepId:` + fmt.Sprintf("%v", this.StepId) + `,`,
		`RendezvousKey:` + fmt.Sprintf("%v", this.RendezvousKey) + `,`,
		`DmaOk:` + fmt.Sprintf("%v", this.DmaOk) + `,`,
		`ClientLocality:` + strings.Replace(fmt.Sprintf("%v", this.ClientLocality), "DeviceLocality", "tensorflow7.DeviceLocality", 1) + `,`,
		`ServerLocality:` + strings.Replace(fmt.Sprintf("%v", this.ServerLocality), "DeviceLocality", "tensorflow7.DeviceLocality", 1) + `,`,
		`TransportOptions:` + strings.Replace(fmt.Sprintf("%v", this.TransportOptions), "Any", "google_protobuf.Any", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecvTensorResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecvTensorResponse{`,
		`Tensor:` + strings.Replace(fmt.Sprintf("%v", this.Tensor), "TensorProto", "tensorflow9.TensorProto", 1) + `,`,
		`IsDead:` + fmt.Sprintf("%v", this.IsDead) + `,`,
		`SendStartMicros:` + fmt.Sprintf("%v", this.SendStartMicros) + `,`,
		`TransportOptions:` + strings.Replace(fmt.Sprintf("%v", this.TransportOptions), "Any", "google_protobuf.Any", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoggingRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoggingRequest{`,
		`RpcLogging:` + fmt.Sprintf("%v", this.RpcLogging) + `,`,
		`Clear:` + fmt.Sprintf("%v", this.Clear) + `,`,
		`FetchStepId:` + fmt.Sprintf("%v", this.FetchStepId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabeledStepStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabeledStepStats{`,
		`StepId:` + fmt.Sprintf("%v", this.StepId) + `,`,
		`StepStats:` + strings.Replace(fmt.Sprintf("%v", this.StepStats), "StepStats", "tensorflow6.StepStats", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoggingResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoggingResponse{`,
		`Step:` + strings.Replace(fmt.Sprintf("%v", this.Step), "LabeledStepStats", "LabeledStepStats", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TraceOpts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TraceOpts{`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`UseStepProfiler:` + fmt.Sprintf("%v", this.UseStepProfiler) + `,`,
		`UseKernelProfiler:` + fmt.Sprintf("%v", this.UseKernelProfiler) + `,`,
		`UseExtendedProfiler:` + fmt.Sprintf("%v", this.UseExtendedProfiler) + `,`,
		`UseGpuProfiler:` + fmt.Sprintf("%v", this.UseGpuProfiler) + `,`,
		`UseSampleProfiler:` + fmt.Sprintf("%v", this.UseSampleProfiler) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TracingRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TracingRequest{`,
		`Options:` + strings.Replace(fmt.Sprintf("%v", this.Options), "TraceOpts", "TraceOpts", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TracingResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TracingResponse{`,
		`}`,
	}, "")
	return s
}
func valueToStringWorker(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GetStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceAttributes = append(m.DeviceAttributes, &tensorflow7.DeviceAttributes{})
			if err := m.DeviceAttributes[len(m.DeviceAttributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWorkerSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWorkerSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWorkerSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerDef == nil {
				m.ServerDef = &tensorflow21.ServerDef{}
			}
			if err := m.ServerDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWorkerSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWorkerSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWorkerSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterGraphRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphDef == nil {
				m.GraphDef = &tensorflow15.GraphDef{}
			}
			if err := m.GraphDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasControlFlow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasControlFlow = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphOptions == nil {
				m.GraphOptions = &tensorflow19.GraphOptions{}
			}
			if err := m.GraphOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DebugOptions == nil {
				m.DebugOptions = &tensorflow16.DebugOptions{}
			}
			if err := m.DebugOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterGraphResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeregisterGraphRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeregisterGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeregisterGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeregisterGraphResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeregisterGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeregisterGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupAllRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupAllRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupAllRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = append(m.Container, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupAllResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupAllResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupAllResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorOpts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorOpts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorOpts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCosts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordCosts = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordTimeline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordTimeline = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordPartitionGraphs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordPartitionGraphs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunGraphRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Send = append(m.Send, &tensorflow20.NamedTensorProto{})
			if err := m.Send[len(m.Send)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecvKey = append(m.RecvKey, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecOpts == nil {
				m.ExecOpts = &ExecutorOpts{}
			}
			if err := m.ExecOpts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartial", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartial = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLastPartialRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLastPartialRun = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionHandle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunGraphResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recv = append(m.Recv, &tensorflow20.NamedTensorProto{})
			if err := m.Recv[len(m.Recv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StepStats == nil {
				m.StepStats = &tensorflow6.StepStats{}
			}
			if err := m.StepStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostGraph == nil {
				m.CostGraph = &tensorflow3.CostGraphDef{}
			}
			if err := m.CostGraph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionGraph = append(m.PartitionGraph, &tensorflow15.GraphDef{})
			if err := m.PartitionGraph[len(m.PartitionGraph)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupGraphRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupGraphResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvTensorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvTensorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvTensorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RendezvousKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RendezvousKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmaOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DmaOk = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLocality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientLocality == nil {
				m.ClientLocality = &tensorflow7.DeviceLocality{}
			}
			if err := m.ClientLocality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerLocality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerLocality == nil {
				m.ServerLocality = &tensorflow7.DeviceLocality{}
			}
			if err := m.ServerLocality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportOptions == nil {
				m.TransportOptions = &google_protobuf.Any{}
			}
			if err := m.TransportOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvTensorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvTensorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvTensorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tensor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tensor == nil {
				m.Tensor = &tensorflow9.TensorProto{}
			}
			if err := m.Tensor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDead = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendStartMicros", wireType)
			}
			m.SendStartMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendStartMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransportOptions == nil {
				m.TransportOptions = &google_protobuf.Any{}
			}
			if err := m.TransportOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcLogging", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RpcLogging = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clear = bool(v != 0)
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FetchStepId = append(m.FetchStepId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWorker
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWorker
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FetchStepId = append(m.FetchStepId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchStepId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabeledStepStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabeledStepStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabeledStepStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			m.StepId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StepStats == nil {
				m.StepStats = &tensorflow6.StepStats{}
			}
			if err := m.StepStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoggingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoggingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoggingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = append(m.Step, &LabeledStepStats{})
			if err := m.Step[len(m.Step)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceOpts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceOpts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceOpts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Duration = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseStepProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseStepProfiler = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseKernelProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseKernelProfiler = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseExtendedProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseExtendedProfiler = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseGpuProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseGpuProfiler = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSampleProfiler", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSampleProfiler = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWorker
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &TraceOpts{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWorker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWorker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWorker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWorker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWorker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWorker
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWorker
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWorker(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWorker = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWorker   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/core/protobuf/worker.proto", fileDescriptorWorker)
}

var fileDescriptorWorker = []byte{
	// 1316 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4b, 0x6f, 0x1c, 0x45,
	0x10, 0xf6, 0xf8, 0xb1, 0xde, 0x2d, 0x27, 0xfb, 0x98, 0xd8, 0xf1, 0xc6, 0x24, 0x8b, 0x19, 0x11,
	0xb0, 0x02, 0xd8, 0x89, 0x79, 0x49, 0x48, 0x39, 0x38, 0x76, 0x08, 0x51, 0x0c, 0xb1, 0xda, 0x91,
	0x38, 0x20, 0x31, 0x6a, 0xcf, 0xd4, 0xae, 0x47, 0x9e, 0x9d, 0x1e, 0xba, 0x7b, 0x9c, 0x98, 0x13,
	0x3f, 0x01, 0x38, 0xf3, 0x03, 0xf8, 0x07, 0xfc, 0x03, 0xc4, 0x05, 0x29, 0x47, 0x8e, 0x64, 0xb9,
	0x70, 0x8c, 0x38, 0x71, 0x44, 0xfd, 0x98, 0xd9, 0xf1, 0x3e, 0x64, 0x85, 0xdb, 0x74, 0xd5, 0x57,
	0xd5, 0xd5, 0x5f, 0x7f, 0x55, 0x3d, 0xb0, 0x99, 0x72, 0x26, 0xd9, 0x51, 0xd6, 0xdd, 0x92, 0x98,
	0x08, 0xc6, 0xbb, 0x31, 0x7b, 0xba, 0x15, 0x30, 0x8e, 0x5b, 0x85, 0xe3, 0x29, 0xe3, 0x27, 0xc8,
	0x0d, 0xd0, 0x85, 0x21, 0x6c, 0xed, 0x5a, 0x8f, 0xb1, 0x5e, 0x5c, 0x42, 0xd2, 0xe4, 0xcc, 0xc0,
	0xd6, 0x6e, 0x8d, 0x66, 0xeb, 0x72, 0xda, 0x47, 0x95, 0x69, 0x2b, 0x60, 0x42, 0xfa, 0x3d, 0x4e,
	0xd3, 0xe3, 0x8b, 0xb1, 0x42, 0x62, 0xea, 0x0b, 0x49, 0xa5, 0xb0, 0xd8, 0x3b, 0xd3, 0xb1, 0x21,
	0x9e, 0x46, 0x01, 0xfa, 0x54, 0x4a, 0x1e, 0x1d, 0x65, 0x12, 0xf3, 0x90, 0x9b, 0xd3, 0x43, 0xca,
	0x55, 0xbc, 0x35, 0x1d, 0x66, 0x3c, 0xd3, 0xd2, 0x15, 0xa7, 0x0f, 0x58, 0xd2, 0x8d, 0x7a, 0x16,
	0xf6, 0xe6, 0x54, 0x58, 0x88, 0x47, 0x59, 0x8e, 0x7a, 0x67, 0x2a, 0x2a, 0xa1, 0x7d, 0x0c, 0xfd,
	0x73, 0x3b, 0xdf, 0x9e, 0x0a, 0x1e, 0x3a, 0x7c, 0x81, 0xfc, 0x34, 0xbf, 0x2c, 0xcf, 0x85, 0xe6,
	0x03, 0x94, 0x87, 0x92, 0xca, 0x4c, 0x10, 0xfc, 0x26, 0x43, 0x21, 0xbd, 0xaf, 0xa1, 0x55, 0xb2,
	0x89, 0x94, 0x25, 0x02, 0xdd, 0x87, 0xd0, 0x1a, 0xa3, 0xaf, 0xed, 0xac, 0xcf, 0x6d, 0x2c, 0x6d,
	0x5f, 0xdf, 0x1c, 0x66, 0xdf, 0xdc, 0xd3, 0xa0, 0x9d, 0x02, 0x43, 0x9a, 0xe1, 0x88, 0xc5, 0x3b,
	0x83, 0xb5, 0x5d, 0x8e, 0x54, 0xe2, 0x97, 0x5a, 0x36, 0x87, 0x28, 0x44, 0xc4, 0x12, 0xbb, 0xbb,
	0x7b, 0x13, 0xea, 0xc2, 0x58, 0xfc, 0x63, 0x9a, 0x84, 0x31, 0xb6, 0x9d, 0x75, 0x67, 0xa3, 0x46,
	0x2e, 0x5b, 0xeb, 0x67, 0xda, 0xe8, 0x7e, 0x00, 0x60, 0x0e, 0xe2, 0x87, 0xd8, 0x6d, 0xcf, 0xae,
	0x3b, 0x1b, 0x4b, 0xdb, 0x2b, 0xe5, 0x42, 0x0e, 0xb5, 0x77, 0x0f, 0xbb, 0xa4, 0x26, 0xf2, 0x4f,
	0xef, 0x06, 0xbc, 0x36, 0x71, 0x6b, 0x73, 0x48, 0xef, 0xa7, 0x59, 0x58, 0x26, 0xd8, 0x8b, 0x84,
	0x44, 0xfe, 0x40, 0xdd, 0xfc, 0x2b, 0x16, 0x75, 0x07, 0x6a, 0x5a, 0x30, 0xa5, 0x9a, 0x96, 0xcb,
	0x35, 0xe9, 0x9c, 0xaa, 0xa4, 0x6a, 0xcf, 0x7e, 0xb9, 0xef, 0x42, 0xf3, 0x98, 0x0a, 0x3f, 0x60,
	0x89, 0xe4, 0x2c, 0xf6, 0x15, 0xac, 0x3d, 0xb7, 0xee, 0x6c, 0x54, 0xef, 0xcd, 0xb6, 0x1d, 0x52,
	0x3f, 0xa6, 0x62, 0xd7, 0xb8, 0x3e, 0x8d, 0xd9, 0x53, 0xf7, 0x2e, 0x5c, 0x36, 0x1b, 0xb0, 0x54,
	0x46, 0x2c, 0x11, 0xed, 0x79, 0xbd, 0x49, 0x7b, 0x6c, 0x93, 0xc7, 0xc6, 0x4f, 0x2e, 0xf5, 0x4a,
	0x2b, 0x15, 0xae, 0xb5, 0x55, 0x84, 0x2f, 0x8c, 0x87, 0xef, 0x29, 0x40, 0x11, 0x1e, 0x96, 0x56,
	0xde, 0x27, 0xb0, 0x32, 0xc2, 0x8e, 0x15, 0xc7, 0x1b, 0x60, 0xf6, 0x39, 0x4f, 0xce, 0x92, 0xb6,
	0x19, 0x6a, 0xbc, 0x23, 0xb8, 0xba, 0x87, 0x7c, 0x12, 0xb7, 0x17, 0x07, 0x4f, 0xa0, 0x7f, 0x76,
	0x02, 0xfd, 0xde, 0x35, 0x58, 0x1d, 0xdb, 0xc3, 0xde, 0xec, 0x1d, 0x68, 0xed, 0xc6, 0x48, 0x93,
	0x2c, 0xdd, 0x89, 0xe3, 0x7c, 0xe7, 0xeb, 0x50, 0x53, 0xbc, 0xd3, 0x28, 0x41, 0xae, 0xb5, 0x5c,
	0x23, 0x43, 0x83, 0xb7, 0x0c, 0x6e, 0x39, 0xc4, 0x26, 0xfa, 0xd1, 0x81, 0x4b, 0xf7, 0x9f, 0x61,
	0x90, 0x49, 0xc6, 0x1f, 0xa7, 0x52, 0xa8, 0xf2, 0x39, 0x06, 0x8c, 0x87, 0xbe, 0x1a, 0x5b, 0x42,
	0x97, 0x5f, 0x25, 0x4b, 0xc6, 0xb6, 0xab, 0x4c, 0xee, 0xdb, 0xd0, 0xb0, 0x10, 0x19, 0xf5, 0x31,
	0x8e, 0x12, 0x34, 0x57, 0x4c, 0xea, 0xc6, 0xfc, 0xc4, 0x5a, 0xdd, 0x8f, 0x60, 0xd5, 0x02, 0x53,
	0xca, 0x65, 0xa4, 0x58, 0x37, 0x73, 0xd0, 0x5c, 0x74, 0x95, 0xac, 0x18, 0xf7, 0x41, 0xee, 0xd5,
	0x87, 0x14, 0xde, 0xaf, 0xb3, 0xd0, 0x20, 0x59, 0xf2, 0xaa, 0xb4, 0xae, 0xc2, 0xa2, 0x1e, 0x9f,
	0x51, 0xa8, 0xf9, 0x9c, 0x23, 0x15, 0xb5, 0x7c, 0x18, 0xba, 0xb7, 0x61, 0x5e, 0x60, 0x12, 0xb6,
	0xe7, 0xc6, 0xfb, 0xfb, 0x0b, 0x35, 0x75, 0x9e, 0xe8, 0xf5, 0x81, 0x9a, 0x20, 0x44, 0x23, 0xdd,
	0x6b, 0x50, 0xe5, 0x18, 0x9c, 0xfa, 0x27, 0x78, 0xd6, 0x9e, 0xd7, 0x4c, 0x2e, 0xaa, 0xf5, 0x23,
	0x3c, 0x73, 0x3f, 0x84, 0x1a, 0x3e, 0xc3, 0x40, 0x69, 0x6e, 0xa2, 0xe0, 0xca, 0x6c, 0x92, 0xaa,
	0x82, 0x6a, 0x5e, 0x6f, 0x00, 0x44, 0xc2, 0xf0, 0x40, 0xe3, 0x76, 0x45, 0x1f, 0xbf, 0x16, 0x89,
	0x03, 0x63, 0x70, 0xdf, 0x83, 0x2b, 0x91, 0xf0, 0x63, 0x2a, 0x64, 0x8e, 0xf1, 0x79, 0x96, 0xb4,
	0x17, 0x35, 0xae, 0x19, 0x89, 0x7d, 0x2a, 0xa4, 0xc5, 0x92, 0x2c, 0x99, 0xa0, 0xa0, 0xea, 0x24,
	0x05, 0xfd, 0xe3, 0x40, 0x73, 0x48, 0xa4, 0x55, 0xf7, 0x6d, 0x98, 0x57, 0x67, 0x99, 0x34, 0xed,
	0xc6, 0xd9, 0x50, 0x48, 0x3d, 0x9c, 0x8a, 0x77, 0x69, 0xe2, 0x70, 0x92, 0x98, 0xaa, 0x01, 0x2b,
	0x48, 0x4d, 0xe4, 0x9f, 0xee, 0xc7, 0x00, 0xc3, 0x97, 0x4f, 0x2b, 0x64, 0x84, 0x29, 0xa5, 0xa6,
	0x62, 0x84, 0xd4, 0x82, 0x7c, 0xe5, 0xde, 0x85, 0xc6, 0x88, 0x5e, 0xf4, 0x1d, 0x4c, 0x1b, 0x3e,
	0xf5, 0xf4, 0x9c, 0x7c, 0xbc, 0x4d, 0xb8, 0x62, 0x85, 0x7e, 0x4e, 0x40, 0x25, 0x75, 0x38, 0x65,
	0x75, 0x78, 0x57, 0x61, 0xf9, 0x3c, 0xde, 0xb6, 0xc6, 0x2f, 0xb3, 0xd0, 0x22, 0x18, 0x9c, 0x1a,
	0x3e, 0x2e, 0x4a, 0xa3, 0xae, 0x84, 0x63, 0x12, 0xe2, 0xb7, 0xa7, 0x2c, 0x13, 0x5a, 0x38, 0xb6,
	0xa9, 0x87, 0x56, 0x25, 0x9f, 0x15, 0xa8, 0x84, 0x7d, 0xea, 0xb3, 0x13, 0xdb, 0x33, 0x0b, 0x61,
	0x9f, 0x3e, 0x3e, 0x71, 0x77, 0xa1, 0x11, 0xc4, 0x11, 0x26, 0xd2, 0x8f, 0x59, 0x40, 0xe3, 0x48,
	0x9e, 0xd9, 0x59, 0xb8, 0x36, 0xfe, 0x1a, 0xed, 0x5b, 0x04, 0xa9, 0x9b, 0x90, 0x7c, 0xad, 0x92,
	0xd8, 0x47, 0xa4, 0x48, 0xb2, 0x70, 0x71, 0x12, 0x13, 0x52, 0x24, 0xd9, 0x81, 0x96, 0xe4, 0x34,
	0x11, 0x29, 0xe3, 0xb2, 0x18, 0xac, 0x15, 0x3b, 0xfc, 0xcd, 0xff, 0x4f, 0xf1, 0x0b, 0xb5, 0xb9,
	0x93, 0x9c, 0x91, 0x66, 0x01, 0xcf, 0x07, 0xeb, 0xef, 0x0e, 0xb8, 0x65, 0xe6, 0xac, 0xf0, 0xb6,
	0xa0, 0x62, 0xca, 0xd0, 0xcc, 0x2d, 0x6d, 0xaf, 0x96, 0xab, 0x2a, 0xab, 0xce, 0xc2, 0x14, 0xd7,
	0x91, 0xf0, 0x43, 0xa4, 0xa6, 0xa1, 0xab, 0xa4, 0x12, 0x89, 0x3d, 0xa4, 0xa1, 0x7b, 0x0b, 0x5a,
	0xaa, 0x4d, 0x95, 0x20, 0xb9, 0xf4, 0xfb, 0x51, 0xc0, 0x99, 0xd0, 0x7c, 0xce, 0x91, 0x86, 0x72,
	0x1c, 0x2a, 0xfb, 0xe7, 0xda, 0x3c, 0xf9, 0x3c, 0xf3, 0xaf, 0x74, 0x9e, 0x13, 0xa8, 0xef, 0xb3,
	0x5e, 0x2f, 0x4a, 0x7a, 0xb9, 0x0a, 0x5e, 0x87, 0x25, 0x9e, 0x06, 0x7e, 0x6c, 0xac, 0x76, 0x48,
	0x02, 0x4f, 0x03, 0x8b, 0x73, 0x97, 0x61, 0x21, 0x88, 0x91, 0x72, 0x5b, 0xb8, 0x59, 0xb8, 0x1e,
	0x5c, 0xee, 0xa2, 0x0c, 0x8e, 0xfd, 0x5c, 0x42, 0x6a, 0x22, 0xcd, 0x91, 0x25, 0x6d, 0x3c, 0x34,
	0x72, 0xa4, 0xd0, 0xdc, 0xa7, 0x47, 0x18, 0x63, 0x58, 0x74, 0xd5, 0x74, 0xd1, 0xfd, 0xaf, 0xce,
	0xf4, 0x76, 0xa1, 0x51, 0x9c, 0x67, 0x38, 0x14, 0x94, 0x7f, 0xd2, 0x50, 0x18, 0xad, 0x86, 0x68,
	0xa4, 0xf7, 0xc3, 0x2c, 0xd4, 0x9e, 0x70, 0x1a, 0xa0, 0x1e, 0x6f, 0x6b, 0x50, 0x0d, 0x33, 0x4e,
	0x15, 0x5f, 0xba, 0x44, 0x87, 0x14, 0x6b, 0x75, 0x5b, 0x99, 0x40, 0x73, 0xe6, 0x94, 0xb3, 0x6e,
	0x14, 0x63, 0xce, 0x4b, 0x23, 0x13, 0xa8, 0x12, 0x1f, 0x58, 0xb3, 0xbb, 0x09, 0x57, 0x14, 0xf6,
	0x04, 0x79, 0x82, 0xf1, 0x10, 0x6d, 0x7a, 0x45, 0xa5, 0x79, 0xa4, 0x3d, 0x05, 0x7e, 0x1b, 0x56,
	0x14, 0x1e, 0x9f, 0x49, 0xd5, 0x65, 0xe1, 0x30, 0xc2, 0x3c, 0x30, 0x2a, 0xd9, 0x7d, 0xeb, 0x2b,
	0x62, 0x36, 0xa0, 0xa9, 0x62, 0x7a, 0x69, 0x36, 0x84, 0x2f, 0x98, 0x07, 0x2c, 0x13, 0xf8, 0x20,
	0xcd, 0x46, 0xab, 0x11, 0xb4, 0x9f, 0xc6, 0x38, 0x04, 0x57, 0x8a, 0x6a, 0x0e, 0xb5, 0x27, 0xc7,
	0x7b, 0x3b, 0x50, 0x57, 0x94, 0x94, 0x84, 0xb2, 0x05, 0x8b, 0xb9, 0xe6, 0x9c, 0xf1, 0xdb, 0x29,
	0xf8, 0x23, 0x39, 0xca, 0x6b, 0x41, 0xa3, 0x48, 0x61, 0xee, 0xe6, 0xde, 0x57, 0xcf, 0x5f, 0x74,
	0x66, 0xfe, 0x78, 0xd1, 0x99, 0x79, 0xf9, 0xa2, 0xe3, 0x7c, 0x37, 0xe8, 0x38, 0x3f, 0x0f, 0x3a,
	0xce, 0x6f, 0x83, 0x8e, 0xf3, 0x7c, 0xd0, 0x71, 0xfe, 0x1c, 0x74, 0x9c, 0xbf, 0x07, 0x9d, 0x99,
	0x97, 0x83, 0x8e, 0xf3, 0xfd, 0x5f, 0x9d, 0x19, 0x58, 0x63, 0xbc, 0x57, 0xde, 0x23, 0x8c, 0x84,
	0xe4, 0x59, 0xa2, 0x9e, 0xea, 0x7b, 0x97, 0xcc, 0x7f, 0xa2, 0xee, 0x32, 0x71, 0xe0, 0xfc, 0xeb,
	0x38, 0x47, 0x15, 0xad, 0xfd, 0xf7, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x45, 0x9b, 0x7f, 0xff,
	0x17, 0x0d, 0x00, 0x00,
}
