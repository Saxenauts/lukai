// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/core/protobuf/config.proto

/*
	Package tensorflow is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/core/protobuf/config.proto

	It has these top-level messages:
		GPUOptions
		OptimizerOptions
		GraphOptions
		ThreadPoolOptionProto
		RPCOptions
		ConfigProto
		RunOptions
		RunMetadata
*/
package tensorflow

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import tensorflow3 "github.com/d4l3k/pok/tensorflow/core/framework"
import tensorflow11 "github.com/d4l3k/pok/tensorflow/core/framework"
import tensorflow14 "github.com/d4l3k/pok/tensorflow/core/framework"
import tensorflow15 "github.com/d4l3k/pok/tensorflow/core/protobuf"
import tensorflow16 "github.com/d4l3k/pok/tensorflow/core/protobuf"
import tensorflow17 "github.com/d4l3k/pok/tensorflow/core/protobuf"

import strconv "strconv"

import fmt "fmt"
import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Optimization level
type OptimizerOptions_Level int32

const (
	// L1 is the default level.
	// Optimization performed at L1 :
	// 1. Common subexpression elimination
	// 2. Constant folding
	L1 OptimizerOptions_Level = 0
	// No optimizations
	L0 OptimizerOptions_Level = -1
)

var OptimizerOptions_Level_name = map[int32]string{
	0:  "L1",
	-1: "L0",
}
var OptimizerOptions_Level_value = map[string]int32{
	"L1": 0,
	"L0": -1,
}

func (OptimizerOptions_Level) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorConfig, []int{1, 0}
}

// Control the use of the compiler/jit.  Experimental.
type OptimizerOptions_GlobalJitLevel int32

const (
	DEFAULT OptimizerOptions_GlobalJitLevel = 0
	OFF     OptimizerOptions_GlobalJitLevel = -1
	// The following settings turn on compilation, with higher values being
	// more aggressive.  Higher values may reduce opportunities for parallelism
	// and may use more memory.  (At present, there is no distinction, but this
	// is expected to change.)
	ON_1 OptimizerOptions_GlobalJitLevel = 1
	ON_2 OptimizerOptions_GlobalJitLevel = 2
)

var OptimizerOptions_GlobalJitLevel_name = map[int32]string{
	0:  "DEFAULT",
	-1: "OFF",
	1:  "ON_1",
	2:  "ON_2",
}
var OptimizerOptions_GlobalJitLevel_value = map[string]int32{
	"DEFAULT": 0,
	"OFF":     -1,
	"ON_1":    1,
	"ON_2":    2,
}

func (OptimizerOptions_GlobalJitLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorConfig, []int{1, 1}
}

// TODO(pbar) Turn this into a TraceOptions proto which allows
// tracing to be controlled in a more orthogonal manner?
type RunOptions_TraceLevel int32

const (
	NO_TRACE       RunOptions_TraceLevel = 0
	SOFTWARE_TRACE RunOptions_TraceLevel = 1
	HARDWARE_TRACE RunOptions_TraceLevel = 2
	FULL_TRACE     RunOptions_TraceLevel = 3
)

var RunOptions_TraceLevel_name = map[int32]string{
	0: "NO_TRACE",
	1: "SOFTWARE_TRACE",
	2: "HARDWARE_TRACE",
	3: "FULL_TRACE",
}
var RunOptions_TraceLevel_value = map[string]int32{
	"NO_TRACE":       0,
	"SOFTWARE_TRACE": 1,
	"HARDWARE_TRACE": 2,
	"FULL_TRACE":     3,
}

func (RunOptions_TraceLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorConfig, []int{6, 0}
}

type GPUOptions struct {
	// A value between 0 and 1 that indicates what fraction of the
	// available GPU memory to pre-allocate for each process.  1 means
	// to pre-allocate all of the GPU memory, 0.5 means the process
	// allocates ~50% of the available GPU memory.
	PerProcessGpuMemoryFraction float64 `protobuf:"fixed64,1,opt,name=per_process_gpu_memory_fraction,json=perProcessGpuMemoryFraction,proto3" json:"per_process_gpu_memory_fraction,omitempty"`
	// The type of GPU allocation strategy to use.
	//
	// Allowed values:
	// "": The empty string (default) uses a system-chosen default
	//     which may change over time.
	//
	// "BFC": A "Best-fit with coalescing" algorithm, simplified from a
	//        version of dlmalloc.
	AllocatorType string `protobuf:"bytes,2,opt,name=allocator_type,json=allocatorType,proto3" json:"allocator_type,omitempty"`
	// Delay deletion of up to this many bytes to reduce the number of
	// interactions with gpu driver code.  If 0, the system chooses
	// a reasonable default (several MBs).
	DeferredDeletionBytes int64 `protobuf:"varint,3,opt,name=deferred_deletion_bytes,json=deferredDeletionBytes,proto3" json:"deferred_deletion_bytes,omitempty"`
	// If true, the allocator does not pre-allocate the entire specified
	// GPU memory region, instead starting small and growing as needed.
	AllowGrowth bool `protobuf:"varint,4,opt,name=allow_growth,json=allowGrowth,proto3" json:"allow_growth,omitempty"`
	// A comma-separated list of GPU ids that determines the 'visible'
	// to 'virtual' mapping of GPU devices.  For example, if TensorFlow
	// can see 8 GPU devices in the process, and one wanted to map
	// visible GPU devices 5 and 3 as "/gpu:0", and "/gpu:1", then one
	// would specify this field as "5,3".  This field is similar in
	// spirit to the CUDA_VISIBLE_DEVICES environment variable, except
	// it applies to the visible GPU devices in the process.
	//
	// NOTE: The GPU driver provides the process with the visible GPUs
	// in an order which is not guaranteed to have any correlation to
	// the *physical* GPU id in the machine.  This field is used for
	// remapping "visible" to "virtual", which means this operates only
	// after the process starts.  Users are required to use vendor
	// specific mechanisms (e.g., CUDA_VISIBLE_DEVICES) to control the
	// physical to visible device mapping prior to invoking TensorFlow.
	VisibleDeviceList string `protobuf:"bytes,5,opt,name=visible_device_list,json=visibleDeviceList,proto3" json:"visible_device_list,omitempty"`
	// In the event polling loop sleep this many microseconds between
	// PollEvents calls, when the queue is not empty.  If value is not
	// set or set to 0, gets set to a non-zero default.
	PollingActiveDelayUsecs int32 `protobuf:"varint,6,opt,name=polling_active_delay_usecs,json=pollingActiveDelayUsecs,proto3" json:"polling_active_delay_usecs,omitempty"`
	// In the event polling loop sleep this many millisconds between
	// PollEvents calls, when the queue is empty.  If value is not
	// set or set to 0, gets set to a non-zero default.
	PollingInactiveDelayMsecs int32 `protobuf:"varint,7,opt,name=polling_inactive_delay_msecs,json=pollingInactiveDelayMsecs,proto3" json:"polling_inactive_delay_msecs,omitempty"`
	// Force all tensors to be gpu_compatible. On a GPU-enabled TensorFlow,
	// enabling this option forces all CPU tensors to be allocated with Cuda
	// pinned memory. Normally, TensorFlow will infer which tensors should be
	// allocated as the pinned memory. But in case where the inference is
	// incomplete, this option can significantly speed up the cross-device memory
	// copy performance as long as it fits the memory.
	// Note that this option is not something that should be
	// enabled by default for unknown or very large models, since all Cuda pinned
	// memory is unpageable, having too much pinned memory might negatively impact
	// the overall host system performance.
	ForceGpuCompatible bool `protobuf:"varint,8,opt,name=force_gpu_compatible,json=forceGpuCompatible,proto3" json:"force_gpu_compatible,omitempty"`
}

func (m *GPUOptions) Reset()                    { *m = GPUOptions{} }
func (*GPUOptions) ProtoMessage()               {}
func (*GPUOptions) Descriptor() ([]byte, []int) { return fileDescriptorConfig, []int{0} }

func (m *GPUOptions) GetPerProcessGpuMemoryFraction() float64 {
	if m != nil {
		return m.PerProcessGpuMemoryFraction
	}
	return 0
}

func (m *GPUOptions) GetAllocatorType() string {
	if m != nil {
		return m.AllocatorType
	}
	return ""
}

func (m *GPUOptions) GetDeferredDeletionBytes() int64 {
	if m != nil {
		return m.DeferredDeletionBytes
	}
	return 0
}

func (m *GPUOptions) GetAllowGrowth() bool {
	if m != nil {
		return m.AllowGrowth
	}
	return false
}

func (m *GPUOptions) GetVisibleDeviceList() string {
	if m != nil {
		return m.VisibleDeviceList
	}
	return ""
}

func (m *GPUOptions) GetPollingActiveDelayUsecs() int32 {
	if m != nil {
		return m.PollingActiveDelayUsecs
	}
	return 0
}

func (m *GPUOptions) GetPollingInactiveDelayMsecs() int32 {
	if m != nil {
		return m.PollingInactiveDelayMsecs
	}
	return 0
}

func (m *GPUOptions) GetForceGpuCompatible() bool {
	if m != nil {
		return m.ForceGpuCompatible
	}
	return false
}

// Options passed to the graph optimizer
type OptimizerOptions struct {
	// If true, optimize the graph using common subexpression elimination.
	DoCommonSubexpressionElimination bool `protobuf:"varint,1,opt,name=do_common_subexpression_elimination,json=doCommonSubexpressionElimination,proto3" json:"do_common_subexpression_elimination,omitempty"`
	// If true, perform constant folding optimization on the graph.
	DoConstantFolding bool `protobuf:"varint,2,opt,name=do_constant_folding,json=doConstantFolding,proto3" json:"do_constant_folding,omitempty"`
	// If true, perform function inlining on the graph.
	DoFunctionInlining bool `protobuf:"varint,4,opt,name=do_function_inlining,json=doFunctionInlining,proto3" json:"do_function_inlining,omitempty"`
	// Overall optimization level. The actual optimizations applied will be the
	// logical OR of the flags that this level implies and any flags already set.
	OptLevel       OptimizerOptions_Level          `protobuf:"varint,3,opt,name=opt_level,json=optLevel,proto3,enum=tensorflow.OptimizerOptions_Level" json:"opt_level,omitempty"`
	GlobalJitLevel OptimizerOptions_GlobalJitLevel `protobuf:"varint,5,opt,name=global_jit_level,json=globalJitLevel,proto3,enum=tensorflow.OptimizerOptions_GlobalJitLevel" json:"global_jit_level,omitempty"`
}

func (m *OptimizerOptions) Reset()                    { *m = OptimizerOptions{} }
func (*OptimizerOptions) ProtoMessage()               {}
func (*OptimizerOptions) Descriptor() ([]byte, []int) { return fileDescriptorConfig, []int{1} }

func (m *OptimizerOptions) GetDoCommonSubexpressionElimination() bool {
	if m != nil {
		return m.DoCommonSubexpressionElimination
	}
	return false
}

func (m *OptimizerOptions) GetDoConstantFolding() bool {
	if m != nil {
		return m.DoConstantFolding
	}
	return false
}

func (m *OptimizerOptions) GetDoFunctionInlining() bool {
	if m != nil {
		return m.DoFunctionInlining
	}
	return false
}

func (m *OptimizerOptions) GetOptLevel() OptimizerOptions_Level {
	if m != nil {
		return m.OptLevel
	}
	return L1
}

func (m *OptimizerOptions) GetGlobalJitLevel() OptimizerOptions_GlobalJitLevel {
	if m != nil {
		return m.GlobalJitLevel
	}
	return DEFAULT
}

type GraphOptions struct {
	// If true, use control flow to schedule the activation of Recv nodes.
	// (Currently ignored.)
	EnableRecvScheduling bool `protobuf:"varint,2,opt,name=enable_recv_scheduling,json=enableRecvScheduling,proto3" json:"enable_recv_scheduling,omitempty"`
	// Options controlling how graph is optimized.
	OptimizerOptions *OptimizerOptions `protobuf:"bytes,3,opt,name=optimizer_options,json=optimizerOptions" json:"optimizer_options,omitempty"`
	// The number of steps to run before returning a cost model detailing
	// the memory usage and performance of each node of the graph. 0 means
	// no cost model.
	BuildCostModel int64 `protobuf:"varint,4,opt,name=build_cost_model,json=buildCostModel,proto3" json:"build_cost_model,omitempty"`
	// The number of steps to skip before collecting statistics for the
	// cost model.
	BuildCostModelAfter int64 `protobuf:"varint,9,opt,name=build_cost_model_after,json=buildCostModelAfter,proto3" json:"build_cost_model_after,omitempty"`
	// Annotate each Node with Op output shape data, to the extent it can
	// be statically inferred.
	InferShapes bool `protobuf:"varint,5,opt,name=infer_shapes,json=inferShapes,proto3" json:"infer_shapes,omitempty"`
	// Only place the subgraphs that are run, rather than the entire graph.
	//
	// This is useful for interactive graph building, where one might
	// produce graphs that cannot be placed during the debugging
	// process.  In particular, it allows the client to continue work in
	// a session after adding a node to a graph whose placement
	// constraints are unsatisfiable.
	PlacePrunedGraph bool `protobuf:"varint,6,opt,name=place_pruned_graph,json=placePrunedGraph,proto3" json:"place_pruned_graph,omitempty"`
	// If true, transfer float values between processes as bfloat16.
	EnableBfloat16Sendrecv bool `protobuf:"varint,7,opt,name=enable_bfloat16_sendrecv,json=enableBfloat16Sendrecv,proto3" json:"enable_bfloat16_sendrecv,omitempty"`
	// If > 0, record a timeline every this many steps.
	// EXPERIMENTAL: This currently has no effect in MasterSession.
	TimelineStep int32 `protobuf:"varint,8,opt,name=timeline_step,json=timelineStep,proto3" json:"timeline_step,omitempty"`
	// Options that control the type and amount of graph rewriting.
	// Not currently configurable via the public Python API (i.e. there is no API
	// stability guarantee if you import RewriterConfig explicitly).
	RewriteOptions *tensorflow17.RewriterConfig `protobuf:"bytes,10,opt,name=rewrite_options,json=rewriteOptions" json:"rewrite_options,omitempty"`
}

func (m *GraphOptions) Reset()                    { *m = GraphOptions{} }
func (*GraphOptions) ProtoMessage()               {}
func (*GraphOptions) Descriptor() ([]byte, []int) { return fileDescriptorConfig, []int{2} }

func (m *GraphOptions) GetEnableRecvScheduling() bool {
	if m != nil {
		return m.EnableRecvScheduling
	}
	return false
}

func (m *GraphOptions) GetOptimizerOptions() *OptimizerOptions {
	if m != nil {
		return m.OptimizerOptions
	}
	return nil
}

func (m *GraphOptions) GetBuildCostModel() int64 {
	if m != nil {
		return m.BuildCostModel
	}
	return 0
}

func (m *GraphOptions) GetBuildCostModelAfter() int64 {
	if m != nil {
		return m.BuildCostModelAfter
	}
	return 0
}

func (m *GraphOptions) GetInferShapes() bool {
	if m != nil {
		return m.InferShapes
	}
	return false
}

func (m *GraphOptions) GetPlacePrunedGraph() bool {
	if m != nil {
		return m.PlacePrunedGraph
	}
	return false
}

func (m *GraphOptions) GetEnableBfloat16Sendrecv() bool {
	if m != nil {
		return m.EnableBfloat16Sendrecv
	}
	return false
}

func (m *GraphOptions) GetTimelineStep() int32 {
	if m != nil {
		return m.TimelineStep
	}
	return 0
}

func (m *GraphOptions) GetRewriteOptions() *tensorflow17.RewriterConfig {
	if m != nil {
		return m.RewriteOptions
	}
	return nil
}

type ThreadPoolOptionProto struct {
	// The number of threads in the pool.
	//
	// 0 means the system picks a value based on where this option proto is used
	// (see the declaration of the specific field for more info).
	NumThreads int32 `protobuf:"varint,1,opt,name=num_threads,json=numThreads,proto3" json:"num_threads,omitempty"`
	// The global name of the threadpool.
	//
	// If empty, then the threadpool is made and used according to the scope it's
	// in - e.g., for a session threadpool, it is used by that session only.
	//
	// If non-empty, then:
	// - a global threadpool associated with this name is looked
	//   up or created. This allows, for example, sharing one threadpool across
	//   many sessions (e.g., like the default behavior, if
	//   inter_op_parallelism_threads is not configured), but still partitioning
	//   into a large and small pool.
	// - if the threadpool for this global_name already exists, then it is an
	//   error if the existing pool was created using a different num_threads
	//   value as is specified on this call.
	// - threadpools created this way are never garbage collected.
	GlobalName string `protobuf:"bytes,2,opt,name=global_name,json=globalName,proto3" json:"global_name,omitempty"`
}

func (m *ThreadPoolOptionProto) Reset()                    { *m = ThreadPoolOptionProto{} }
func (*ThreadPoolOptionProto) ProtoMessage()               {}
func (*ThreadPoolOptionProto) Descriptor() ([]byte, []int) { return fileDescriptorConfig, []int{3} }

func (m *ThreadPoolOptionProto) GetNumThreads() int32 {
	if m != nil {
		return m.NumThreads
	}
	return 0
}

func (m *ThreadPoolOptionProto) GetGlobalName() string {
	if m != nil {
		return m.GlobalName
	}
	return ""
}

type RPCOptions struct {
	// If true, always use RPC to contact the session target.
	//
	// If false (the default option), TensorFlow may use an optimized
	// transport for client-master communication that avoids the RPC
	// stack. This option is primarily for used testing the RPC stack.
	UseRpcForInprocessMaster bool `protobuf:"varint,1,opt,name=use_rpc_for_inprocess_master,json=useRpcForInprocessMaster,proto3" json:"use_rpc_for_inprocess_master,omitempty"`
}

func (m *RPCOptions) Reset()                    { *m = RPCOptions{} }
func (*RPCOptions) ProtoMessage()               {}
func (*RPCOptions) Descriptor() ([]byte, []int) { return fileDescriptorConfig, []int{4} }

func (m *RPCOptions) GetUseRpcForInprocessMaster() bool {
	if m != nil {
		return m.UseRpcForInprocessMaster
	}
	return false
}

// Session configuration parameters.
// The system picks appropriate values for fields that are not set.
type ConfigProto struct {
	// Map from device type name (e.g., "CPU" or "GPU" ) to maximum
	// number of devices of that type to use.  If a particular device
	// type is not found in the map, the system picks an appropriate
	// number.
	DeviceCount map[string]int32 `protobuf:"bytes,1,rep,name=device_count,json=deviceCount" json:"device_count,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// The execution of an individual op (for some op types) can be
	// parallelized on a pool of intra_op_parallelism_threads.
	// 0 means the system picks an appropriate number.
	IntraOpParallelismThreads int32 `protobuf:"varint,2,opt,name=intra_op_parallelism_threads,json=intraOpParallelismThreads,proto3" json:"intra_op_parallelism_threads,omitempty"`
	// Nodes that perform blocking operations are enqueued on a pool of
	// inter_op_parallelism_threads available in each process.
	//
	// 0 means the system picks an appropriate number.
	//
	// Note that the first Session created in the process sets the
	// number of threads for all future sessions unless use_per_session_threads is
	// true or session_inter_op_thread_pool is configured.
	InterOpParallelismThreads int32 `protobuf:"varint,5,opt,name=inter_op_parallelism_threads,json=interOpParallelismThreads,proto3" json:"inter_op_parallelism_threads,omitempty"`
	// If true, use a new set of threads for this session rather than the global
	// pool of threads. Only supported by direct sessions.
	//
	// If false, use the global threads created by the first session, or the
	// per-session thread pools configured by session_inter_op_thread_pool.
	//
	// This option is deprecated. The same effect can be achieved by setting
	// session_inter_op_thread_pool to have one element, whose num_threads equals
	// inter_op_parallelism_threads.
	UsePerSessionThreads bool `protobuf:"varint,9,opt,name=use_per_session_threads,json=usePerSessionThreads,proto3" json:"use_per_session_threads,omitempty"`
	// This option is experimental - it may be replaced with a different mechanism
	// in the future.
	//
	// Configures session thread pools. If this is configured, then RunOptions for
	// a Run call can select the thread pool to use.
	//
	// The intended use is for when some session invocations need to run in a
	// background pool limited to a small number of threads:
	// - For example, a session may be configured to have one large pool (for
	// regular compute) and one small pool (for periodic, low priority work);
	// using the small pool is currently the mechanism for limiting the inter-op
	// parallelism of the low priority work.  Note that it does not limit the
	// parallelism of work spawned by a single op kernel implementation.
	// - Using this setting is normally not needed in training, but may help some
	// serving use cases.
	// - It is also generally recommended to set the global_name field of this
	// proto, to avoid creating multiple large pools. It is typically better to
	// run the non-low-priority work, even across sessions, in a single large
	// pool.
	SessionInterOpThreadPool []*ThreadPoolOptionProto `protobuf:"bytes,12,rep,name=session_inter_op_thread_pool,json=sessionInterOpThreadPool" json:"session_inter_op_thread_pool,omitempty"`
	// Assignment of Nodes to Devices is recomputed every placement_period
	// steps until the system warms up (at which point the recomputation
	// typically slows down automatically).
	PlacementPeriod int32 `protobuf:"varint,3,opt,name=placement_period,json=placementPeriod,proto3" json:"placement_period,omitempty"`
	// When any filters are present sessions will ignore all devices which do not
	// match the filters. Each filter can be partially specified, e.g. "/job:ps"
	// "/job:worker/replica:3", etc.
	DeviceFilters []string `protobuf:"bytes,4,rep,name=device_filters,json=deviceFilters" json:"device_filters,omitempty"`
	// Options that apply to all GPUs.
	GpuOptions *GPUOptions `protobuf:"bytes,6,opt,name=gpu_options,json=gpuOptions" json:"gpu_options,omitempty"`
	// Whether soft placement is allowed. If allow_soft_placement is true,
	// an op will be placed on CPU if
	//   1. there's no GPU implementation for the OP
	// or
	//   2. no GPU devices are known or registered
	// or
	//   3. need to co-locate with reftype input(s) which are from CPU.
	AllowSoftPlacement bool `protobuf:"varint,7,opt,name=allow_soft_placement,json=allowSoftPlacement,proto3" json:"allow_soft_placement,omitempty"`
	// Whether device placements should be logged.
	LogDevicePlacement bool `protobuf:"varint,8,opt,name=log_device_placement,json=logDevicePlacement,proto3" json:"log_device_placement,omitempty"`
	// Options that apply to all graphs.
	GraphOptions *GraphOptions `protobuf:"bytes,10,opt,name=graph_options,json=graphOptions" json:"graph_options,omitempty"`
	// Global timeout for all blocking operations in this session.  If non-zero,
	// and not overridden on a per-operation basis, this value will be used as the
	// deadline for all blocking operations.
	OperationTimeoutInMs int64 `protobuf:"varint,11,opt,name=operation_timeout_in_ms,json=operationTimeoutInMs,proto3" json:"operation_timeout_in_ms,omitempty"`
	// Options that apply when this session uses the distributed runtime.
	RpcOptions *RPCOptions `protobuf:"bytes,13,opt,name=rpc_options,json=rpcOptions" json:"rpc_options,omitempty"`
	// Optional list of all workers to use in this session.
	ClusterDef *tensorflow16.ClusterDef `protobuf:"bytes,14,opt,name=cluster_def,json=clusterDef" json:"cluster_def,omitempty"`
}

func (m *ConfigProto) Reset()                    { *m = ConfigProto{} }
func (*ConfigProto) ProtoMessage()               {}
func (*ConfigProto) Descriptor() ([]byte, []int) { return fileDescriptorConfig, []int{5} }

func (m *ConfigProto) GetDeviceCount() map[string]int32 {
	if m != nil {
		return m.DeviceCount
	}
	return nil
}

func (m *ConfigProto) GetIntraOpParallelismThreads() int32 {
	if m != nil {
		return m.IntraOpParallelismThreads
	}
	return 0
}

func (m *ConfigProto) GetInterOpParallelismThreads() int32 {
	if m != nil {
		return m.InterOpParallelismThreads
	}
	return 0
}

func (m *ConfigProto) GetUsePerSessionThreads() bool {
	if m != nil {
		return m.UsePerSessionThreads
	}
	return false
}

func (m *ConfigProto) GetSessionInterOpThreadPool() []*ThreadPoolOptionProto {
	if m != nil {
		return m.SessionInterOpThreadPool
	}
	return nil
}

func (m *ConfigProto) GetPlacementPeriod() int32 {
	if m != nil {
		return m.PlacementPeriod
	}
	return 0
}

func (m *ConfigProto) GetDeviceFilters() []string {
	if m != nil {
		return m.DeviceFilters
	}
	return nil
}

func (m *ConfigProto) GetGpuOptions() *GPUOptions {
	if m != nil {
		return m.GpuOptions
	}
	return nil
}

func (m *ConfigProto) GetAllowSoftPlacement() bool {
	if m != nil {
		return m.AllowSoftPlacement
	}
	return false
}

func (m *ConfigProto) GetLogDevicePlacement() bool {
	if m != nil {
		return m.LogDevicePlacement
	}
	return false
}

func (m *ConfigProto) GetGraphOptions() *GraphOptions {
	if m != nil {
		return m.GraphOptions
	}
	return nil
}

func (m *ConfigProto) GetOperationTimeoutInMs() int64 {
	if m != nil {
		return m.OperationTimeoutInMs
	}
	return 0
}

func (m *ConfigProto) GetRpcOptions() *RPCOptions {
	if m != nil {
		return m.RpcOptions
	}
	return nil
}

func (m *ConfigProto) GetClusterDef() *tensorflow16.ClusterDef {
	if m != nil {
		return m.ClusterDef
	}
	return nil
}

// Options for a single Run() call.
type RunOptions struct {
	TraceLevel RunOptions_TraceLevel `protobuf:"varint,1,opt,name=trace_level,json=traceLevel,proto3,enum=tensorflow.RunOptions_TraceLevel" json:"trace_level,omitempty"`
	// Time to wait for operation to complete in milliseconds.
	TimeoutInMs int64 `protobuf:"varint,2,opt,name=timeout_in_ms,json=timeoutInMs,proto3" json:"timeout_in_ms,omitempty"`
	// The thread pool to use, if session_inter_op_thread_pool is configured.
	InterOpThreadPool int32 `protobuf:"varint,3,opt,name=inter_op_thread_pool,json=interOpThreadPool,proto3" json:"inter_op_thread_pool,omitempty"`
	// Whether the partition graph(s) executed by the executor(s) should be
	// outputted via RunMetadata.
	OutputPartitionGraphs bool `protobuf:"varint,5,opt,name=output_partition_graphs,json=outputPartitionGraphs,proto3" json:"output_partition_graphs,omitempty"`
	// EXPERIMENTAL.  Options used to initialize DebuggerState, if enabled.
	DebugOptions *tensorflow15.DebugOptions `protobuf:"bytes,6,opt,name=debug_options,json=debugOptions" json:"debug_options,omitempty"`
}

func (m *RunOptions) Reset()                    { *m = RunOptions{} }
func (*RunOptions) ProtoMessage()               {}
func (*RunOptions) Descriptor() ([]byte, []int) { return fileDescriptorConfig, []int{6} }

func (m *RunOptions) GetTraceLevel() RunOptions_TraceLevel {
	if m != nil {
		return m.TraceLevel
	}
	return NO_TRACE
}

func (m *RunOptions) GetTimeoutInMs() int64 {
	if m != nil {
		return m.TimeoutInMs
	}
	return 0
}

func (m *RunOptions) GetInterOpThreadPool() int32 {
	if m != nil {
		return m.InterOpThreadPool
	}
	return 0
}

func (m *RunOptions) GetOutputPartitionGraphs() bool {
	if m != nil {
		return m.OutputPartitionGraphs
	}
	return false
}

func (m *RunOptions) GetDebugOptions() *tensorflow15.DebugOptions {
	if m != nil {
		return m.DebugOptions
	}
	return nil
}

// Metadata output (i.e., non-Tensor) for a single Run() call.
type RunMetadata struct {
	// Statistics traced for this step. Populated if tracing is turned on via the
	// "RunOptions" proto.
	// EXPERIMENTAL: The format and set of events may change in future versions.
	StepStats *tensorflow14.StepStats `protobuf:"bytes,1,opt,name=step_stats,json=stepStats" json:"step_stats,omitempty"`
	// The cost graph for the computation defined by the run call.
	CostGraph *tensorflow3.CostGraphDef `protobuf:"bytes,2,opt,name=cost_graph,json=costGraph" json:"cost_graph,omitempty"`
	// Graphs of the partitions executed by executors.
	PartitionGraphs []*tensorflow11.GraphDef `protobuf:"bytes,3,rep,name=partition_graphs,json=partitionGraphs" json:"partition_graphs,omitempty"`
}

func (m *RunMetadata) Reset()                    { *m = RunMetadata{} }
func (*RunMetadata) ProtoMessage()               {}
func (*RunMetadata) Descriptor() ([]byte, []int) { return fileDescriptorConfig, []int{7} }

func (m *RunMetadata) GetStepStats() *tensorflow14.StepStats {
	if m != nil {
		return m.StepStats
	}
	return nil
}

func (m *RunMetadata) GetCostGraph() *tensorflow3.CostGraphDef {
	if m != nil {
		return m.CostGraph
	}
	return nil
}

func (m *RunMetadata) GetPartitionGraphs() []*tensorflow11.GraphDef {
	if m != nil {
		return m.PartitionGraphs
	}
	return nil
}

func init() {
	proto.RegisterType((*GPUOptions)(nil), "tensorflow.GPUOptions")
	proto.RegisterType((*OptimizerOptions)(nil), "tensorflow.OptimizerOptions")
	proto.RegisterType((*GraphOptions)(nil), "tensorflow.GraphOptions")
	proto.RegisterType((*ThreadPoolOptionProto)(nil), "tensorflow.ThreadPoolOptionProto")
	proto.RegisterType((*RPCOptions)(nil), "tensorflow.RPCOptions")
	proto.RegisterType((*ConfigProto)(nil), "tensorflow.ConfigProto")
	proto.RegisterType((*RunOptions)(nil), "tensorflow.RunOptions")
	proto.RegisterType((*RunMetadata)(nil), "tensorflow.RunMetadata")
	proto.RegisterEnum("tensorflow.OptimizerOptions_Level", OptimizerOptions_Level_name, OptimizerOptions_Level_value)
	proto.RegisterEnum("tensorflow.OptimizerOptions_GlobalJitLevel", OptimizerOptions_GlobalJitLevel_name, OptimizerOptions_GlobalJitLevel_value)
	proto.RegisterEnum("tensorflow.RunOptions_TraceLevel", RunOptions_TraceLevel_name, RunOptions_TraceLevel_value)
}
func (x OptimizerOptions_Level) String() string {
	s, ok := OptimizerOptions_Level_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OptimizerOptions_GlobalJitLevel) String() string {
	s, ok := OptimizerOptions_GlobalJitLevel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RunOptions_TraceLevel) String() string {
	s, ok := RunOptions_TraceLevel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *GPUOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GPUOptions)
	if !ok {
		that2, ok := that.(GPUOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.PerProcessGpuMemoryFraction != that1.PerProcessGpuMemoryFraction {
		return false
	}
	if this.AllocatorType != that1.AllocatorType {
		return false
	}
	if this.DeferredDeletionBytes != that1.DeferredDeletionBytes {
		return false
	}
	if this.AllowGrowth != that1.AllowGrowth {
		return false
	}
	if this.VisibleDeviceList != that1.VisibleDeviceList {
		return false
	}
	if this.PollingActiveDelayUsecs != that1.PollingActiveDelayUsecs {
		return false
	}
	if this.PollingInactiveDelayMsecs != that1.PollingInactiveDelayMsecs {
		return false
	}
	if this.ForceGpuCompatible != that1.ForceGpuCompatible {
		return false
	}
	return true
}
func (this *OptimizerOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OptimizerOptions)
	if !ok {
		that2, ok := that.(OptimizerOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.DoCommonSubexpressionElimination != that1.DoCommonSubexpressionElimination {
		return false
	}
	if this.DoConstantFolding != that1.DoConstantFolding {
		return false
	}
	if this.DoFunctionInlining != that1.DoFunctionInlining {
		return false
	}
	if this.OptLevel != that1.OptLevel {
		return false
	}
	if this.GlobalJitLevel != that1.GlobalJitLevel {
		return false
	}
	return true
}
func (this *GraphOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GraphOptions)
	if !ok {
		that2, ok := that.(GraphOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.EnableRecvScheduling != that1.EnableRecvScheduling {
		return false
	}
	if !this.OptimizerOptions.Equal(that1.OptimizerOptions) {
		return false
	}
	if this.BuildCostModel != that1.BuildCostModel {
		return false
	}
	if this.BuildCostModelAfter != that1.BuildCostModelAfter {
		return false
	}
	if this.InferShapes != that1.InferShapes {
		return false
	}
	if this.PlacePrunedGraph != that1.PlacePrunedGraph {
		return false
	}
	if this.EnableBfloat16Sendrecv != that1.EnableBfloat16Sendrecv {
		return false
	}
	if this.TimelineStep != that1.TimelineStep {
		return false
	}
	if !this.RewriteOptions.Equal(that1.RewriteOptions) {
		return false
	}
	return true
}
func (this *ThreadPoolOptionProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ThreadPoolOptionProto)
	if !ok {
		that2, ok := that.(ThreadPoolOptionProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NumThreads != that1.NumThreads {
		return false
	}
	if this.GlobalName != that1.GlobalName {
		return false
	}
	return true
}
func (this *RPCOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RPCOptions)
	if !ok {
		that2, ok := that.(RPCOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.UseRpcForInprocessMaster != that1.UseRpcForInprocessMaster {
		return false
	}
	return true
}
func (this *ConfigProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ConfigProto)
	if !ok {
		that2, ok := that.(ConfigProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.DeviceCount) != len(that1.DeviceCount) {
		return false
	}
	for i := range this.DeviceCount {
		if this.DeviceCount[i] != that1.DeviceCount[i] {
			return false
		}
	}
	if this.IntraOpParallelismThreads != that1.IntraOpParallelismThreads {
		return false
	}
	if this.InterOpParallelismThreads != that1.InterOpParallelismThreads {
		return false
	}
	if this.UsePerSessionThreads != that1.UsePerSessionThreads {
		return false
	}
	if len(this.SessionInterOpThreadPool) != len(that1.SessionInterOpThreadPool) {
		return false
	}
	for i := range this.SessionInterOpThreadPool {
		if !this.SessionInterOpThreadPool[i].Equal(that1.SessionInterOpThreadPool[i]) {
			return false
		}
	}
	if this.PlacementPeriod != that1.PlacementPeriod {
		return false
	}
	if len(this.DeviceFilters) != len(that1.DeviceFilters) {
		return false
	}
	for i := range this.DeviceFilters {
		if this.DeviceFilters[i] != that1.DeviceFilters[i] {
			return false
		}
	}
	if !this.GpuOptions.Equal(that1.GpuOptions) {
		return false
	}
	if this.AllowSoftPlacement != that1.AllowSoftPlacement {
		return false
	}
	if this.LogDevicePlacement != that1.LogDevicePlacement {
		return false
	}
	if !this.GraphOptions.Equal(that1.GraphOptions) {
		return false
	}
	if this.OperationTimeoutInMs != that1.OperationTimeoutInMs {
		return false
	}
	if !this.RpcOptions.Equal(that1.RpcOptions) {
		return false
	}
	if !this.ClusterDef.Equal(that1.ClusterDef) {
		return false
	}
	return true
}
func (this *RunOptions) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RunOptions)
	if !ok {
		that2, ok := that.(RunOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.TraceLevel != that1.TraceLevel {
		return false
	}
	if this.TimeoutInMs != that1.TimeoutInMs {
		return false
	}
	if this.InterOpThreadPool != that1.InterOpThreadPool {
		return false
	}
	if this.OutputPartitionGraphs != that1.OutputPartitionGraphs {
		return false
	}
	if !this.DebugOptions.Equal(that1.DebugOptions) {
		return false
	}
	return true
}
func (this *RunMetadata) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RunMetadata)
	if !ok {
		that2, ok := that.(RunMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.StepStats.Equal(that1.StepStats) {
		return false
	}
	if !this.CostGraph.Equal(that1.CostGraph) {
		return false
	}
	if len(this.PartitionGraphs) != len(that1.PartitionGraphs) {
		return false
	}
	for i := range this.PartitionGraphs {
		if !this.PartitionGraphs[i].Equal(that1.PartitionGraphs[i]) {
			return false
		}
	}
	return true
}
func (this *GPUOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tensorflow.GPUOptions{")
	s = append(s, "PerProcessGpuMemoryFraction: "+fmt.Sprintf("%#v", this.PerProcessGpuMemoryFraction)+",\n")
	s = append(s, "AllocatorType: "+fmt.Sprintf("%#v", this.AllocatorType)+",\n")
	s = append(s, "DeferredDeletionBytes: "+fmt.Sprintf("%#v", this.DeferredDeletionBytes)+",\n")
	s = append(s, "AllowGrowth: "+fmt.Sprintf("%#v", this.AllowGrowth)+",\n")
	s = append(s, "VisibleDeviceList: "+fmt.Sprintf("%#v", this.VisibleDeviceList)+",\n")
	s = append(s, "PollingActiveDelayUsecs: "+fmt.Sprintf("%#v", this.PollingActiveDelayUsecs)+",\n")
	s = append(s, "PollingInactiveDelayMsecs: "+fmt.Sprintf("%#v", this.PollingInactiveDelayMsecs)+",\n")
	s = append(s, "ForceGpuCompatible: "+fmt.Sprintf("%#v", this.ForceGpuCompatible)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OptimizerOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tensorflow.OptimizerOptions{")
	s = append(s, "DoCommonSubexpressionElimination: "+fmt.Sprintf("%#v", this.DoCommonSubexpressionElimination)+",\n")
	s = append(s, "DoConstantFolding: "+fmt.Sprintf("%#v", this.DoConstantFolding)+",\n")
	s = append(s, "DoFunctionInlining: "+fmt.Sprintf("%#v", this.DoFunctionInlining)+",\n")
	s = append(s, "OptLevel: "+fmt.Sprintf("%#v", this.OptLevel)+",\n")
	s = append(s, "GlobalJitLevel: "+fmt.Sprintf("%#v", this.GlobalJitLevel)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GraphOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&tensorflow.GraphOptions{")
	s = append(s, "EnableRecvScheduling: "+fmt.Sprintf("%#v", this.EnableRecvScheduling)+",\n")
	if this.OptimizerOptions != nil {
		s = append(s, "OptimizerOptions: "+fmt.Sprintf("%#v", this.OptimizerOptions)+",\n")
	}
	s = append(s, "BuildCostModel: "+fmt.Sprintf("%#v", this.BuildCostModel)+",\n")
	s = append(s, "BuildCostModelAfter: "+fmt.Sprintf("%#v", this.BuildCostModelAfter)+",\n")
	s = append(s, "InferShapes: "+fmt.Sprintf("%#v", this.InferShapes)+",\n")
	s = append(s, "PlacePrunedGraph: "+fmt.Sprintf("%#v", this.PlacePrunedGraph)+",\n")
	s = append(s, "EnableBfloat16Sendrecv: "+fmt.Sprintf("%#v", this.EnableBfloat16Sendrecv)+",\n")
	s = append(s, "TimelineStep: "+fmt.Sprintf("%#v", this.TimelineStep)+",\n")
	if this.RewriteOptions != nil {
		s = append(s, "RewriteOptions: "+fmt.Sprintf("%#v", this.RewriteOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ThreadPoolOptionProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow.ThreadPoolOptionProto{")
	s = append(s, "NumThreads: "+fmt.Sprintf("%#v", this.NumThreads)+",\n")
	s = append(s, "GlobalName: "+fmt.Sprintf("%#v", this.GlobalName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RPCOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.RPCOptions{")
	s = append(s, "UseRpcForInprocessMaster: "+fmt.Sprintf("%#v", this.UseRpcForInprocessMaster)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConfigProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&tensorflow.ConfigProto{")
	keysForDeviceCount := make([]string, 0, len(this.DeviceCount))
	for k, _ := range this.DeviceCount {
		keysForDeviceCount = append(keysForDeviceCount, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDeviceCount)
	mapStringForDeviceCount := "map[string]int32{"
	for _, k := range keysForDeviceCount {
		mapStringForDeviceCount += fmt.Sprintf("%#v: %#v,", k, this.DeviceCount[k])
	}
	mapStringForDeviceCount += "}"
	if this.DeviceCount != nil {
		s = append(s, "DeviceCount: "+mapStringForDeviceCount+",\n")
	}
	s = append(s, "IntraOpParallelismThreads: "+fmt.Sprintf("%#v", this.IntraOpParallelismThreads)+",\n")
	s = append(s, "InterOpParallelismThreads: "+fmt.Sprintf("%#v", this.InterOpParallelismThreads)+",\n")
	s = append(s, "UsePerSessionThreads: "+fmt.Sprintf("%#v", this.UsePerSessionThreads)+",\n")
	if this.SessionInterOpThreadPool != nil {
		s = append(s, "SessionInterOpThreadPool: "+fmt.Sprintf("%#v", this.SessionInterOpThreadPool)+",\n")
	}
	s = append(s, "PlacementPeriod: "+fmt.Sprintf("%#v", this.PlacementPeriod)+",\n")
	s = append(s, "DeviceFilters: "+fmt.Sprintf("%#v", this.DeviceFilters)+",\n")
	if this.GpuOptions != nil {
		s = append(s, "GpuOptions: "+fmt.Sprintf("%#v", this.GpuOptions)+",\n")
	}
	s = append(s, "AllowSoftPlacement: "+fmt.Sprintf("%#v", this.AllowSoftPlacement)+",\n")
	s = append(s, "LogDevicePlacement: "+fmt.Sprintf("%#v", this.LogDevicePlacement)+",\n")
	if this.GraphOptions != nil {
		s = append(s, "GraphOptions: "+fmt.Sprintf("%#v", this.GraphOptions)+",\n")
	}
	s = append(s, "OperationTimeoutInMs: "+fmt.Sprintf("%#v", this.OperationTimeoutInMs)+",\n")
	if this.RpcOptions != nil {
		s = append(s, "RpcOptions: "+fmt.Sprintf("%#v", this.RpcOptions)+",\n")
	}
	if this.ClusterDef != nil {
		s = append(s, "ClusterDef: "+fmt.Sprintf("%#v", this.ClusterDef)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RunOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tensorflow.RunOptions{")
	s = append(s, "TraceLevel: "+fmt.Sprintf("%#v", this.TraceLevel)+",\n")
	s = append(s, "TimeoutInMs: "+fmt.Sprintf("%#v", this.TimeoutInMs)+",\n")
	s = append(s, "InterOpThreadPool: "+fmt.Sprintf("%#v", this.InterOpThreadPool)+",\n")
	s = append(s, "OutputPartitionGraphs: "+fmt.Sprintf("%#v", this.OutputPartitionGraphs)+",\n")
	if this.DebugOptions != nil {
		s = append(s, "DebugOptions: "+fmt.Sprintf("%#v", this.DebugOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RunMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow.RunMetadata{")
	if this.StepStats != nil {
		s = append(s, "StepStats: "+fmt.Sprintf("%#v", this.StepStats)+",\n")
	}
	if this.CostGraph != nil {
		s = append(s, "CostGraph: "+fmt.Sprintf("%#v", this.CostGraph)+",\n")
	}
	if this.PartitionGraphs != nil {
		s = append(s, "PartitionGraphs: "+fmt.Sprintf("%#v", this.PartitionGraphs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringConfig(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GPUOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PerProcessGpuMemoryFraction != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Config(dAtA, i, uint64(math.Float64bits(float64(m.PerProcessGpuMemoryFraction))))
	}
	if len(m.AllocatorType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.AllocatorType)))
		i += copy(dAtA[i:], m.AllocatorType)
	}
	if m.DeferredDeletionBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.DeferredDeletionBytes))
	}
	if m.AllowGrowth {
		dAtA[i] = 0x20
		i++
		if m.AllowGrowth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.VisibleDeviceList) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.VisibleDeviceList)))
		i += copy(dAtA[i:], m.VisibleDeviceList)
	}
	if m.PollingActiveDelayUsecs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.PollingActiveDelayUsecs))
	}
	if m.PollingInactiveDelayMsecs != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.PollingInactiveDelayMsecs))
	}
	if m.ForceGpuCompatible {
		dAtA[i] = 0x40
		i++
		if m.ForceGpuCompatible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *OptimizerOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptimizerOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DoCommonSubexpressionElimination {
		dAtA[i] = 0x8
		i++
		if m.DoCommonSubexpressionElimination {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DoConstantFolding {
		dAtA[i] = 0x10
		i++
		if m.DoConstantFolding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OptLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.OptLevel))
	}
	if m.DoFunctionInlining {
		dAtA[i] = 0x20
		i++
		if m.DoFunctionInlining {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GlobalJitLevel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.GlobalJitLevel))
	}
	return i, nil
}

func (m *GraphOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnableRecvScheduling {
		dAtA[i] = 0x10
		i++
		if m.EnableRecvScheduling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OptimizerOptions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.OptimizerOptions.Size()))
		n1, err := m.OptimizerOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.BuildCostModel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.BuildCostModel))
	}
	if m.InferShapes {
		dAtA[i] = 0x28
		i++
		if m.InferShapes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PlacePrunedGraph {
		dAtA[i] = 0x30
		i++
		if m.PlacePrunedGraph {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableBfloat16Sendrecv {
		dAtA[i] = 0x38
		i++
		if m.EnableBfloat16Sendrecv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TimelineStep != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.TimelineStep))
	}
	if m.BuildCostModelAfter != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.BuildCostModelAfter))
	}
	if m.RewriteOptions != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.RewriteOptions.Size()))
		n2, err := m.RewriteOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ThreadPoolOptionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreadPoolOptionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumThreads != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.NumThreads))
	}
	if len(m.GlobalName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.GlobalName)))
		i += copy(dAtA[i:], m.GlobalName)
	}
	return i, nil
}

func (m *RPCOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPCOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseRpcForInprocessMaster {
		dAtA[i] = 0x8
		i++
		if m.UseRpcForInprocessMaster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ConfigProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DeviceCount) > 0 {
		for k, _ := range m.DeviceCount {
			dAtA[i] = 0xa
			i++
			v := m.DeviceCount[k]
			mapSize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + sovConfig(uint64(v))
			i = encodeVarintConfig(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintConfig(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintConfig(dAtA, i, uint64(v))
		}
	}
	if m.IntraOpParallelismThreads != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.IntraOpParallelismThreads))
	}
	if m.PlacementPeriod != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.PlacementPeriod))
	}
	if len(m.DeviceFilters) > 0 {
		for _, s := range m.DeviceFilters {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.InterOpParallelismThreads != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.InterOpParallelismThreads))
	}
	if m.GpuOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.GpuOptions.Size()))
		n3, err := m.GpuOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.AllowSoftPlacement {
		dAtA[i] = 0x38
		i++
		if m.AllowSoftPlacement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LogDevicePlacement {
		dAtA[i] = 0x40
		i++
		if m.LogDevicePlacement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UsePerSessionThreads {
		dAtA[i] = 0x48
		i++
		if m.UsePerSessionThreads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GraphOptions != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.GraphOptions.Size()))
		n4, err := m.GraphOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.OperationTimeoutInMs != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.OperationTimeoutInMs))
	}
	if len(m.SessionInterOpThreadPool) > 0 {
		for _, msg := range m.SessionInterOpThreadPool {
			dAtA[i] = 0x62
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RpcOptions != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.RpcOptions.Size()))
		n5, err := m.RpcOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ClusterDef != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.ClusterDef.Size()))
		n6, err := m.ClusterDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *RunOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TraceLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.TraceLevel))
	}
	if m.TimeoutInMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.TimeoutInMs))
	}
	if m.InterOpThreadPool != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.InterOpThreadPool))
	}
	if m.OutputPartitionGraphs {
		dAtA[i] = 0x28
		i++
		if m.OutputPartitionGraphs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DebugOptions != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.DebugOptions.Size()))
		n7, err := m.DebugOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *RunMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StepStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.StepStats.Size()))
		n8, err := m.StepStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CostGraph != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.CostGraph.Size()))
		n9, err := m.CostGraph.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.PartitionGraphs) > 0 {
		for _, msg := range m.PartitionGraphs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Config(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Config(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintConfig(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GPUOptions) Size() (n int) {
	var l int
	_ = l
	if m.PerProcessGpuMemoryFraction != 0 {
		n += 9
	}
	l = len(m.AllocatorType)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.DeferredDeletionBytes != 0 {
		n += 1 + sovConfig(uint64(m.DeferredDeletionBytes))
	}
	if m.AllowGrowth {
		n += 2
	}
	l = len(m.VisibleDeviceList)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.PollingActiveDelayUsecs != 0 {
		n += 1 + sovConfig(uint64(m.PollingActiveDelayUsecs))
	}
	if m.PollingInactiveDelayMsecs != 0 {
		n += 1 + sovConfig(uint64(m.PollingInactiveDelayMsecs))
	}
	if m.ForceGpuCompatible {
		n += 2
	}
	return n
}

func (m *OptimizerOptions) Size() (n int) {
	var l int
	_ = l
	if m.DoCommonSubexpressionElimination {
		n += 2
	}
	if m.DoConstantFolding {
		n += 2
	}
	if m.OptLevel != 0 {
		n += 1 + sovConfig(uint64(m.OptLevel))
	}
	if m.DoFunctionInlining {
		n += 2
	}
	if m.GlobalJitLevel != 0 {
		n += 1 + sovConfig(uint64(m.GlobalJitLevel))
	}
	return n
}

func (m *GraphOptions) Size() (n int) {
	var l int
	_ = l
	if m.EnableRecvScheduling {
		n += 2
	}
	if m.OptimizerOptions != nil {
		l = m.OptimizerOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.BuildCostModel != 0 {
		n += 1 + sovConfig(uint64(m.BuildCostModel))
	}
	if m.InferShapes {
		n += 2
	}
	if m.PlacePrunedGraph {
		n += 2
	}
	if m.EnableBfloat16Sendrecv {
		n += 2
	}
	if m.TimelineStep != 0 {
		n += 1 + sovConfig(uint64(m.TimelineStep))
	}
	if m.BuildCostModelAfter != 0 {
		n += 1 + sovConfig(uint64(m.BuildCostModelAfter))
	}
	if m.RewriteOptions != nil {
		l = m.RewriteOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *ThreadPoolOptionProto) Size() (n int) {
	var l int
	_ = l
	if m.NumThreads != 0 {
		n += 1 + sovConfig(uint64(m.NumThreads))
	}
	l = len(m.GlobalName)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *RPCOptions) Size() (n int) {
	var l int
	_ = l
	if m.UseRpcForInprocessMaster {
		n += 2
	}
	return n
}

func (m *ConfigProto) Size() (n int) {
	var l int
	_ = l
	if len(m.DeviceCount) > 0 {
		for k, v := range m.DeviceCount {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + sovConfig(uint64(v))
			n += mapEntrySize + 1 + sovConfig(uint64(mapEntrySize))
		}
	}
	if m.IntraOpParallelismThreads != 0 {
		n += 1 + sovConfig(uint64(m.IntraOpParallelismThreads))
	}
	if m.PlacementPeriod != 0 {
		n += 1 + sovConfig(uint64(m.PlacementPeriod))
	}
	if len(m.DeviceFilters) > 0 {
		for _, s := range m.DeviceFilters {
			l = len(s)
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.InterOpParallelismThreads != 0 {
		n += 1 + sovConfig(uint64(m.InterOpParallelismThreads))
	}
	if m.GpuOptions != nil {
		l = m.GpuOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.AllowSoftPlacement {
		n += 2
	}
	if m.LogDevicePlacement {
		n += 2
	}
	if m.UsePerSessionThreads {
		n += 2
	}
	if m.GraphOptions != nil {
		l = m.GraphOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.OperationTimeoutInMs != 0 {
		n += 1 + sovConfig(uint64(m.OperationTimeoutInMs))
	}
	if len(m.SessionInterOpThreadPool) > 0 {
		for _, e := range m.SessionInterOpThreadPool {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.RpcOptions != nil {
		l = m.RpcOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.ClusterDef != nil {
		l = m.ClusterDef.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *RunOptions) Size() (n int) {
	var l int
	_ = l
	if m.TraceLevel != 0 {
		n += 1 + sovConfig(uint64(m.TraceLevel))
	}
	if m.TimeoutInMs != 0 {
		n += 1 + sovConfig(uint64(m.TimeoutInMs))
	}
	if m.InterOpThreadPool != 0 {
		n += 1 + sovConfig(uint64(m.InterOpThreadPool))
	}
	if m.OutputPartitionGraphs {
		n += 2
	}
	if m.DebugOptions != nil {
		l = m.DebugOptions.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func (m *RunMetadata) Size() (n int) {
	var l int
	_ = l
	if m.StepStats != nil {
		l = m.StepStats.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.CostGraph != nil {
		l = m.CostGraph.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if len(m.PartitionGraphs) > 0 {
		for _, e := range m.PartitionGraphs {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	return n
}

func sovConfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConfig(x uint64) (n int) {
	return sovConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GPUOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GPUOptions{`,
		`PerProcessGpuMemoryFraction:` + fmt.Sprintf("%v", this.PerProcessGpuMemoryFraction) + `,`,
		`AllocatorType:` + fmt.Sprintf("%v", this.AllocatorType) + `,`,
		`DeferredDeletionBytes:` + fmt.Sprintf("%v", this.DeferredDeletionBytes) + `,`,
		`AllowGrowth:` + fmt.Sprintf("%v", this.AllowGrowth) + `,`,
		`VisibleDeviceList:` + fmt.Sprintf("%v", this.VisibleDeviceList) + `,`,
		`PollingActiveDelayUsecs:` + fmt.Sprintf("%v", this.PollingActiveDelayUsecs) + `,`,
		`PollingInactiveDelayMsecs:` + fmt.Sprintf("%v", this.PollingInactiveDelayMsecs) + `,`,
		`ForceGpuCompatible:` + fmt.Sprintf("%v", this.ForceGpuCompatible) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OptimizerOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OptimizerOptions{`,
		`DoCommonSubexpressionElimination:` + fmt.Sprintf("%v", this.DoCommonSubexpressionElimination) + `,`,
		`DoConstantFolding:` + fmt.Sprintf("%v", this.DoConstantFolding) + `,`,
		`OptLevel:` + fmt.Sprintf("%v", this.OptLevel) + `,`,
		`DoFunctionInlining:` + fmt.Sprintf("%v", this.DoFunctionInlining) + `,`,
		`GlobalJitLevel:` + fmt.Sprintf("%v", this.GlobalJitLevel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GraphOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GraphOptions{`,
		`EnableRecvScheduling:` + fmt.Sprintf("%v", this.EnableRecvScheduling) + `,`,
		`OptimizerOptions:` + strings.Replace(fmt.Sprintf("%v", this.OptimizerOptions), "OptimizerOptions", "OptimizerOptions", 1) + `,`,
		`BuildCostModel:` + fmt.Sprintf("%v", this.BuildCostModel) + `,`,
		`InferShapes:` + fmt.Sprintf("%v", this.InferShapes) + `,`,
		`PlacePrunedGraph:` + fmt.Sprintf("%v", this.PlacePrunedGraph) + `,`,
		`EnableBfloat16Sendrecv:` + fmt.Sprintf("%v", this.EnableBfloat16Sendrecv) + `,`,
		`TimelineStep:` + fmt.Sprintf("%v", this.TimelineStep) + `,`,
		`BuildCostModelAfter:` + fmt.Sprintf("%v", this.BuildCostModelAfter) + `,`,
		`RewriteOptions:` + strings.Replace(fmt.Sprintf("%v", this.RewriteOptions), "RewriterConfig", "tensorflow17.RewriterConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ThreadPoolOptionProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ThreadPoolOptionProto{`,
		`NumThreads:` + fmt.Sprintf("%v", this.NumThreads) + `,`,
		`GlobalName:` + fmt.Sprintf("%v", this.GlobalName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RPCOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RPCOptions{`,
		`UseRpcForInprocessMaster:` + fmt.Sprintf("%v", this.UseRpcForInprocessMaster) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigProto) String() string {
	if this == nil {
		return "nil"
	}
	keysForDeviceCount := make([]string, 0, len(this.DeviceCount))
	for k, _ := range this.DeviceCount {
		keysForDeviceCount = append(keysForDeviceCount, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDeviceCount)
	mapStringForDeviceCount := "map[string]int32{"
	for _, k := range keysForDeviceCount {
		mapStringForDeviceCount += fmt.Sprintf("%v: %v,", k, this.DeviceCount[k])
	}
	mapStringForDeviceCount += "}"
	s := strings.Join([]string{`&ConfigProto{`,
		`DeviceCount:` + mapStringForDeviceCount + `,`,
		`IntraOpParallelismThreads:` + fmt.Sprintf("%v", this.IntraOpParallelismThreads) + `,`,
		`PlacementPeriod:` + fmt.Sprintf("%v", this.PlacementPeriod) + `,`,
		`DeviceFilters:` + fmt.Sprintf("%v", this.DeviceFilters) + `,`,
		`InterOpParallelismThreads:` + fmt.Sprintf("%v", this.InterOpParallelismThreads) + `,`,
		`GpuOptions:` + strings.Replace(fmt.Sprintf("%v", this.GpuOptions), "GPUOptions", "GPUOptions", 1) + `,`,
		`AllowSoftPlacement:` + fmt.Sprintf("%v", this.AllowSoftPlacement) + `,`,
		`LogDevicePlacement:` + fmt.Sprintf("%v", this.LogDevicePlacement) + `,`,
		`UsePerSessionThreads:` + fmt.Sprintf("%v", this.UsePerSessionThreads) + `,`,
		`GraphOptions:` + strings.Replace(fmt.Sprintf("%v", this.GraphOptions), "GraphOptions", "GraphOptions", 1) + `,`,
		`OperationTimeoutInMs:` + fmt.Sprintf("%v", this.OperationTimeoutInMs) + `,`,
		`SessionInterOpThreadPool:` + strings.Replace(fmt.Sprintf("%v", this.SessionInterOpThreadPool), "ThreadPoolOptionProto", "ThreadPoolOptionProto", 1) + `,`,
		`RpcOptions:` + strings.Replace(fmt.Sprintf("%v", this.RpcOptions), "RPCOptions", "RPCOptions", 1) + `,`,
		`ClusterDef:` + strings.Replace(fmt.Sprintf("%v", this.ClusterDef), "ClusterDef", "tensorflow16.ClusterDef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RunOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RunOptions{`,
		`TraceLevel:` + fmt.Sprintf("%v", this.TraceLevel) + `,`,
		`TimeoutInMs:` + fmt.Sprintf("%v", this.TimeoutInMs) + `,`,
		`InterOpThreadPool:` + fmt.Sprintf("%v", this.InterOpThreadPool) + `,`,
		`OutputPartitionGraphs:` + fmt.Sprintf("%v", this.OutputPartitionGraphs) + `,`,
		`DebugOptions:` + strings.Replace(fmt.Sprintf("%v", this.DebugOptions), "DebugOptions", "tensorflow15.DebugOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RunMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RunMetadata{`,
		`StepStats:` + strings.Replace(fmt.Sprintf("%v", this.StepStats), "StepStats", "tensorflow14.StepStats", 1) + `,`,
		`CostGraph:` + strings.Replace(fmt.Sprintf("%v", this.CostGraph), "CostGraphDef", "tensorflow3.CostGraphDef", 1) + `,`,
		`PartitionGraphs:` + strings.Replace(fmt.Sprintf("%v", this.PartitionGraphs), "GraphDef", "tensorflow11.GraphDef", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringConfig(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GPUOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerProcessGpuMemoryFraction", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.PerProcessGpuMemoryFraction = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocatorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeferredDeletionBytes", wireType)
			}
			m.DeferredDeletionBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeferredDeletionBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowGrowth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowGrowth = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleDeviceList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VisibleDeviceList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollingActiveDelayUsecs", wireType)
			}
			m.PollingActiveDelayUsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollingActiveDelayUsecs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollingInactiveDelayMsecs", wireType)
			}
			m.PollingInactiveDelayMsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PollingInactiveDelayMsecs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceGpuCompatible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceGpuCompatible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptimizerOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptimizerOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptimizerOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoCommonSubexpressionElimination", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoCommonSubexpressionElimination = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoConstantFolding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoConstantFolding = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptLevel", wireType)
			}
			m.OptLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptLevel |= (OptimizerOptions_Level(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoFunctionInlining", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DoFunctionInlining = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalJitLevel", wireType)
			}
			m.GlobalJitLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalJitLevel |= (OptimizerOptions_GlobalJitLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableRecvScheduling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableRecvScheduling = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizerOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimizerOptions == nil {
				m.OptimizerOptions = &OptimizerOptions{}
			}
			if err := m.OptimizerOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildCostModel", wireType)
			}
			m.BuildCostModel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildCostModel |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferShapes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InferShapes = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacePrunedGraph", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlacePrunedGraph = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableBfloat16Sendrecv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableBfloat16Sendrecv = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelineStep", wireType)
			}
			m.TimelineStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimelineStep |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildCostModelAfter", wireType)
			}
			m.BuildCostModelAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildCostModelAfter |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewriteOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewriteOptions == nil {
				m.RewriteOptions = &tensorflow17.RewriterConfig{}
			}
			if err := m.RewriteOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreadPoolOptionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreadPoolOptionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreadPoolOptionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumThreads", wireType)
			}
			m.NumThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPCOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPCOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPCOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRpcForInprocessMaster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseRpcForInprocessMaster = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceCount == nil {
				m.DeviceCount = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DeviceCount[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntraOpParallelismThreads", wireType)
			}
			m.IntraOpParallelismThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntraOpParallelismThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementPeriod", wireType)
			}
			m.PlacementPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlacementPeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceFilters = append(m.DeviceFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterOpParallelismThreads", wireType)
			}
			m.InterOpParallelismThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterOpParallelismThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GpuOptions == nil {
				m.GpuOptions = &GPUOptions{}
			}
			if err := m.GpuOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowSoftPlacement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowSoftPlacement = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogDevicePlacement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogDevicePlacement = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePerSessionThreads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePerSessionThreads = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GraphOptions == nil {
				m.GraphOptions = &GraphOptions{}
			}
			if err := m.GraphOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationTimeoutInMs", wireType)
			}
			m.OperationTimeoutInMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationTimeoutInMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionInterOpThreadPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionInterOpThreadPool = append(m.SessionInterOpThreadPool, &ThreadPoolOptionProto{})
			if err := m.SessionInterOpThreadPool[len(m.SessionInterOpThreadPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcOptions == nil {
				m.RpcOptions = &RPCOptions{}
			}
			if err := m.RpcOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterDef == nil {
				m.ClusterDef = &tensorflow16.ClusterDef{}
			}
			if err := m.ClusterDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLevel", wireType)
			}
			m.TraceLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLevel |= (RunOptions_TraceLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutInMs", wireType)
			}
			m.TimeoutInMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutInMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterOpThreadPool", wireType)
			}
			m.InterOpThreadPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InterOpThreadPool |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputPartitionGraphs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputPartitionGraphs = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DebugOptions == nil {
				m.DebugOptions = &tensorflow15.DebugOptions{}
			}
			if err := m.DebugOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StepStats == nil {
				m.StepStats = &tensorflow14.StepStats{}
			}
			if err := m.StepStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CostGraph == nil {
				m.CostGraph = &tensorflow3.CostGraphDef{}
			}
			if err := m.CostGraph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionGraphs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionGraphs = append(m.PartitionGraphs, &tensorflow11.GraphDef{})
			if err := m.PartitionGraphs[len(m.PartitionGraphs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthConfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConfig(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConfig   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/core/protobuf/config.proto", fileDescriptorConfig)
}

var fileDescriptorConfig = []byte{
	// 1636 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x57, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x37, 0x25, 0x2b, 0x91, 0x9f, 0x1c, 0x45, 0x99, 0x75, 0x62, 0xd6, 0x0d, 0xb4, 0x5a, 0x6d,
	0x53, 0xb8, 0x7f, 0x60, 0x27, 0xde, 0xdd, 0x64, 0xd1, 0xa2, 0x1b, 0xd8, 0xb2, 0xe5, 0x3a, 0xb5,
	0x63, 0x61, 0x64, 0xa3, 0xd8, 0xd3, 0x80, 0x22, 0x87, 0x32, 0x1b, 0x92, 0x33, 0x98, 0x19, 0xda,
	0x75, 0x4f, 0xfd, 0x02, 0x05, 0xf6, 0x63, 0xf4, 0x03, 0xf4, 0xda, 0x4b, 0x4f, 0x3d, 0xee, 0xb1,
	0xc7, 0xc6, 0xbd, 0xf4, 0xb8, 0xa7, 0xa2, 0xb7, 0x16, 0xf3, 0x87, 0x12, 0x6d, 0x27, 0x59, 0x9d,
	0x86, 0xef, 0xf7, 0x7b, 0xc3, 0xf7, 0xff, 0x89, 0xb0, 0xc1, 0x05, 0x53, 0x6c, 0x52, 0xc4, 0x9b,
	0x8a, 0xe6, 0x92, 0x89, 0x38, 0x65, 0x17, 0x9b, 0x21, 0x13, 0x74, 0x73, 0x06, 0x84, 0x2c, 0x8f,
	0x93, 0xa9, 0x25, 0x22, 0x98, 0xd3, 0xd6, 0x7e, 0x7a, 0x53, 0x25, 0x16, 0x41, 0x46, 0x2f, 0x98,
	0x78, 0xb3, 0x19, 0x32, 0xa9, 0xc8, 0x54, 0x04, 0xfc, 0xcc, 0xea, 0xad, 0x3d, 0x79, 0x3f, 0xb7,
	0x4a, 0xfb, 0xc0, 0x95, 0x52, 0x51, 0x4e, 0xa4, 0x0a, 0x94, 0x74, 0xdc, 0x1f, 0xbd, 0xd7, 0xe2,
	0x88, 0x4e, 0x0a, 0x67, 0xf0, 0xda, 0x8f, 0xdf, 0xef, 0x57, 0x5a, 0x48, 0x45, 0x85, 0xe3, 0x6d,
	0xbc, 0x97, 0x27, 0xe8, 0x85, 0x48, 0x14, 0x15, 0xa4, 0x1a, 0x88, 0xfe, 0x5f, 0xea, 0x00, 0xfb,
	0xa3, 0xd3, 0x63, 0xae, 0x12, 0x96, 0x4b, 0xb4, 0x0b, 0x1f, 0x73, 0x2a, 0x08, 0x17, 0x2c, 0xa4,
	0x52, 0x92, 0x29, 0x2f, 0x48, 0x46, 0x33, 0x26, 0x2e, 0x49, 0x2c, 0x82, 0x50, 0x73, 0x7c, 0xaf,
	0xe7, 0xad, 0x7b, 0xf8, 0x87, 0x9c, 0x8a, 0x91, 0x65, 0xed, 0xf3, 0xe2, 0xc8, 0x70, 0x86, 0x8e,
	0x82, 0x9e, 0x40, 0x3b, 0x48, 0x53, 0x16, 0x06, 0x8a, 0x09, 0xa2, 0x2e, 0x39, 0xf5, 0x6b, 0x3d,
	0x6f, 0x7d, 0x09, 0xdf, 0x9b, 0x49, 0x4f, 0x2e, 0x39, 0x45, 0xcf, 0x61, 0x35, 0xa2, 0x31, 0x15,
	0x82, 0x46, 0x24, 0xa2, 0x29, 0xd5, 0xba, 0x64, 0x72, 0xa9, 0xa8, 0xf4, 0xeb, 0x3d, 0x6f, 0xbd,
	0x8e, 0x1f, 0x96, 0xf0, 0xae, 0x43, 0x77, 0x34, 0x88, 0x3e, 0x81, 0x65, 0x7d, 0xd1, 0x05, 0x99,
	0x0a, 0x76, 0xa1, 0xce, 0xfc, 0xc5, 0x9e, 0xb7, 0xde, 0xc4, 0x2d, 0x23, 0xdb, 0x37, 0x22, 0xb4,
	0x01, 0x1f, 0x9d, 0x27, 0x32, 0x99, 0xa4, 0x94, 0x44, 0xf4, 0x3c, 0x09, 0x29, 0x49, 0x13, 0xa9,
	0xfc, 0x86, 0x31, 0xe3, 0x81, 0x83, 0x76, 0x0d, 0x72, 0x98, 0x48, 0x85, 0x7e, 0x09, 0x6b, 0x9c,
	0xa5, 0x69, 0x92, 0x4f, 0x89, 0xf6, 0xe1, 0x5c, 0xab, 0xa5, 0xc1, 0x25, 0x29, 0x24, 0x0d, 0xa5,
	0x7f, 0xa7, 0xe7, 0xad, 0x37, 0xf0, 0xaa, 0x63, 0x6c, 0x1b, 0xc2, 0xae, 0xc6, 0x4f, 0x35, 0x8c,
	0x5e, 0xc2, 0xe3, 0x52, 0x39, 0xc9, 0xaf, 0xa9, 0x67, 0x46, 0xfd, 0xae, 0x51, 0xff, 0x81, 0xe3,
	0x1c, 0x38, 0x8a, 0xb9, 0xe0, 0xc8, 0x5c, 0xf0, 0x14, 0x56, 0x62, 0x26, 0x42, 0x6a, 0xe2, 0x1d,
	0xb2, 0x8c, 0x07, 0x4a, 0xdb, 0xe7, 0x37, 0x8d, 0x63, 0xc8, 0x60, 0xfb, 0xbc, 0x18, 0xcc, 0x90,
	0xfe, 0xdf, 0xea, 0xd0, 0xd1, 0x39, 0xcb, 0x92, 0x3f, 0x50, 0x51, 0x26, 0xef, 0x08, 0x3e, 0x8d,
	0x98, 0xd6, 0xcf, 0x58, 0x4e, 0x64, 0x31, 0xa1, 0xbf, 0xe7, 0x82, 0x4a, 0xa9, 0xa3, 0x4a, 0xd3,
	0x24, 0x4b, 0xf2, 0x60, 0x96, 0xc0, 0x26, 0xee, 0x45, 0x6c, 0x60, 0x98, 0xe3, 0x2a, 0x71, 0x6f,
	0xce, 0xd3, 0x31, 0x34, 0xd7, 0xe5, 0x52, 0x05, 0xb9, 0x22, 0x31, 0x4b, 0xa3, 0x24, 0x9f, 0x9a,
	0x54, 0x36, 0xf1, 0x03, 0xad, 0x6e, 0x91, 0xa1, 0x05, 0xd0, 0x4b, 0x58, 0x62, 0x5c, 0x91, 0x94,
	0x9e, 0xd3, 0xd4, 0x24, 0xb0, 0xbd, 0xd5, 0xaf, 0x94, 0xe3, 0xc6, 0x4d, 0x7b, 0x37, 0x0e, 0x35,
	0x13, 0x37, 0x19, 0x57, 0xe6, 0xa4, 0xc3, 0x10, 0x31, 0x12, 0x17, 0xb9, 0xa9, 0x22, 0x92, 0xe4,
	0x69, 0x92, 0xeb, 0x37, 0xda, 0xfc, 0xa2, 0x88, 0x0d, 0x1d, 0x74, 0xe0, 0x10, 0x74, 0x0a, 0x9d,
	0x69, 0xca, 0x26, 0x41, 0x4a, 0x7e, 0x97, 0x94, 0x6f, 0x6e, 0x98, 0x37, 0xff, 0xec, 0x83, 0x6f,
	0xde, 0x37, 0x4a, 0xaf, 0x12, 0xfb, 0x62, 0xdc, 0x9e, 0x5e, 0x7b, 0xee, 0xf7, 0xa0, 0x61, 0x2d,
	0xba, 0x03, 0xb5, 0xc3, 0x67, 0x9d, 0x05, 0x74, 0x1f, 0x6a, 0x87, 0x4f, 0x3b, 0xff, 0x2b, 0x7f,
	0x5e, 0x7f, 0x00, 0xed, 0xeb, 0x77, 0xa0, 0x16, 0xdc, 0xdd, 0xdd, 0x1b, 0x6e, 0x9f, 0x1e, 0x9e,
	0x74, 0x16, 0x50, 0x07, 0xea, 0xc7, 0xc3, 0x61, 0x45, 0x01, 0x35, 0x61, 0xf1, 0xf8, 0x35, 0x79,
	0xd6, 0x29, 0x4f, 0x5b, 0x9d, 0x5a, 0xff, 0x9b, 0x45, 0x58, 0xde, 0xd7, 0x53, 0xa3, 0x4c, 0xe0,
	0xe7, 0xf0, 0x88, 0xe6, 0x81, 0x2e, 0x5a, 0x41, 0xc3, 0x73, 0x22, 0xc3, 0x33, 0x1a, 0x15, 0xe9,
	0x3c, 0xe8, 0x2b, 0x16, 0xc5, 0x34, 0x3c, 0x1f, 0xcf, 0x30, 0x74, 0x00, 0x0f, 0x58, 0xe9, 0x20,
	0x61, 0xf6, 0x2a, 0x13, 0xff, 0xd6, 0xd6, 0xe3, 0x0f, 0x45, 0x01, 0x77, 0xd8, 0xcd, 0x0a, 0x5a,
	0x87, 0xce, 0xa4, 0x48, 0xd2, 0x88, 0x98, 0xc1, 0x97, 0xb1, 0x88, 0xa6, 0x26, 0xfa, 0x75, 0xdc,
	0x36, 0xf2, 0x01, 0x93, 0xea, 0x48, 0x4b, 0x75, 0x0f, 0x26, 0x79, 0x4c, 0x05, 0x91, 0x67, 0x01,
	0xa7, 0xd2, 0x44, 0xbd, 0x89, 0x5b, 0x46, 0x36, 0x36, 0x22, 0xf4, 0x73, 0x40, 0x3c, 0x0d, 0x42,
	0x4a, 0xb8, 0x28, 0x72, 0x1a, 0xd9, 0x39, 0x6a, 0x7a, 0xa9, 0x89, 0x3b, 0x06, 0x19, 0x19, 0xc0,
	0x84, 0x00, 0x7d, 0x09, 0xbe, 0xf3, 0x7d, 0x12, 0xa7, 0x2c, 0x50, 0xcf, 0x9e, 0x13, 0x49, 0xf3,
	0x48, 0x07, 0xc2, 0x34, 0x50, 0x13, 0xbb, 0xd8, 0xec, 0x38, 0x78, 0xec, 0x50, 0xf4, 0x29, 0xdc,
	0x53, 0x49, 0x46, 0xd3, 0x24, 0xa7, 0x44, 0x4f, 0x57, 0xd3, 0x36, 0x0d, 0xbc, 0x5c, 0x0a, 0xc7,
	0x8a, 0x72, 0xf4, 0x19, 0x3c, 0xba, 0xe9, 0x19, 0x09, 0x62, 0x45, 0x85, 0xbf, 0x64, 0xfc, 0xfb,
	0xe8, 0xba, 0x7f, 0xdb, 0x1a, 0x42, 0x03, 0xb8, 0xef, 0xa6, 0xe6, 0x2c, 0xae, 0x60, 0xe2, 0x5a,
	0x1d, 0xb3, 0x1b, 0xd8, 0x0d, 0xd6, 0x81, 0x99, 0xab, 0xb8, 0xed, 0x54, 0x5c, 0x4c, 0x5f, 0x2d,
	0x36, 0xbd, 0x4e, 0x0d, 0x3f, 0x91, 0x6f, 0x12, 0xfe, 0xbd, 0xbd, 0xd9, 0xff, 0x1a, 0x1e, 0x9e,
	0x9c, 0x09, 0x1a, 0x44, 0x23, 0xc6, 0x52, 0x7b, 0xc3, 0xc8, 0x2c, 0xac, 0x8f, 0xa1, 0x95, 0x17,
	0x19, 0x51, 0x06, 0x94, 0xa6, 0x87, 0x1b, 0x18, 0xf2, 0x22, 0xb3, 0x74, 0xa9, 0x09, 0xae, 0x15,
	0xf2, 0x20, 0x2b, 0x07, 0x2e, 0x58, 0xd1, 0xeb, 0x20, 0xa3, 0xfd, 0x43, 0x00, 0x3c, 0x1a, 0x94,
	0x99, 0xfe, 0x0a, 0x1e, 0x17, 0x92, 0x12, 0xc1, 0x43, 0x12, 0x33, 0x41, 0x92, 0xbc, 0x1c, 0xf9,
	0x59, 0xa0, 0xb7, 0x89, 0x1b, 0x12, 0x7e, 0x21, 0x29, 0xe6, 0xe1, 0x90, 0x89, 0x83, 0x92, 0x70,
	0x64, 0xf0, 0xfe, 0x9f, 0xee, 0x42, 0xcb, 0x3a, 0x6c, 0xed, 0xfb, 0x0d, 0x2c, 0xbb, 0x41, 0x1b,
	0xb2, 0x22, 0x57, 0xbe, 0xd7, 0xab, 0xaf, 0xb7, 0xb6, 0xd6, 0xab, 0x71, 0xaa, 0xd0, 0x37, 0xec,
	0xe8, 0x1d, 0x68, 0xea, 0x5e, 0xae, 0xc4, 0x25, 0x6e, 0x45, 0x73, 0x89, 0x1e, 0xa8, 0x49, 0xae,
	0x44, 0x40, 0x18, 0x27, 0x3c, 0x10, 0x41, 0x9a, 0xd2, 0x34, 0x91, 0x73, 0xef, 0x6b, 0x76, 0xa0,
	0x1a, 0xce, 0x31, 0x1f, 0xcd, 0x19, 0x65, 0x30, 0x7e, 0x02, 0xb6, 0xc0, 0x32, 0x9a, 0x2b, 0xc2,
	0xa9, 0x48, 0x58, 0x64, 0x3a, 0xa2, 0x81, 0xef, 0xcf, 0xe4, 0x23, 0x23, 0xd6, 0xbb, 0xca, 0x19,
	0x1e, 0x27, 0xa9, 0xa2, 0x42, 0xfa, 0x8b, 0xbd, 0xba, 0xde, 0x55, 0x56, 0x3a, 0xb4, 0x42, 0x67,
	0x92, 0x69, 0xb0, 0x77, 0x9a, 0xd4, 0x98, 0x99, 0xa4, 0xbb, 0xe9, 0x1d, 0x26, 0xbd, 0x80, 0x96,
	0x9e, 0xee, 0x65, 0x1d, 0xdd, 0x31, 0x75, 0xf4, 0xa8, 0x1a, 0x9f, 0xf9, 0x1a, 0xc6, 0x30, 0xe5,
	0x45, 0x99, 0xa9, 0xa7, 0xb0, 0x62, 0xb7, 0x9d, 0x64, 0xb1, 0x22, 0x33, 0xf3, 0x5d, 0x53, 0x20,
	0x83, 0x8d, 0x59, 0xac, 0x46, 0x25, 0xa2, 0x35, 0x52, 0x36, 0x2d, 0x17, 0xdf, 0x5c, 0xc3, 0xad,
	0x93, 0x94, 0x4d, 0x6d, 0xf8, 0xe7, 0x1a, 0x5f, 0xc0, 0xaa, 0xae, 0x06, 0xbd, 0xfa, 0xa5, 0xab,
	0xca, 0xd2, 0xb1, 0x25, 0x3b, 0x79, 0x0a, 0x49, 0x47, 0x54, 0x8c, 0x2d, 0x58, 0xfa, 0xf4, 0x2b,
	0xb8, 0x67, 0x9a, 0xfa, 0x46, 0x77, 0xf8, 0xd7, 0xbc, 0xaa, 0x0c, 0x38, 0xbc, 0x3c, 0xad, 0x8e,
	0xbb, 0x2f, 0x60, 0x95, 0x71, 0x2a, 0x4c, 0xe5, 0x13, 0xdd, 0xad, 0xac, 0x50, 0x24, 0xc9, 0x49,
	0x26, 0xfd, 0x96, 0x69, 0xca, 0x95, 0x19, 0x7c, 0x62, 0xd1, 0x83, 0xfc, 0x48, 0xa2, 0x00, 0x1e,
	0x97, 0x46, 0xce, 0x52, 0x62, 0xad, 0x25, 0x9c, 0xb1, 0xd4, 0x5f, 0x36, 0xa5, 0xf7, 0x49, 0xd5,
	0x88, 0x77, 0xf6, 0x14, 0xf6, 0xdd, 0x35, 0x07, 0x36, 0x69, 0x73, 0x92, 0x4e, 0x96, 0xee, 0x8c,
	0xd2, 0xad, 0x7b, 0xb7, 0x93, 0x35, 0x6f, 0x25, 0x0c, 0x82, 0x87, 0xa5, 0x4b, 0x2f, 0xa0, 0xe5,
	0xfe, 0x8f, 0x91, 0x88, 0xc6, 0x7e, 0xfb, 0xb6, 0xe2, 0xc0, 0xc2, 0xbb, 0x34, 0xc6, 0x10, 0xce,
	0xce, 0x6b, 0x5f, 0x41, 0xe7, 0x66, 0x4f, 0xe8, 0x2d, 0xf2, 0x86, 0x5e, 0x9a, 0x56, 0x5c, 0xc2,
	0xfa, 0x88, 0x56, 0xa0, 0x71, 0x1e, 0xa4, 0x05, 0x75, 0x1d, 0x60, 0x1f, 0x7e, 0x51, 0xfb, 0xd2,
	0xeb, 0xff, 0xa7, 0x06, 0x80, 0x8b, 0xbc, 0xb4, 0x63, 0x07, 0x5a, 0x4a, 0xe8, 0xd9, 0x6b, 0x77,
	0xa2, 0x67, 0x76, 0xe2, 0xb5, 0x90, 0xcc, 0xc9, 0x1b, 0x27, 0x9a, 0x69, 0x37, 0x21, 0xa8, 0xd9,
	0x19, 0xf5, 0xed, 0x5c, 0x9d, 0x27, 0xa5, 0x66, 0x92, 0xd2, 0x52, 0x95, 0x5c, 0x6c, 0xc2, 0xca,
	0x3b, 0x73, 0x60, 0x9b, 0xed, 0x41, 0x72, 0x2b, 0xb2, 0xcf, 0x61, 0x95, 0x15, 0x8a, 0x17, 0x4a,
	0x77, 0x91, 0x4a, 0x4c, 0xea, 0x4d, 0x51, 0x94, 0x2b, 0xe4, 0xa1, 0x85, 0x47, 0x25, 0x6a, 0xea,
	0xc7, 0x94, 0x9a, 0xf9, 0x3b, 0x7c, 0xa3, 0x81, 0xae, 0x95, 0xda, 0xae, 0x26, 0xcc, 0x4a, 0x2d,
	0xaa, 0x3c, 0xf5, 0x31, 0xc0, 0xdc, 0x4b, 0xb4, 0x0c, 0xcd, 0xd7, 0xc7, 0xe4, 0x04, 0x6f, 0x0f,
	0xf6, 0x3a, 0x0b, 0x08, 0x41, 0x7b, 0x7c, 0x3c, 0x3c, 0xf9, 0xed, 0x36, 0xde, 0x73, 0x32, 0x4f,
	0xcb, 0x7e, 0xbd, 0x8d, 0x77, 0x2b, 0xb2, 0x1a, 0x6a, 0x03, 0x0c, 0x4f, 0x0f, 0x0f, 0xdd, 0x73,
	0xfd, 0xd5, 0x62, 0x73, 0xb1, 0xd3, 0xe8, 0xff, 0xd5, 0x83, 0x16, 0x2e, 0xf2, 0x23, 0xaa, 0x82,
	0x28, 0x50, 0x01, 0xfa, 0x1c, 0x60, 0xfe, 0x17, 0xdf, 0x04, 0xbe, 0xb5, 0xf5, 0xb0, 0x6a, 0xa5,
	0x5e, 0x47, 0x63, 0x0d, 0xe2, 0x25, 0x59, 0x1e, 0xd1, 0x0b, 0x80, 0xf9, 0xb7, 0x86, 0x09, 0xf4,
	0x0d, 0xdf, 0xf4, 0x66, 0x32, 0xa1, 0xd0, 0x85, 0xb3, 0x14, 0x96, 0x4f, 0xe8, 0x25, 0x74, 0x6e,
	0x05, 0xb2, 0x6e, 0x1a, 0x60, 0xe5, 0x56, 0x17, 0x6a, 0xd5, 0xfb, 0xfc, 0x7a, 0x60, 0x77, 0xbe,
	0xfe, 0xf6, 0x6d, 0x77, 0xe1, 0x1f, 0x6f, 0xbb, 0x0b, 0xdf, 0xbd, 0xed, 0x7a, 0x7f, 0xbc, 0xea,
	0x7a, 0x7f, 0xbe, 0xea, 0x7a, 0x7f, 0xbf, 0xea, 0x7a, 0xdf, 0x5e, 0x75, 0xbd, 0x7f, 0x5e, 0x75,
	0xbd, 0x7f, 0x5f, 0x75, 0x17, 0xbe, 0xbb, 0xea, 0x7a, 0xdf, 0xfc, 0xab, 0xbb, 0x00, 0x3e, 0x13,
	0xd3, 0xea, 0xbd, 0xb3, 0xef, 0x9a, 0x9d, 0xe5, 0xca, 0x78, 0x97, 0x23, 0xef, 0xbf, 0x9e, 0x37,
	0xb9, 0x63, 0x3e, 0x31, 0x3e, 0xfb, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0e, 0x8d, 0x9f, 0x3d,
	0x9d, 0x0d, 0x00, 0x00,
}
