// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/core/profiler/profile.proto

/*
	Package tensorflow_tfprof_pprof is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/core/profiler/profile.proto

	It has these top-level messages:
		Profile
		ValueType
		Sample
		Label
		Mapping
		Location
		Line
		Function
*/
package tensorflow_tfprof_pprof

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import fmt "fmt"
import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Profile struct {
	SampleType        []*ValueType `protobuf:"bytes,1,rep,name=sample_type,json=sampleType" json:"sample_type,omitempty"`
	Sample            []*Sample    `protobuf:"bytes,2,rep,name=sample" json:"sample,omitempty"`
	Mapping           []*Mapping   `protobuf:"bytes,3,rep,name=mapping" json:"mapping,omitempty"`
	Location          []*Location  `protobuf:"bytes,4,rep,name=location" json:"location,omitempty"`
	Function          []*Function  `protobuf:"bytes,5,rep,name=function" json:"function,omitempty"`
	StringTable       []string     `protobuf:"bytes,6,rep,name=string_table,json=stringTable" json:"string_table,omitempty"`
	DropFrames        int64        `protobuf:"varint,7,opt,name=drop_frames,json=dropFrames,proto3" json:"drop_frames,omitempty"`
	KeepFrames        int64        `protobuf:"varint,8,opt,name=keep_frames,json=keepFrames,proto3" json:"keep_frames,omitempty"`
	TimeNanos         int64        `protobuf:"varint,9,opt,name=time_nanos,json=timeNanos,proto3" json:"time_nanos,omitempty"`
	DurationNanos     int64        `protobuf:"varint,10,opt,name=duration_nanos,json=durationNanos,proto3" json:"duration_nanos,omitempty"`
	PeriodType        *ValueType   `protobuf:"bytes,11,opt,name=period_type,json=periodType" json:"period_type,omitempty"`
	Period            int64        `protobuf:"varint,12,opt,name=period,proto3" json:"period,omitempty"`
	Comment           []int64      `protobuf:"varint,13,rep,packed,name=comment" json:"comment,omitempty"`
	DefaultSampleType int64        `protobuf:"varint,14,opt,name=default_sample_type,json=defaultSampleType,proto3" json:"default_sample_type,omitempty"`
}

func (m *Profile) Reset()                    { *m = Profile{} }
func (*Profile) ProtoMessage()               {}
func (*Profile) Descriptor() ([]byte, []int) { return fileDescriptorProfile, []int{0} }

func (m *Profile) GetSampleType() []*ValueType {
	if m != nil {
		return m.SampleType
	}
	return nil
}

func (m *Profile) GetSample() []*Sample {
	if m != nil {
		return m.Sample
	}
	return nil
}

func (m *Profile) GetMapping() []*Mapping {
	if m != nil {
		return m.Mapping
	}
	return nil
}

func (m *Profile) GetLocation() []*Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Profile) GetFunction() []*Function {
	if m != nil {
		return m.Function
	}
	return nil
}

func (m *Profile) GetStringTable() []string {
	if m != nil {
		return m.StringTable
	}
	return nil
}

func (m *Profile) GetDropFrames() int64 {
	if m != nil {
		return m.DropFrames
	}
	return 0
}

func (m *Profile) GetKeepFrames() int64 {
	if m != nil {
		return m.KeepFrames
	}
	return 0
}

func (m *Profile) GetTimeNanos() int64 {
	if m != nil {
		return m.TimeNanos
	}
	return 0
}

func (m *Profile) GetDurationNanos() int64 {
	if m != nil {
		return m.DurationNanos
	}
	return 0
}

func (m *Profile) GetPeriodType() *ValueType {
	if m != nil {
		return m.PeriodType
	}
	return nil
}

func (m *Profile) GetPeriod() int64 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *Profile) GetComment() []int64 {
	if m != nil {
		return m.Comment
	}
	return nil
}

func (m *Profile) GetDefaultSampleType() int64 {
	if m != nil {
		return m.DefaultSampleType
	}
	return 0
}

type ValueType struct {
	Type int64 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Unit int64 `protobuf:"varint,2,opt,name=unit,proto3" json:"unit,omitempty"`
}

func (m *ValueType) Reset()                    { *m = ValueType{} }
func (*ValueType) ProtoMessage()               {}
func (*ValueType) Descriptor() ([]byte, []int) { return fileDescriptorProfile, []int{1} }

func (m *ValueType) GetType() int64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ValueType) GetUnit() int64 {
	if m != nil {
		return m.Unit
	}
	return 0
}

type Sample struct {
	LocationId []uint64 `protobuf:"varint,1,rep,packed,name=location_id,json=locationId" json:"location_id,omitempty"`
	Value      []int64  `protobuf:"varint,2,rep,packed,name=value" json:"value,omitempty"`
	Label      []*Label `protobuf:"bytes,3,rep,name=label" json:"label,omitempty"`
}

func (m *Sample) Reset()                    { *m = Sample{} }
func (*Sample) ProtoMessage()               {}
func (*Sample) Descriptor() ([]byte, []int) { return fileDescriptorProfile, []int{2} }

func (m *Sample) GetLocationId() []uint64 {
	if m != nil {
		return m.LocationId
	}
	return nil
}

func (m *Sample) GetValue() []int64 {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Sample) GetLabel() []*Label {
	if m != nil {
		return m.Label
	}
	return nil
}

type Label struct {
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Str int64 `protobuf:"varint,2,opt,name=str,proto3" json:"str,omitempty"`
	Num int64 `protobuf:"varint,3,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *Label) Reset()                    { *m = Label{} }
func (*Label) ProtoMessage()               {}
func (*Label) Descriptor() ([]byte, []int) { return fileDescriptorProfile, []int{3} }

func (m *Label) GetKey() int64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Label) GetStr() int64 {
	if m != nil {
		return m.Str
	}
	return 0
}

func (m *Label) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

type Mapping struct {
	Id              uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MemoryStart     uint64 `protobuf:"varint,2,opt,name=memory_start,json=memoryStart,proto3" json:"memory_start,omitempty"`
	MemoryLimit     uint64 `protobuf:"varint,3,opt,name=memory_limit,json=memoryLimit,proto3" json:"memory_limit,omitempty"`
	FileOffset      uint64 `protobuf:"varint,4,opt,name=file_offset,json=fileOffset,proto3" json:"file_offset,omitempty"`
	Filename        int64  `protobuf:"varint,5,opt,name=filename,proto3" json:"filename,omitempty"`
	BuildId         int64  `protobuf:"varint,6,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	HasFunctions    bool   `protobuf:"varint,7,opt,name=has_functions,json=hasFunctions,proto3" json:"has_functions,omitempty"`
	HasFilenames    bool   `protobuf:"varint,8,opt,name=has_filenames,json=hasFilenames,proto3" json:"has_filenames,omitempty"`
	HasLineNumbers  bool   `protobuf:"varint,9,opt,name=has_line_numbers,json=hasLineNumbers,proto3" json:"has_line_numbers,omitempty"`
	HasInlineFrames bool   `protobuf:"varint,10,opt,name=has_inline_frames,json=hasInlineFrames,proto3" json:"has_inline_frames,omitempty"`
}

func (m *Mapping) Reset()                    { *m = Mapping{} }
func (*Mapping) ProtoMessage()               {}
func (*Mapping) Descriptor() ([]byte, []int) { return fileDescriptorProfile, []int{4} }

func (m *Mapping) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Mapping) GetMemoryStart() uint64 {
	if m != nil {
		return m.MemoryStart
	}
	return 0
}

func (m *Mapping) GetMemoryLimit() uint64 {
	if m != nil {
		return m.MemoryLimit
	}
	return 0
}

func (m *Mapping) GetFileOffset() uint64 {
	if m != nil {
		return m.FileOffset
	}
	return 0
}

func (m *Mapping) GetFilename() int64 {
	if m != nil {
		return m.Filename
	}
	return 0
}

func (m *Mapping) GetBuildId() int64 {
	if m != nil {
		return m.BuildId
	}
	return 0
}

func (m *Mapping) GetHasFunctions() bool {
	if m != nil {
		return m.HasFunctions
	}
	return false
}

func (m *Mapping) GetHasFilenames() bool {
	if m != nil {
		return m.HasFilenames
	}
	return false
}

func (m *Mapping) GetHasLineNumbers() bool {
	if m != nil {
		return m.HasLineNumbers
	}
	return false
}

func (m *Mapping) GetHasInlineFrames() bool {
	if m != nil {
		return m.HasInlineFrames
	}
	return false
}

type Location struct {
	Id        uint64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MappingId uint64  `protobuf:"varint,2,opt,name=mapping_id,json=mappingId,proto3" json:"mapping_id,omitempty"`
	Address   uint64  `protobuf:"varint,3,opt,name=address,proto3" json:"address,omitempty"`
	Line      []*Line `protobuf:"bytes,4,rep,name=line" json:"line,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorProfile, []int{5} }

func (m *Location) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Location) GetMappingId() uint64 {
	if m != nil {
		return m.MappingId
	}
	return 0
}

func (m *Location) GetAddress() uint64 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *Location) GetLine() []*Line {
	if m != nil {
		return m.Line
	}
	return nil
}

type Line struct {
	FunctionId uint64 `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3" json:"function_id,omitempty"`
	Line       int64  `protobuf:"varint,2,opt,name=line,proto3" json:"line,omitempty"`
}

func (m *Line) Reset()                    { *m = Line{} }
func (*Line) ProtoMessage()               {}
func (*Line) Descriptor() ([]byte, []int) { return fileDescriptorProfile, []int{6} }

func (m *Line) GetFunctionId() uint64 {
	if m != nil {
		return m.FunctionId
	}
	return 0
}

func (m *Line) GetLine() int64 {
	if m != nil {
		return m.Line
	}
	return 0
}

type Function struct {
	Id         uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name       int64  `protobuf:"varint,2,opt,name=name,proto3" json:"name,omitempty"`
	SystemName int64  `protobuf:"varint,3,opt,name=system_name,json=systemName,proto3" json:"system_name,omitempty"`
	Filename   int64  `protobuf:"varint,4,opt,name=filename,proto3" json:"filename,omitempty"`
	StartLine  int64  `protobuf:"varint,5,opt,name=start_line,json=startLine,proto3" json:"start_line,omitempty"`
}

func (m *Function) Reset()                    { *m = Function{} }
func (*Function) ProtoMessage()               {}
func (*Function) Descriptor() ([]byte, []int) { return fileDescriptorProfile, []int{7} }

func (m *Function) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Function) GetName() int64 {
	if m != nil {
		return m.Name
	}
	return 0
}

func (m *Function) GetSystemName() int64 {
	if m != nil {
		return m.SystemName
	}
	return 0
}

func (m *Function) GetFilename() int64 {
	if m != nil {
		return m.Filename
	}
	return 0
}

func (m *Function) GetStartLine() int64 {
	if m != nil {
		return m.StartLine
	}
	return 0
}

func init() {
	proto.RegisterType((*Profile)(nil), "tensorflow.tfprof.pprof.Profile")
	proto.RegisterType((*ValueType)(nil), "tensorflow.tfprof.pprof.ValueType")
	proto.RegisterType((*Sample)(nil), "tensorflow.tfprof.pprof.Sample")
	proto.RegisterType((*Label)(nil), "tensorflow.tfprof.pprof.Label")
	proto.RegisterType((*Mapping)(nil), "tensorflow.tfprof.pprof.Mapping")
	proto.RegisterType((*Location)(nil), "tensorflow.tfprof.pprof.Location")
	proto.RegisterType((*Line)(nil), "tensorflow.tfprof.pprof.Line")
	proto.RegisterType((*Function)(nil), "tensorflow.tfprof.pprof.Function")
}
func (this *Profile) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Profile)
	if !ok {
		that2, ok := that.(Profile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.SampleType) != len(that1.SampleType) {
		return false
	}
	for i := range this.SampleType {
		if !this.SampleType[i].Equal(that1.SampleType[i]) {
			return false
		}
	}
	if len(this.Sample) != len(that1.Sample) {
		return false
	}
	for i := range this.Sample {
		if !this.Sample[i].Equal(that1.Sample[i]) {
			return false
		}
	}
	if len(this.Mapping) != len(that1.Mapping) {
		return false
	}
	for i := range this.Mapping {
		if !this.Mapping[i].Equal(that1.Mapping[i]) {
			return false
		}
	}
	if len(this.Location) != len(that1.Location) {
		return false
	}
	for i := range this.Location {
		if !this.Location[i].Equal(that1.Location[i]) {
			return false
		}
	}
	if len(this.Function) != len(that1.Function) {
		return false
	}
	for i := range this.Function {
		if !this.Function[i].Equal(that1.Function[i]) {
			return false
		}
	}
	if len(this.StringTable) != len(that1.StringTable) {
		return false
	}
	for i := range this.StringTable {
		if this.StringTable[i] != that1.StringTable[i] {
			return false
		}
	}
	if this.DropFrames != that1.DropFrames {
		return false
	}
	if this.KeepFrames != that1.KeepFrames {
		return false
	}
	if this.TimeNanos != that1.TimeNanos {
		return false
	}
	if this.DurationNanos != that1.DurationNanos {
		return false
	}
	if !this.PeriodType.Equal(that1.PeriodType) {
		return false
	}
	if this.Period != that1.Period {
		return false
	}
	if len(this.Comment) != len(that1.Comment) {
		return false
	}
	for i := range this.Comment {
		if this.Comment[i] != that1.Comment[i] {
			return false
		}
	}
	if this.DefaultSampleType != that1.DefaultSampleType {
		return false
	}
	return true
}
func (this *ValueType) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ValueType)
	if !ok {
		that2, ok := that.(ValueType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	return true
}
func (this *Sample) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Sample)
	if !ok {
		that2, ok := that.(Sample)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.LocationId) != len(that1.LocationId) {
		return false
	}
	for i := range this.LocationId {
		if this.LocationId[i] != that1.LocationId[i] {
			return false
		}
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if this.Value[i] != that1.Value[i] {
			return false
		}
	}
	if len(this.Label) != len(that1.Label) {
		return false
	}
	for i := range this.Label {
		if !this.Label[i].Equal(that1.Label[i]) {
			return false
		}
	}
	return true
}
func (this *Label) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Label)
	if !ok {
		that2, ok := that.(Label)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Str != that1.Str {
		return false
	}
	if this.Num != that1.Num {
		return false
	}
	return true
}
func (this *Mapping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Mapping)
	if !ok {
		that2, ok := that.(Mapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.MemoryStart != that1.MemoryStart {
		return false
	}
	if this.MemoryLimit != that1.MemoryLimit {
		return false
	}
	if this.FileOffset != that1.FileOffset {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if this.BuildId != that1.BuildId {
		return false
	}
	if this.HasFunctions != that1.HasFunctions {
		return false
	}
	if this.HasFilenames != that1.HasFilenames {
		return false
	}
	if this.HasLineNumbers != that1.HasLineNumbers {
		return false
	}
	if this.HasInlineFrames != that1.HasInlineFrames {
		return false
	}
	return true
}
func (this *Location) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Location)
	if !ok {
		that2, ok := that.(Location)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.MappingId != that1.MappingId {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if len(this.Line) != len(that1.Line) {
		return false
	}
	for i := range this.Line {
		if !this.Line[i].Equal(that1.Line[i]) {
			return false
		}
	}
	return true
}
func (this *Line) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Line)
	if !ok {
		that2, ok := that.(Line)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FunctionId != that1.FunctionId {
		return false
	}
	if this.Line != that1.Line {
		return false
	}
	return true
}
func (this *Function) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Function)
	if !ok {
		that2, ok := that.(Function)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.SystemName != that1.SystemName {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if this.StartLine != that1.StartLine {
		return false
	}
	return true
}
func (this *Profile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&tensorflow_tfprof_pprof.Profile{")
	if this.SampleType != nil {
		s = append(s, "SampleType: "+fmt.Sprintf("%#v", this.SampleType)+",\n")
	}
	if this.Sample != nil {
		s = append(s, "Sample: "+fmt.Sprintf("%#v", this.Sample)+",\n")
	}
	if this.Mapping != nil {
		s = append(s, "Mapping: "+fmt.Sprintf("%#v", this.Mapping)+",\n")
	}
	if this.Location != nil {
		s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	}
	if this.Function != nil {
		s = append(s, "Function: "+fmt.Sprintf("%#v", this.Function)+",\n")
	}
	s = append(s, "StringTable: "+fmt.Sprintf("%#v", this.StringTable)+",\n")
	s = append(s, "DropFrames: "+fmt.Sprintf("%#v", this.DropFrames)+",\n")
	s = append(s, "KeepFrames: "+fmt.Sprintf("%#v", this.KeepFrames)+",\n")
	s = append(s, "TimeNanos: "+fmt.Sprintf("%#v", this.TimeNanos)+",\n")
	s = append(s, "DurationNanos: "+fmt.Sprintf("%#v", this.DurationNanos)+",\n")
	if this.PeriodType != nil {
		s = append(s, "PeriodType: "+fmt.Sprintf("%#v", this.PeriodType)+",\n")
	}
	s = append(s, "Period: "+fmt.Sprintf("%#v", this.Period)+",\n")
	s = append(s, "Comment: "+fmt.Sprintf("%#v", this.Comment)+",\n")
	s = append(s, "DefaultSampleType: "+fmt.Sprintf("%#v", this.DefaultSampleType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValueType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_tfprof_pprof.ValueType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sample) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_tfprof_pprof.Sample{")
	s = append(s, "LocationId: "+fmt.Sprintf("%#v", this.LocationId)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.Label != nil {
		s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Label) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_tfprof_pprof.Label{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Str: "+fmt.Sprintf("%#v", this.Str)+",\n")
	s = append(s, "Num: "+fmt.Sprintf("%#v", this.Num)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Mapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&tensorflow_tfprof_pprof.Mapping{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "MemoryStart: "+fmt.Sprintf("%#v", this.MemoryStart)+",\n")
	s = append(s, "MemoryLimit: "+fmt.Sprintf("%#v", this.MemoryLimit)+",\n")
	s = append(s, "FileOffset: "+fmt.Sprintf("%#v", this.FileOffset)+",\n")
	s = append(s, "Filename: "+fmt.Sprintf("%#v", this.Filename)+",\n")
	s = append(s, "BuildId: "+fmt.Sprintf("%#v", this.BuildId)+",\n")
	s = append(s, "HasFunctions: "+fmt.Sprintf("%#v", this.HasFunctions)+",\n")
	s = append(s, "HasFilenames: "+fmt.Sprintf("%#v", this.HasFilenames)+",\n")
	s = append(s, "HasLineNumbers: "+fmt.Sprintf("%#v", this.HasLineNumbers)+",\n")
	s = append(s, "HasInlineFrames: "+fmt.Sprintf("%#v", this.HasInlineFrames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Location) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_tfprof_pprof.Location{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "MappingId: "+fmt.Sprintf("%#v", this.MappingId)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Line != nil {
		s = append(s, "Line: "+fmt.Sprintf("%#v", this.Line)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Line) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_tfprof_pprof.Line{")
	s = append(s, "FunctionId: "+fmt.Sprintf("%#v", this.FunctionId)+",\n")
	s = append(s, "Line: "+fmt.Sprintf("%#v", this.Line)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Function) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tensorflow_tfprof_pprof.Function{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "SystemName: "+fmt.Sprintf("%#v", this.SystemName)+",\n")
	s = append(s, "Filename: "+fmt.Sprintf("%#v", this.Filename)+",\n")
	s = append(s, "StartLine: "+fmt.Sprintf("%#v", this.StartLine)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringProfile(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Profile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Profile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SampleType) > 0 {
		for _, msg := range m.SampleType {
			dAtA[i] = 0xa
			i++
			i = encodeVarintProfile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Sample) > 0 {
		for _, msg := range m.Sample {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProfile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Mapping) > 0 {
		for _, msg := range m.Mapping {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProfile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Location) > 0 {
		for _, msg := range m.Location {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProfile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Function) > 0 {
		for _, msg := range m.Function {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintProfile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StringTable) > 0 {
		for _, s := range m.StringTable {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DropFrames != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.DropFrames))
	}
	if m.KeepFrames != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.KeepFrames))
	}
	if m.TimeNanos != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.TimeNanos))
	}
	if m.DurationNanos != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.DurationNanos))
	}
	if m.PeriodType != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.PeriodType.Size()))
		n1, err := m.PeriodType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Period != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Period))
	}
	if len(m.Comment) > 0 {
		dAtA3 := make([]byte, len(m.Comment)*10)
		var j2 int
		for _, num1 := range m.Comment {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintProfile(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.DefaultSampleType != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.DefaultSampleType))
	}
	return i, nil
}

func (m *ValueType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Type))
	}
	if m.Unit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Unit))
	}
	return i, nil
}

func (m *Sample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LocationId) > 0 {
		dAtA5 := make([]byte, len(m.LocationId)*10)
		var j4 int
		for _, num := range m.LocationId {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintProfile(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.Value) > 0 {
		dAtA7 := make([]byte, len(m.Value)*10)
		var j6 int
		for _, num1 := range m.Value {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintProfile(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.Label) > 0 {
		for _, msg := range m.Label {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProfile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Key))
	}
	if m.Str != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Str))
	}
	if m.Num != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *Mapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Id))
	}
	if m.MemoryStart != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.MemoryStart))
	}
	if m.MemoryLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.MemoryLimit))
	}
	if m.FileOffset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.FileOffset))
	}
	if m.Filename != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Filename))
	}
	if m.BuildId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.BuildId))
	}
	if m.HasFunctions {
		dAtA[i] = 0x38
		i++
		if m.HasFunctions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasFilenames {
		dAtA[i] = 0x40
		i++
		if m.HasFilenames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasLineNumbers {
		dAtA[i] = 0x48
		i++
		if m.HasLineNumbers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasInlineFrames {
		dAtA[i] = 0x50
		i++
		if m.HasInlineFrames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Id))
	}
	if m.MappingId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.MappingId))
	}
	if m.Address != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Address))
	}
	if len(m.Line) > 0 {
		for _, msg := range m.Line {
			dAtA[i] = 0x22
			i++
			i = encodeVarintProfile(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Line) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Line) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FunctionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.FunctionId))
	}
	if m.Line != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Line))
	}
	return i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Id))
	}
	if m.Name != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Name))
	}
	if m.SystemName != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.SystemName))
	}
	if m.Filename != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.Filename))
	}
	if m.StartLine != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProfile(dAtA, i, uint64(m.StartLine))
	}
	return i, nil
}

func encodeFixed64Profile(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Profile(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintProfile(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Profile) Size() (n int) {
	var l int
	_ = l
	if len(m.SampleType) > 0 {
		for _, e := range m.SampleType {
			l = e.Size()
			n += 1 + l + sovProfile(uint64(l))
		}
	}
	if len(m.Sample) > 0 {
		for _, e := range m.Sample {
			l = e.Size()
			n += 1 + l + sovProfile(uint64(l))
		}
	}
	if len(m.Mapping) > 0 {
		for _, e := range m.Mapping {
			l = e.Size()
			n += 1 + l + sovProfile(uint64(l))
		}
	}
	if len(m.Location) > 0 {
		for _, e := range m.Location {
			l = e.Size()
			n += 1 + l + sovProfile(uint64(l))
		}
	}
	if len(m.Function) > 0 {
		for _, e := range m.Function {
			l = e.Size()
			n += 1 + l + sovProfile(uint64(l))
		}
	}
	if len(m.StringTable) > 0 {
		for _, s := range m.StringTable {
			l = len(s)
			n += 1 + l + sovProfile(uint64(l))
		}
	}
	if m.DropFrames != 0 {
		n += 1 + sovProfile(uint64(m.DropFrames))
	}
	if m.KeepFrames != 0 {
		n += 1 + sovProfile(uint64(m.KeepFrames))
	}
	if m.TimeNanos != 0 {
		n += 1 + sovProfile(uint64(m.TimeNanos))
	}
	if m.DurationNanos != 0 {
		n += 1 + sovProfile(uint64(m.DurationNanos))
	}
	if m.PeriodType != nil {
		l = m.PeriodType.Size()
		n += 1 + l + sovProfile(uint64(l))
	}
	if m.Period != 0 {
		n += 1 + sovProfile(uint64(m.Period))
	}
	if len(m.Comment) > 0 {
		l = 0
		for _, e := range m.Comment {
			l += sovProfile(uint64(e))
		}
		n += 1 + sovProfile(uint64(l)) + l
	}
	if m.DefaultSampleType != 0 {
		n += 1 + sovProfile(uint64(m.DefaultSampleType))
	}
	return n
}

func (m *ValueType) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovProfile(uint64(m.Type))
	}
	if m.Unit != 0 {
		n += 1 + sovProfile(uint64(m.Unit))
	}
	return n
}

func (m *Sample) Size() (n int) {
	var l int
	_ = l
	if len(m.LocationId) > 0 {
		l = 0
		for _, e := range m.LocationId {
			l += sovProfile(uint64(e))
		}
		n += 1 + sovProfile(uint64(l)) + l
	}
	if len(m.Value) > 0 {
		l = 0
		for _, e := range m.Value {
			l += sovProfile(uint64(e))
		}
		n += 1 + sovProfile(uint64(l)) + l
	}
	if len(m.Label) > 0 {
		for _, e := range m.Label {
			l = e.Size()
			n += 1 + l + sovProfile(uint64(l))
		}
	}
	return n
}

func (m *Label) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovProfile(uint64(m.Key))
	}
	if m.Str != 0 {
		n += 1 + sovProfile(uint64(m.Str))
	}
	if m.Num != 0 {
		n += 1 + sovProfile(uint64(m.Num))
	}
	return n
}

func (m *Mapping) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovProfile(uint64(m.Id))
	}
	if m.MemoryStart != 0 {
		n += 1 + sovProfile(uint64(m.MemoryStart))
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovProfile(uint64(m.MemoryLimit))
	}
	if m.FileOffset != 0 {
		n += 1 + sovProfile(uint64(m.FileOffset))
	}
	if m.Filename != 0 {
		n += 1 + sovProfile(uint64(m.Filename))
	}
	if m.BuildId != 0 {
		n += 1 + sovProfile(uint64(m.BuildId))
	}
	if m.HasFunctions {
		n += 2
	}
	if m.HasFilenames {
		n += 2
	}
	if m.HasLineNumbers {
		n += 2
	}
	if m.HasInlineFrames {
		n += 2
	}
	return n
}

func (m *Location) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovProfile(uint64(m.Id))
	}
	if m.MappingId != 0 {
		n += 1 + sovProfile(uint64(m.MappingId))
	}
	if m.Address != 0 {
		n += 1 + sovProfile(uint64(m.Address))
	}
	if len(m.Line) > 0 {
		for _, e := range m.Line {
			l = e.Size()
			n += 1 + l + sovProfile(uint64(l))
		}
	}
	return n
}

func (m *Line) Size() (n int) {
	var l int
	_ = l
	if m.FunctionId != 0 {
		n += 1 + sovProfile(uint64(m.FunctionId))
	}
	if m.Line != 0 {
		n += 1 + sovProfile(uint64(m.Line))
	}
	return n
}

func (m *Function) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovProfile(uint64(m.Id))
	}
	if m.Name != 0 {
		n += 1 + sovProfile(uint64(m.Name))
	}
	if m.SystemName != 0 {
		n += 1 + sovProfile(uint64(m.SystemName))
	}
	if m.Filename != 0 {
		n += 1 + sovProfile(uint64(m.Filename))
	}
	if m.StartLine != 0 {
		n += 1 + sovProfile(uint64(m.StartLine))
	}
	return n
}

func sovProfile(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProfile(x uint64) (n int) {
	return sovProfile(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Profile) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Profile{`,
		`SampleType:` + strings.Replace(fmt.Sprintf("%v", this.SampleType), "ValueType", "ValueType", 1) + `,`,
		`Sample:` + strings.Replace(fmt.Sprintf("%v", this.Sample), "Sample", "Sample", 1) + `,`,
		`Mapping:` + strings.Replace(fmt.Sprintf("%v", this.Mapping), "Mapping", "Mapping", 1) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "Location", "Location", 1) + `,`,
		`Function:` + strings.Replace(fmt.Sprintf("%v", this.Function), "Function", "Function", 1) + `,`,
		`StringTable:` + fmt.Sprintf("%v", this.StringTable) + `,`,
		`DropFrames:` + fmt.Sprintf("%v", this.DropFrames) + `,`,
		`KeepFrames:` + fmt.Sprintf("%v", this.KeepFrames) + `,`,
		`TimeNanos:` + fmt.Sprintf("%v", this.TimeNanos) + `,`,
		`DurationNanos:` + fmt.Sprintf("%v", this.DurationNanos) + `,`,
		`PeriodType:` + strings.Replace(fmt.Sprintf("%v", this.PeriodType), "ValueType", "ValueType", 1) + `,`,
		`Period:` + fmt.Sprintf("%v", this.Period) + `,`,
		`Comment:` + fmt.Sprintf("%v", this.Comment) + `,`,
		`DefaultSampleType:` + fmt.Sprintf("%v", this.DefaultSampleType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValueType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValueType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sample) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sample{`,
		`LocationId:` + fmt.Sprintf("%v", this.LocationId) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Label:` + strings.Replace(fmt.Sprintf("%v", this.Label), "Label", "Label", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Label) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Label{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Str:` + fmt.Sprintf("%v", this.Str) + `,`,
		`Num:` + fmt.Sprintf("%v", this.Num) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Mapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Mapping{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`MemoryStart:` + fmt.Sprintf("%v", this.MemoryStart) + `,`,
		`MemoryLimit:` + fmt.Sprintf("%v", this.MemoryLimit) + `,`,
		`FileOffset:` + fmt.Sprintf("%v", this.FileOffset) + `,`,
		`Filename:` + fmt.Sprintf("%v", this.Filename) + `,`,
		`BuildId:` + fmt.Sprintf("%v", this.BuildId) + `,`,
		`HasFunctions:` + fmt.Sprintf("%v", this.HasFunctions) + `,`,
		`HasFilenames:` + fmt.Sprintf("%v", this.HasFilenames) + `,`,
		`HasLineNumbers:` + fmt.Sprintf("%v", this.HasLineNumbers) + `,`,
		`HasInlineFrames:` + fmt.Sprintf("%v", this.HasInlineFrames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Location) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Location{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`MappingId:` + fmt.Sprintf("%v", this.MappingId) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Line:` + strings.Replace(fmt.Sprintf("%v", this.Line), "Line", "Line", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Line) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Line{`,
		`FunctionId:` + fmt.Sprintf("%v", this.FunctionId) + `,`,
		`Line:` + fmt.Sprintf("%v", this.Line) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Function) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Function{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`SystemName:` + fmt.Sprintf("%v", this.SystemName) + `,`,
		`Filename:` + fmt.Sprintf("%v", this.Filename) + `,`,
		`StartLine:` + fmt.Sprintf("%v", this.StartLine) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringProfile(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Profile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleType = append(m.SampleType, &ValueType{})
			if err := m.SampleType[len(m.SampleType)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sample = append(m.Sample, &Sample{})
			if err := m.Sample[len(m.Sample)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mapping = append(m.Mapping, &Mapping{})
			if err := m.Mapping[len(m.Mapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = append(m.Location, &Location{})
			if err := m.Location[len(m.Location)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Function = append(m.Function, &Function{})
			if err := m.Function[len(m.Function)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringTable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringTable = append(m.StringTable, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropFrames", wireType)
			}
			m.DropFrames = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropFrames |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepFrames", wireType)
			}
			m.KeepFrames = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepFrames |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNanos", wireType)
			}
			m.TimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNanos", wireType)
			}
			m.DurationNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeriodType == nil {
				m.PeriodType = &ValueType{}
			}
			if err := m.PeriodType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProfile
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Comment = append(m.Comment, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProfile
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProfile
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProfile
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Comment = append(m.Comment, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSampleType", wireType)
			}
			m.DefaultSampleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultSampleType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProfile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProfile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProfile
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LocationId = append(m.LocationId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProfile
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProfile
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProfile
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LocationId = append(m.LocationId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationId", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProfile
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Value = append(m.Value, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProfile
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProfile
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProfile
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Value = append(m.Value, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = append(m.Label, &Label{})
			if err := m.Label[len(m.Label)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProfile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			m.Str = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Str |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProfile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryStart", wireType)
			}
			m.MemoryStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryStart |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileOffset", wireType)
			}
			m.FileOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileOffset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			m.Filename = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filename |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildId", wireType)
			}
			m.BuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFunctions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFunctions = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFilenames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFilenames = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLineNumbers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasLineNumbers = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasInlineFrames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasInlineFrames = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProfile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingId", wireType)
			}
			m.MappingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MappingId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			m.Address = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Address |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProfile
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Line = append(m.Line, &Line{})
			if err := m.Line[len(m.Line)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProfile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Line) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Line: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Line: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionId", wireType)
			}
			m.FunctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProfile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			m.Name = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Name |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemName", wireType)
			}
			m.SystemName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemName |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			m.Filename = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filename |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartLine |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProfile(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProfile
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProfile(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProfile
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProfile
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProfile
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProfile
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProfile(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProfile = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProfile   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/core/profiler/profile.proto", fileDescriptorProfile)
}

var fileDescriptorProfile = []byte{
	// 819 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x95, 0x4f, 0x8b, 0xe4, 0x44,
	0x18, 0xc6, 0x27, 0x9d, 0xf4, 0xbf, 0xb7, 0x67, 0xc6, 0xdd, 0x52, 0x34, 0x0a, 0x93, 0xe9, 0x6d,
	0x11, 0x1a, 0x91, 0x1e, 0x74, 0x05, 0x41, 0xd9, 0x8b, 0x0b, 0x0b, 0x0d, 0xe3, 0x28, 0x35, 0x8b,
	0xd7, 0x50, 0x3d, 0xa9, 0x6c, 0x17, 0x9b, 0x54, 0x42, 0xaa, 0xa2, 0xf4, 0xcd, 0x93, 0x07, 0x4f,
	0x82, 0x5f, 0xc2, 0x8f, 0xe2, 0x71, 0x6f, 0x7a, 0x74, 0xda, 0x8b, 0xc7, 0xfd, 0x08, 0xf2, 0xbe,
	0x55, 0x89, 0x83, 0x4b, 0xe3, 0x5e, 0x86, 0x7a, 0x9f, 0xfa, 0x3d, 0x95, 0xaa, 0x7a, 0x9f, 0xea,
	0x81, 0x8b, 0xba, 0xa9, 0x6c, 0xb5, 0x69, 0xf3, 0x0b, 0x2b, 0xb5, 0xa9, 0x9a, 0xbc, 0xa8, 0xbe,
	0xbf, 0xb8, 0xa9, 0x1a, 0x89, 0x13, 0xb9, 0x2a, 0x64, 0xd3, 0x0d, 0x56, 0x44, 0xb2, 0x77, 0xfe,
	0xe5, 0x56, 0x36, 0xc7, 0xb9, 0x55, 0x8d, 0x7f, 0x17, 0xbf, 0x0c, 0x61, 0xfc, 0x8d, 0x43, 0xd9,
	0x63, 0x98, 0x19, 0x51, 0xd6, 0x85, 0x4c, 0xed, 0xae, 0x96, 0x71, 0x30, 0x0f, 0x97, 0xb3, 0x4f,
	0x16, 0xab, 0x03, 0xd6, 0xd5, 0xb7, 0xa2, 0x68, 0xe5, 0xd3, 0x5d, 0x2d, 0x39, 0x38, 0x1b, 0x8e,
	0xd9, 0x67, 0x30, 0x72, 0x55, 0x3c, 0x20, 0xff, 0xf9, 0x41, 0xff, 0x35, 0x61, 0xdc, 0xe3, 0xec,
	0x73, 0x18, 0x97, 0xa2, 0xae, 0x95, 0x7e, 0x16, 0x87, 0xe4, 0x9c, 0x1f, 0x74, 0x7e, 0xe5, 0x38,
	0xde, 0x19, 0xd8, 0x23, 0x98, 0x14, 0xd5, 0x8d, 0xb0, 0xaa, 0xd2, 0x71, 0x44, 0xe6, 0x07, 0x07,
	0xcd, 0x97, 0x1e, 0xe4, 0xbd, 0x05, 0xed, 0x79, 0xab, 0x6f, 0xc8, 0x3e, 0xfc, 0x1f, 0xfb, 0x13,
	0x0f, 0xf2, 0xde, 0xc2, 0x1e, 0xc0, 0xb1, 0xb1, 0x8d, 0xd2, 0xcf, 0x52, 0x2b, 0x36, 0x85, 0x8c,
	0x47, 0xf3, 0x70, 0x39, 0xe5, 0x33, 0xa7, 0x3d, 0x45, 0x89, 0x9d, 0xc3, 0x2c, 0x6b, 0xaa, 0x3a,
	0xcd, 0x1b, 0x51, 0x4a, 0x13, 0x8f, 0xe7, 0xc1, 0x32, 0xe4, 0x80, 0xd2, 0x13, 0x52, 0x10, 0x78,
	0x2e, 0x65, 0x0f, 0x4c, 0x1c, 0x80, 0x92, 0x07, 0xce, 0x00, 0xac, 0x2a, 0x65, 0xaa, 0x85, 0xae,
	0x4c, 0x3c, 0xa5, 0xf9, 0x29, 0x2a, 0x57, 0x28, 0xb0, 0x0f, 0xe0, 0x34, 0x6b, 0x1b, 0x3a, 0x8e,
	0x47, 0x80, 0x90, 0x93, 0x4e, 0x75, 0xd8, 0x63, 0x98, 0xd5, 0xb2, 0x51, 0x55, 0xe6, 0x5a, 0x3c,
	0x9b, 0x07, 0xaf, 0xdb, 0x62, 0x67, 0xa3, 0x16, 0xbf, 0x0d, 0x23, 0x57, 0xc5, 0xc7, 0xf4, 0x0d,
	0x5f, 0xb1, 0x18, 0xc6, 0x37, 0x55, 0x59, 0x4a, 0x6d, 0xe3, 0x93, 0x79, 0xb8, 0x0c, 0x79, 0x57,
	0xb2, 0x15, 0xbc, 0x99, 0xc9, 0x5c, 0xb4, 0x85, 0x4d, 0xef, 0x26, 0xec, 0x94, 0xec, 0xf7, 0xfd,
	0xd4, 0x75, 0x1f, 0xa2, 0xc5, 0x43, 0x98, 0xf6, 0x9f, 0x66, 0x0c, 0x22, 0x9f, 0x47, 0xa4, 0x69,
	0x8c, 0x5a, 0xab, 0x95, 0x8d, 0x07, 0x4e, 0xc3, 0xf1, 0xa2, 0x85, 0x91, 0x5b, 0x02, 0x2f, 0xb3,
	0xeb, 0x6d, 0xaa, 0x32, 0x0a, 0x72, 0xc4, 0xa1, 0x93, 0xd6, 0x19, 0x7b, 0x0b, 0x86, 0xdf, 0xe1,
	0xfa, 0x94, 0xd1, 0x90, 0xbb, 0x82, 0x7d, 0x0a, 0xc3, 0x42, 0x6c, 0x64, 0xe1, 0xf3, 0x97, 0x1c,
	0x8e, 0x10, 0x52, 0xdc, 0xc1, 0x8b, 0x47, 0x30, 0xa4, 0x9a, 0xdd, 0x83, 0xf0, 0xb9, 0xdc, 0xf9,
	0x6d, 0xe2, 0x10, 0x15, 0x63, 0x1b, 0xbf, 0x49, 0x1c, 0xa2, 0xa2, 0xdb, 0x32, 0x0e, 0x9d, 0xa2,
	0xdb, 0x72, 0xf1, 0xfb, 0x00, 0xc6, 0x3e, 0xcf, 0xec, 0x14, 0x06, 0xb4, 0xdd, 0x60, 0x19, 0xf1,
	0x81, 0xca, 0x30, 0x58, 0xa5, 0x2c, 0xab, 0x66, 0x97, 0x1a, 0x2b, 0x1a, 0x77, 0xda, 0x88, 0xcf,
	0x9c, 0x76, 0x8d, 0xd2, 0x1d, 0xa4, 0x50, 0xa5, 0xb2, 0xb4, 0x72, 0x8f, 0x5c, 0xa2, 0x84, 0xb7,
	0x81, 0xcf, 0x3b, 0xad, 0xf2, 0xdc, 0x48, 0x1b, 0x47, 0x44, 0x00, 0x4a, 0x5f, 0x93, 0xc2, 0xde,
	0x83, 0x09, 0x56, 0x5a, 0x94, 0x32, 0x1e, 0xd2, 0xce, 0xfa, 0x9a, 0xbd, 0x0b, 0x93, 0x4d, 0xab,
	0x8a, 0x0c, 0xef, 0x71, 0x44, 0x73, 0x63, 0xaa, 0xd7, 0x19, 0x7b, 0x1f, 0x4e, 0xb6, 0xc2, 0xa4,
	0xdd, 0x33, 0x70, 0xa9, 0x9e, 0xf0, 0xe3, 0xad, 0x30, 0xdd, 0x23, 0x31, 0x3d, 0xe4, 0xd7, 0x73,
	0xc9, 0xf6, 0x50, 0xa7, 0xb1, 0x25, 0xdc, 0x43, 0xa8, 0x50, 0x5a, 0xa6, 0xba, 0x2d, 0x37, 0xb2,
	0x71, 0x09, 0x9f, 0xf0, 0xd3, 0xad, 0x30, 0x97, 0x4a, 0xcb, 0x2b, 0xa7, 0xb2, 0x0f, 0xe1, 0x3e,
	0x92, 0x4a, 0x13, 0xeb, 0x1f, 0x0b, 0x10, 0xfa, 0xc6, 0x56, 0x98, 0x35, 0xe9, 0xee, 0xc5, 0x2c,
	0x7e, 0x0c, 0x60, 0xd2, 0x3d, 0xf6, 0x57, 0xae, 0xf6, 0x0c, 0xc0, 0xff, 0x78, 0xe0, 0xc9, 0xdc,
	0xc5, 0x4e, 0xbd, 0xb2, 0xa6, 0x28, 0x8b, 0x2c, 0x6b, 0xa4, 0x31, 0xfe, 0x46, 0xbb, 0x92, 0x7d,
	0x0c, 0x11, 0x7e, 0xc3, 0xff, 0xcc, 0x9c, 0x1d, 0xce, 0x88, 0xd2, 0x92, 0x13, 0xba, 0xf8, 0x02,
	0x22, 0xac, 0xa8, 0x11, 0xfe, 0x62, 0xd2, 0x7e, 0x33, 0xd0, 0x49, 0xeb, 0x0c, 0x53, 0x4d, 0x6b,
	0xfb, 0x54, 0x93, 0xf9, 0xa7, 0x00, 0x26, 0xdd, 0x75, 0xbe, 0x72, 0x0a, 0x06, 0x11, 0x75, 0xcd,
	0x1b, 0xa8, 0x63, 0xe7, 0x30, 0x33, 0x3b, 0x63, 0x65, 0x99, 0xd2, 0x94, 0x8b, 0x1a, 0x38, 0xe9,
	0x0a, 0x81, 0xbb, 0xed, 0x8e, 0xfe, 0xd3, 0xee, 0x33, 0x00, 0x8a, 0x1a, 0xf5, 0xc2, 0x87, 0x61,
	0x4a, 0x0a, 0x9e, 0xe0, 0xcb, 0x8f, 0x5e, 0xdc, 0x26, 0x47, 0x7f, 0xdc, 0x26, 0x47, 0x2f, 0x6f,
	0x93, 0xe0, 0x87, 0x7d, 0x12, 0xfc, 0xba, 0x4f, 0x82, 0xdf, 0xf6, 0x49, 0xf0, 0x62, 0x9f, 0x04,
	0x7f, 0xee, 0x93, 0xe0, 0xef, 0x7d, 0x72, 0xf4, 0x72, 0x9f, 0x04, 0x3f, 0xff, 0x95, 0x1c, 0x6d,
	0x46, 0xf4, 0xbf, 0xe7, 0xe1, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x7c, 0x21, 0x7d, 0x50, 0xae,
	0x06, 0x00, 0x00,
}
