// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/core/profiler/tfprof_output.proto

/*
	Package tensorflow_tfprof is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/core/profiler/tfprof_output.proto

	It has these top-level messages:
		TFProfTensorProto
		GraphNodeProto
		MultiGraphNodeProto
		AdviceProto
*/
package tensorflow_tfprof

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import tensorflow "github.com/d4l3k/pok/tensorflow/core/framework"
import tensorflow1 "github.com/d4l3k/pok/tensorflow/core/framework"

import fmt "fmt"
import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type TFProfTensorProto struct {
	Dtype tensorflow1.DataType `protobuf:"varint,1,opt,name=dtype,proto3,enum=tensorflow.DataType" json:"dtype,omitempty"`
	// Flatten tensor in row-major.
	// Only one of the following array is set.
	ValueDouble []float64 `protobuf:"fixed64,2,rep,packed,name=value_double,json=valueDouble" json:"value_double,omitempty"`
	ValueInt64  []int64   `protobuf:"varint,3,rep,packed,name=value_int64,json=valueInt64" json:"value_int64,omitempty"`
	ValueStr    []string  `protobuf:"bytes,4,rep,name=value_str,json=valueStr" json:"value_str,omitempty"`
}

func (m *TFProfTensorProto) Reset()                    { *m = TFProfTensorProto{} }
func (*TFProfTensorProto) ProtoMessage()               {}
func (*TFProfTensorProto) Descriptor() ([]byte, []int) { return fileDescriptorTfprofOutput, []int{0} }

func (m *TFProfTensorProto) GetDtype() tensorflow1.DataType {
	if m != nil {
		return m.Dtype
	}
	return tensorflow1.DT_INVALID
}

func (m *TFProfTensorProto) GetValueDouble() []float64 {
	if m != nil {
		return m.ValueDouble
	}
	return nil
}

func (m *TFProfTensorProto) GetValueInt64() []int64 {
	if m != nil {
		return m.ValueInt64
	}
	return nil
}

func (m *TFProfTensorProto) GetValueStr() []string {
	if m != nil {
		return m.ValueStr
	}
	return nil
}

// A node in TensorFlow graph. Used by scope/graph view.
type GraphNodeProto struct {
	// op name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// tensor value restored from checkpoint.
	TensorValue *TFProfTensorProto `protobuf:"bytes,15,opt,name=tensor_value,json=tensorValue" json:"tensor_value,omitempty"`
	// op execution time.
	// A node can be defined once but run multiple times in tf.while_loop.
	// the times sum up all different runs.
	RunCount              int64 `protobuf:"varint,21,opt,name=run_count,json=runCount,proto3" json:"run_count,omitempty"`
	ExecMicros            int64 `protobuf:"varint,2,opt,name=exec_micros,json=execMicros,proto3" json:"exec_micros,omitempty"`
	AcceleratorExecMicros int64 `protobuf:"varint,17,opt,name=accelerator_exec_micros,json=acceleratorExecMicros,proto3" json:"accelerator_exec_micros,omitempty"`
	CpuExecMicros         int64 `protobuf:"varint,18,opt,name=cpu_exec_micros,json=cpuExecMicros,proto3" json:"cpu_exec_micros,omitempty"`
	// Total bytes requested by the op.
	RequestedBytes int64 `protobuf:"varint,3,opt,name=requested_bytes,json=requestedBytes,proto3" json:"requested_bytes,omitempty"`
	// Max bytes allocated and being used by the op at a point.
	PeakBytes int64 `protobuf:"varint,24,opt,name=peak_bytes,json=peakBytes,proto3" json:"peak_bytes,omitempty"`
	// Total bytes requested by the op and not released before end.
	ResidualBytes int64 `protobuf:"varint,25,opt,name=residual_bytes,json=residualBytes,proto3" json:"residual_bytes,omitempty"`
	// Total bytes output by the op (not necessarily allocated by the op).
	OutputBytes int64 `protobuf:"varint,26,opt,name=output_bytes,json=outputBytes,proto3" json:"output_bytes,omitempty"`
	// Number of parameters if available.
	Parameters int64 `protobuf:"varint,4,opt,name=parameters,proto3" json:"parameters,omitempty"`
	// Number of float operations.
	FloatOps int64 `protobuf:"varint,13,opt,name=float_ops,json=floatOps,proto3" json:"float_ops,omitempty"`
	// Device the op is assigned to.
	// Since an op can fire multiple kernel calls, there can be multiple devices.
	Devices []string `protobuf:"bytes,10,rep,name=devices" json:"devices,omitempty"`
	// The following are the aggregated stats from all *accounted* children and
	// the node itself. The actual children depend on the data structure used.
	// In graph view, children are inputs recursively.
	// In scope view, children are nodes under the name scope.
	TotalDefinitionCount       int64 `protobuf:"varint,23,opt,name=total_definition_count,json=totalDefinitionCount,proto3" json:"total_definition_count,omitempty"`
	TotalRunCount              int64 `protobuf:"varint,22,opt,name=total_run_count,json=totalRunCount,proto3" json:"total_run_count,omitempty"`
	TotalExecMicros            int64 `protobuf:"varint,6,opt,name=total_exec_micros,json=totalExecMicros,proto3" json:"total_exec_micros,omitempty"`
	TotalAcceleratorExecMicros int64 `protobuf:"varint,19,opt,name=total_accelerator_exec_micros,json=totalAcceleratorExecMicros,proto3" json:"total_accelerator_exec_micros,omitempty"`
	TotalCpuExecMicros         int64 `protobuf:"varint,20,opt,name=total_cpu_exec_micros,json=totalCpuExecMicros,proto3" json:"total_cpu_exec_micros,omitempty"`
	TotalRequestedBytes        int64 `protobuf:"varint,7,opt,name=total_requested_bytes,json=totalRequestedBytes,proto3" json:"total_requested_bytes,omitempty"`
	TotalPeakBytes             int64 `protobuf:"varint,27,opt,name=total_peak_bytes,json=totalPeakBytes,proto3" json:"total_peak_bytes,omitempty"`
	TotalResidualBytes         int64 `protobuf:"varint,28,opt,name=total_residual_bytes,json=totalResidualBytes,proto3" json:"total_residual_bytes,omitempty"`
	TotalOutputBytes           int64 `protobuf:"varint,29,opt,name=total_output_bytes,json=totalOutputBytes,proto3" json:"total_output_bytes,omitempty"`
	TotalParameters            int64 `protobuf:"varint,8,opt,name=total_parameters,json=totalParameters,proto3" json:"total_parameters,omitempty"`
	TotalFloatOps              int64 `protobuf:"varint,14,opt,name=total_float_ops,json=totalFloatOps,proto3" json:"total_float_ops,omitempty"`
	// shape information, if available.
	// TODO(xpan): Why is this repeated?
	Shapes      []*tensorflow.TensorShapeProto         `protobuf:"bytes,11,rep,name=shapes" json:"shapes,omitempty"`
	InputShapes map[int32]*tensorflow.TensorShapeProto `protobuf:"bytes,16,rep,name=input_shapes,json=inputShapes" json:"input_shapes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Descendants of the graph. The actual descendants depend on the data
	// structure used (scope, graph).
	Children []*GraphNodeProto `protobuf:"bytes,12,rep,name=children" json:"children,omitempty"`
}

func (m *GraphNodeProto) Reset()                    { *m = GraphNodeProto{} }
func (*GraphNodeProto) ProtoMessage()               {}
func (*GraphNodeProto) Descriptor() ([]byte, []int) { return fileDescriptorTfprofOutput, []int{1} }

func (m *GraphNodeProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphNodeProto) GetTensorValue() *TFProfTensorProto {
	if m != nil {
		return m.TensorValue
	}
	return nil
}

func (m *GraphNodeProto) GetRunCount() int64 {
	if m != nil {
		return m.RunCount
	}
	return 0
}

func (m *GraphNodeProto) GetExecMicros() int64 {
	if m != nil {
		return m.ExecMicros
	}
	return 0
}

func (m *GraphNodeProto) GetAcceleratorExecMicros() int64 {
	if m != nil {
		return m.AcceleratorExecMicros
	}
	return 0
}

func (m *GraphNodeProto) GetCpuExecMicros() int64 {
	if m != nil {
		return m.CpuExecMicros
	}
	return 0
}

func (m *GraphNodeProto) GetRequestedBytes() int64 {
	if m != nil {
		return m.RequestedBytes
	}
	return 0
}

func (m *GraphNodeProto) GetPeakBytes() int64 {
	if m != nil {
		return m.PeakBytes
	}
	return 0
}

func (m *GraphNodeProto) GetResidualBytes() int64 {
	if m != nil {
		return m.ResidualBytes
	}
	return 0
}

func (m *GraphNodeProto) GetOutputBytes() int64 {
	if m != nil {
		return m.OutputBytes
	}
	return 0
}

func (m *GraphNodeProto) GetParameters() int64 {
	if m != nil {
		return m.Parameters
	}
	return 0
}

func (m *GraphNodeProto) GetFloatOps() int64 {
	if m != nil {
		return m.FloatOps
	}
	return 0
}

func (m *GraphNodeProto) GetDevices() []string {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *GraphNodeProto) GetTotalDefinitionCount() int64 {
	if m != nil {
		return m.TotalDefinitionCount
	}
	return 0
}

func (m *GraphNodeProto) GetTotalRunCount() int64 {
	if m != nil {
		return m.TotalRunCount
	}
	return 0
}

func (m *GraphNodeProto) GetTotalExecMicros() int64 {
	if m != nil {
		return m.TotalExecMicros
	}
	return 0
}

func (m *GraphNodeProto) GetTotalAcceleratorExecMicros() int64 {
	if m != nil {
		return m.TotalAcceleratorExecMicros
	}
	return 0
}

func (m *GraphNodeProto) GetTotalCpuExecMicros() int64 {
	if m != nil {
		return m.TotalCpuExecMicros
	}
	return 0
}

func (m *GraphNodeProto) GetTotalRequestedBytes() int64 {
	if m != nil {
		return m.TotalRequestedBytes
	}
	return 0
}

func (m *GraphNodeProto) GetTotalPeakBytes() int64 {
	if m != nil {
		return m.TotalPeakBytes
	}
	return 0
}

func (m *GraphNodeProto) GetTotalResidualBytes() int64 {
	if m != nil {
		return m.TotalResidualBytes
	}
	return 0
}

func (m *GraphNodeProto) GetTotalOutputBytes() int64 {
	if m != nil {
		return m.TotalOutputBytes
	}
	return 0
}

func (m *GraphNodeProto) GetTotalParameters() int64 {
	if m != nil {
		return m.TotalParameters
	}
	return 0
}

func (m *GraphNodeProto) GetTotalFloatOps() int64 {
	if m != nil {
		return m.TotalFloatOps
	}
	return 0
}

func (m *GraphNodeProto) GetShapes() []*tensorflow.TensorShapeProto {
	if m != nil {
		return m.Shapes
	}
	return nil
}

func (m *GraphNodeProto) GetInputShapes() map[int32]*tensorflow.TensorShapeProto {
	if m != nil {
		return m.InputShapes
	}
	return nil
}

func (m *GraphNodeProto) GetChildren() []*GraphNodeProto {
	if m != nil {
		return m.Children
	}
	return nil
}

// A node that groups multiple GraphNodeProto.
// Depending on the 'view', the semantics of the TFmultiGraphNodeProto
// is different:
// code view: A node groups all TensorFlow graph nodes created by the
//            Python code.
// op view:   A node groups all TensorFlow graph nodes that are of type
//            of the op (e.g. MatMul, Conv2D).
type MultiGraphNodeProto struct {
	// Name of the node.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// code execution time.
	ExecMicros            int64 `protobuf:"varint,2,opt,name=exec_micros,json=execMicros,proto3" json:"exec_micros,omitempty"`
	AcceleratorExecMicros int64 `protobuf:"varint,12,opt,name=accelerator_exec_micros,json=acceleratorExecMicros,proto3" json:"accelerator_exec_micros,omitempty"`
	CpuExecMicros         int64 `protobuf:"varint,13,opt,name=cpu_exec_micros,json=cpuExecMicros,proto3" json:"cpu_exec_micros,omitempty"`
	// Total requested bytes by the code.
	RequestedBytes int64 `protobuf:"varint,3,opt,name=requested_bytes,json=requestedBytes,proto3" json:"requested_bytes,omitempty"`
	// Max bytes allocated and being used by the op at a point.
	PeakBytes int64 `protobuf:"varint,16,opt,name=peak_bytes,json=peakBytes,proto3" json:"peak_bytes,omitempty"`
	// Total bytes requested by the op and not released before end.
	ResidualBytes int64 `protobuf:"varint,17,opt,name=residual_bytes,json=residualBytes,proto3" json:"residual_bytes,omitempty"`
	// Total bytes output by the op (not necessarily allocated by the op).
	OutputBytes int64 `protobuf:"varint,18,opt,name=output_bytes,json=outputBytes,proto3" json:"output_bytes,omitempty"`
	// Number of parameters if available.
	Parameters int64 `protobuf:"varint,4,opt,name=parameters,proto3" json:"parameters,omitempty"`
	// Number of float operations.
	FloatOps int64 `protobuf:"varint,5,opt,name=float_ops,json=floatOps,proto3" json:"float_ops,omitempty"`
	// The following are the aggregated stats from descendants.
	// The actual descendants depend on the data structure used.
	TotalExecMicros            int64 `protobuf:"varint,6,opt,name=total_exec_micros,json=totalExecMicros,proto3" json:"total_exec_micros,omitempty"`
	TotalAcceleratorExecMicros int64 `protobuf:"varint,14,opt,name=total_accelerator_exec_micros,json=totalAcceleratorExecMicros,proto3" json:"total_accelerator_exec_micros,omitempty"`
	TotalCpuExecMicros         int64 `protobuf:"varint,15,opt,name=total_cpu_exec_micros,json=totalCpuExecMicros,proto3" json:"total_cpu_exec_micros,omitempty"`
	TotalRequestedBytes        int64 `protobuf:"varint,7,opt,name=total_requested_bytes,json=totalRequestedBytes,proto3" json:"total_requested_bytes,omitempty"`
	TotalPeakBytes             int64 `protobuf:"varint,19,opt,name=total_peak_bytes,json=totalPeakBytes,proto3" json:"total_peak_bytes,omitempty"`
	TotalResidualBytes         int64 `protobuf:"varint,20,opt,name=total_residual_bytes,json=totalResidualBytes,proto3" json:"total_residual_bytes,omitempty"`
	TotalOutputBytes           int64 `protobuf:"varint,21,opt,name=total_output_bytes,json=totalOutputBytes,proto3" json:"total_output_bytes,omitempty"`
	TotalParameters            int64 `protobuf:"varint,8,opt,name=total_parameters,json=totalParameters,proto3" json:"total_parameters,omitempty"`
	TotalFloatOps              int64 `protobuf:"varint,9,opt,name=total_float_ops,json=totalFloatOps,proto3" json:"total_float_ops,omitempty"`
	// TensorFlow graph nodes contained by the MultiGraphNodeProto.
	GraphNodes []*GraphNodeProto `protobuf:"bytes,10,rep,name=graph_nodes,json=graphNodes" json:"graph_nodes,omitempty"`
	// Descendants of the node. The actual descendants depend on the data
	// structure used.
	Children []*MultiGraphNodeProto `protobuf:"bytes,11,rep,name=children" json:"children,omitempty"`
}

func (m *MultiGraphNodeProto) Reset()                    { *m = MultiGraphNodeProto{} }
func (*MultiGraphNodeProto) ProtoMessage()               {}
func (*MultiGraphNodeProto) Descriptor() ([]byte, []int) { return fileDescriptorTfprofOutput, []int{2} }

func (m *MultiGraphNodeProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MultiGraphNodeProto) GetExecMicros() int64 {
	if m != nil {
		return m.ExecMicros
	}
	return 0
}

func (m *MultiGraphNodeProto) GetAcceleratorExecMicros() int64 {
	if m != nil {
		return m.AcceleratorExecMicros
	}
	return 0
}

func (m *MultiGraphNodeProto) GetCpuExecMicros() int64 {
	if m != nil {
		return m.CpuExecMicros
	}
	return 0
}

func (m *MultiGraphNodeProto) GetRequestedBytes() int64 {
	if m != nil {
		return m.RequestedBytes
	}
	return 0
}

func (m *MultiGraphNodeProto) GetPeakBytes() int64 {
	if m != nil {
		return m.PeakBytes
	}
	return 0
}

func (m *MultiGraphNodeProto) GetResidualBytes() int64 {
	if m != nil {
		return m.ResidualBytes
	}
	return 0
}

func (m *MultiGraphNodeProto) GetOutputBytes() int64 {
	if m != nil {
		return m.OutputBytes
	}
	return 0
}

func (m *MultiGraphNodeProto) GetParameters() int64 {
	if m != nil {
		return m.Parameters
	}
	return 0
}

func (m *MultiGraphNodeProto) GetFloatOps() int64 {
	if m != nil {
		return m.FloatOps
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalExecMicros() int64 {
	if m != nil {
		return m.TotalExecMicros
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalAcceleratorExecMicros() int64 {
	if m != nil {
		return m.TotalAcceleratorExecMicros
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalCpuExecMicros() int64 {
	if m != nil {
		return m.TotalCpuExecMicros
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalRequestedBytes() int64 {
	if m != nil {
		return m.TotalRequestedBytes
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalPeakBytes() int64 {
	if m != nil {
		return m.TotalPeakBytes
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalResidualBytes() int64 {
	if m != nil {
		return m.TotalResidualBytes
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalOutputBytes() int64 {
	if m != nil {
		return m.TotalOutputBytes
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalParameters() int64 {
	if m != nil {
		return m.TotalParameters
	}
	return 0
}

func (m *MultiGraphNodeProto) GetTotalFloatOps() int64 {
	if m != nil {
		return m.TotalFloatOps
	}
	return 0
}

func (m *MultiGraphNodeProto) GetGraphNodes() []*GraphNodeProto {
	if m != nil {
		return m.GraphNodes
	}
	return nil
}

func (m *MultiGraphNodeProto) GetChildren() []*MultiGraphNodeProto {
	if m != nil {
		return m.Children
	}
	return nil
}

type AdviceProto struct {
	// checker name -> a list of reports from the checker.
	Checkers map[string]*AdviceProto_Checker `protobuf:"bytes,1,rep,name=checkers" json:"checkers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AdviceProto) Reset()                    { *m = AdviceProto{} }
func (*AdviceProto) ProtoMessage()               {}
func (*AdviceProto) Descriptor() ([]byte, []int) { return fileDescriptorTfprofOutput, []int{3} }

func (m *AdviceProto) GetCheckers() map[string]*AdviceProto_Checker {
	if m != nil {
		return m.Checkers
	}
	return nil
}

type AdviceProto_Checker struct {
	Reports []string `protobuf:"bytes,2,rep,name=reports" json:"reports,omitempty"`
}

func (m *AdviceProto_Checker) Reset()      { *m = AdviceProto_Checker{} }
func (*AdviceProto_Checker) ProtoMessage() {}
func (*AdviceProto_Checker) Descriptor() ([]byte, []int) {
	return fileDescriptorTfprofOutput, []int{3, 1}
}

func (m *AdviceProto_Checker) GetReports() []string {
	if m != nil {
		return m.Reports
	}
	return nil
}

func init() {
	proto.RegisterType((*TFProfTensorProto)(nil), "tensorflow.tfprof.TFProfTensorProto")
	proto.RegisterType((*GraphNodeProto)(nil), "tensorflow.tfprof.GraphNodeProto")
	proto.RegisterType((*MultiGraphNodeProto)(nil), "tensorflow.tfprof.MultiGraphNodeProto")
	proto.RegisterType((*AdviceProto)(nil), "tensorflow.tfprof.AdviceProto")
	proto.RegisterType((*AdviceProto_Checker)(nil), "tensorflow.tfprof.AdviceProto.Checker")
}
func (this *TFProfTensorProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TFProfTensorProto)
	if !ok {
		that2, ok := that.(TFProfTensorProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Dtype != that1.Dtype {
		return false
	}
	if len(this.ValueDouble) != len(that1.ValueDouble) {
		return false
	}
	for i := range this.ValueDouble {
		if this.ValueDouble[i] != that1.ValueDouble[i] {
			return false
		}
	}
	if len(this.ValueInt64) != len(that1.ValueInt64) {
		return false
	}
	for i := range this.ValueInt64 {
		if this.ValueInt64[i] != that1.ValueInt64[i] {
			return false
		}
	}
	if len(this.ValueStr) != len(that1.ValueStr) {
		return false
	}
	for i := range this.ValueStr {
		if this.ValueStr[i] != that1.ValueStr[i] {
			return false
		}
	}
	return true
}
func (this *GraphNodeProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GraphNodeProto)
	if !ok {
		that2, ok := that.(GraphNodeProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.TensorValue.Equal(that1.TensorValue) {
		return false
	}
	if this.RunCount != that1.RunCount {
		return false
	}
	if this.ExecMicros != that1.ExecMicros {
		return false
	}
	if this.AcceleratorExecMicros != that1.AcceleratorExecMicros {
		return false
	}
	if this.CpuExecMicros != that1.CpuExecMicros {
		return false
	}
	if this.RequestedBytes != that1.RequestedBytes {
		return false
	}
	if this.PeakBytes != that1.PeakBytes {
		return false
	}
	if this.ResidualBytes != that1.ResidualBytes {
		return false
	}
	if this.OutputBytes != that1.OutputBytes {
		return false
	}
	if this.Parameters != that1.Parameters {
		return false
	}
	if this.FloatOps != that1.FloatOps {
		return false
	}
	if len(this.Devices) != len(that1.Devices) {
		return false
	}
	for i := range this.Devices {
		if this.Devices[i] != that1.Devices[i] {
			return false
		}
	}
	if this.TotalDefinitionCount != that1.TotalDefinitionCount {
		return false
	}
	if this.TotalRunCount != that1.TotalRunCount {
		return false
	}
	if this.TotalExecMicros != that1.TotalExecMicros {
		return false
	}
	if this.TotalAcceleratorExecMicros != that1.TotalAcceleratorExecMicros {
		return false
	}
	if this.TotalCpuExecMicros != that1.TotalCpuExecMicros {
		return false
	}
	if this.TotalRequestedBytes != that1.TotalRequestedBytes {
		return false
	}
	if this.TotalPeakBytes != that1.TotalPeakBytes {
		return false
	}
	if this.TotalResidualBytes != that1.TotalResidualBytes {
		return false
	}
	if this.TotalOutputBytes != that1.TotalOutputBytes {
		return false
	}
	if this.TotalParameters != that1.TotalParameters {
		return false
	}
	if this.TotalFloatOps != that1.TotalFloatOps {
		return false
	}
	if len(this.Shapes) != len(that1.Shapes) {
		return false
	}
	for i := range this.Shapes {
		if !this.Shapes[i].Equal(that1.Shapes[i]) {
			return false
		}
	}
	if len(this.InputShapes) != len(that1.InputShapes) {
		return false
	}
	for i := range this.InputShapes {
		if !this.InputShapes[i].Equal(that1.InputShapes[i]) {
			return false
		}
	}
	if len(this.Children) != len(that1.Children) {
		return false
	}
	for i := range this.Children {
		if !this.Children[i].Equal(that1.Children[i]) {
			return false
		}
	}
	return true
}
func (this *MultiGraphNodeProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MultiGraphNodeProto)
	if !ok {
		that2, ok := that.(MultiGraphNodeProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ExecMicros != that1.ExecMicros {
		return false
	}
	if this.AcceleratorExecMicros != that1.AcceleratorExecMicros {
		return false
	}
	if this.CpuExecMicros != that1.CpuExecMicros {
		return false
	}
	if this.RequestedBytes != that1.RequestedBytes {
		return false
	}
	if this.PeakBytes != that1.PeakBytes {
		return false
	}
	if this.ResidualBytes != that1.ResidualBytes {
		return false
	}
	if this.OutputBytes != that1.OutputBytes {
		return false
	}
	if this.Parameters != that1.Parameters {
		return false
	}
	if this.FloatOps != that1.FloatOps {
		return false
	}
	if this.TotalExecMicros != that1.TotalExecMicros {
		return false
	}
	if this.TotalAcceleratorExecMicros != that1.TotalAcceleratorExecMicros {
		return false
	}
	if this.TotalCpuExecMicros != that1.TotalCpuExecMicros {
		return false
	}
	if this.TotalRequestedBytes != that1.TotalRequestedBytes {
		return false
	}
	if this.TotalPeakBytes != that1.TotalPeakBytes {
		return false
	}
	if this.TotalResidualBytes != that1.TotalResidualBytes {
		return false
	}
	if this.TotalOutputBytes != that1.TotalOutputBytes {
		return false
	}
	if this.TotalParameters != that1.TotalParameters {
		return false
	}
	if this.TotalFloatOps != that1.TotalFloatOps {
		return false
	}
	if len(this.GraphNodes) != len(that1.GraphNodes) {
		return false
	}
	for i := range this.GraphNodes {
		if !this.GraphNodes[i].Equal(that1.GraphNodes[i]) {
			return false
		}
	}
	if len(this.Children) != len(that1.Children) {
		return false
	}
	for i := range this.Children {
		if !this.Children[i].Equal(that1.Children[i]) {
			return false
		}
	}
	return true
}
func (this *AdviceProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AdviceProto)
	if !ok {
		that2, ok := that.(AdviceProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Checkers) != len(that1.Checkers) {
		return false
	}
	for i := range this.Checkers {
		if !this.Checkers[i].Equal(that1.Checkers[i]) {
			return false
		}
	}
	return true
}
func (this *AdviceProto_Checker) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AdviceProto_Checker)
	if !ok {
		that2, ok := that.(AdviceProto_Checker)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Reports) != len(that1.Reports) {
		return false
	}
	for i := range this.Reports {
		if this.Reports[i] != that1.Reports[i] {
			return false
		}
	}
	return true
}
func (this *TFProfTensorProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_tfprof.TFProfTensorProto{")
	s = append(s, "Dtype: "+fmt.Sprintf("%#v", this.Dtype)+",\n")
	s = append(s, "ValueDouble: "+fmt.Sprintf("%#v", this.ValueDouble)+",\n")
	s = append(s, "ValueInt64: "+fmt.Sprintf("%#v", this.ValueInt64)+",\n")
	s = append(s, "ValueStr: "+fmt.Sprintf("%#v", this.ValueStr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GraphNodeProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 31)
	s = append(s, "&tensorflow_tfprof.GraphNodeProto{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.TensorValue != nil {
		s = append(s, "TensorValue: "+fmt.Sprintf("%#v", this.TensorValue)+",\n")
	}
	s = append(s, "RunCount: "+fmt.Sprintf("%#v", this.RunCount)+",\n")
	s = append(s, "ExecMicros: "+fmt.Sprintf("%#v", this.ExecMicros)+",\n")
	s = append(s, "AcceleratorExecMicros: "+fmt.Sprintf("%#v", this.AcceleratorExecMicros)+",\n")
	s = append(s, "CpuExecMicros: "+fmt.Sprintf("%#v", this.CpuExecMicros)+",\n")
	s = append(s, "RequestedBytes: "+fmt.Sprintf("%#v", this.RequestedBytes)+",\n")
	s = append(s, "PeakBytes: "+fmt.Sprintf("%#v", this.PeakBytes)+",\n")
	s = append(s, "ResidualBytes: "+fmt.Sprintf("%#v", this.ResidualBytes)+",\n")
	s = append(s, "OutputBytes: "+fmt.Sprintf("%#v", this.OutputBytes)+",\n")
	s = append(s, "Parameters: "+fmt.Sprintf("%#v", this.Parameters)+",\n")
	s = append(s, "FloatOps: "+fmt.Sprintf("%#v", this.FloatOps)+",\n")
	s = append(s, "Devices: "+fmt.Sprintf("%#v", this.Devices)+",\n")
	s = append(s, "TotalDefinitionCount: "+fmt.Sprintf("%#v", this.TotalDefinitionCount)+",\n")
	s = append(s, "TotalRunCount: "+fmt.Sprintf("%#v", this.TotalRunCount)+",\n")
	s = append(s, "TotalExecMicros: "+fmt.Sprintf("%#v", this.TotalExecMicros)+",\n")
	s = append(s, "TotalAcceleratorExecMicros: "+fmt.Sprintf("%#v", this.TotalAcceleratorExecMicros)+",\n")
	s = append(s, "TotalCpuExecMicros: "+fmt.Sprintf("%#v", this.TotalCpuExecMicros)+",\n")
	s = append(s, "TotalRequestedBytes: "+fmt.Sprintf("%#v", this.TotalRequestedBytes)+",\n")
	s = append(s, "TotalPeakBytes: "+fmt.Sprintf("%#v", this.TotalPeakBytes)+",\n")
	s = append(s, "TotalResidualBytes: "+fmt.Sprintf("%#v", this.TotalResidualBytes)+",\n")
	s = append(s, "TotalOutputBytes: "+fmt.Sprintf("%#v", this.TotalOutputBytes)+",\n")
	s = append(s, "TotalParameters: "+fmt.Sprintf("%#v", this.TotalParameters)+",\n")
	s = append(s, "TotalFloatOps: "+fmt.Sprintf("%#v", this.TotalFloatOps)+",\n")
	if this.Shapes != nil {
		s = append(s, "Shapes: "+fmt.Sprintf("%#v", this.Shapes)+",\n")
	}
	keysForInputShapes := make([]int32, 0, len(this.InputShapes))
	for k, _ := range this.InputShapes {
		keysForInputShapes = append(keysForInputShapes, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInputShapes)
	mapStringForInputShapes := "map[int32]*tensorflow.TensorShapeProto{"
	for _, k := range keysForInputShapes {
		mapStringForInputShapes += fmt.Sprintf("%#v: %#v,", k, this.InputShapes[k])
	}
	mapStringForInputShapes += "}"
	if this.InputShapes != nil {
		s = append(s, "InputShapes: "+mapStringForInputShapes+",\n")
	}
	if this.Children != nil {
		s = append(s, "Children: "+fmt.Sprintf("%#v", this.Children)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MultiGraphNodeProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 25)
	s = append(s, "&tensorflow_tfprof.MultiGraphNodeProto{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ExecMicros: "+fmt.Sprintf("%#v", this.ExecMicros)+",\n")
	s = append(s, "AcceleratorExecMicros: "+fmt.Sprintf("%#v", this.AcceleratorExecMicros)+",\n")
	s = append(s, "CpuExecMicros: "+fmt.Sprintf("%#v", this.CpuExecMicros)+",\n")
	s = append(s, "RequestedBytes: "+fmt.Sprintf("%#v", this.RequestedBytes)+",\n")
	s = append(s, "PeakBytes: "+fmt.Sprintf("%#v", this.PeakBytes)+",\n")
	s = append(s, "ResidualBytes: "+fmt.Sprintf("%#v", this.ResidualBytes)+",\n")
	s = append(s, "OutputBytes: "+fmt.Sprintf("%#v", this.OutputBytes)+",\n")
	s = append(s, "Parameters: "+fmt.Sprintf("%#v", this.Parameters)+",\n")
	s = append(s, "FloatOps: "+fmt.Sprintf("%#v", this.FloatOps)+",\n")
	s = append(s, "TotalExecMicros: "+fmt.Sprintf("%#v", this.TotalExecMicros)+",\n")
	s = append(s, "TotalAcceleratorExecMicros: "+fmt.Sprintf("%#v", this.TotalAcceleratorExecMicros)+",\n")
	s = append(s, "TotalCpuExecMicros: "+fmt.Sprintf("%#v", this.TotalCpuExecMicros)+",\n")
	s = append(s, "TotalRequestedBytes: "+fmt.Sprintf("%#v", this.TotalRequestedBytes)+",\n")
	s = append(s, "TotalPeakBytes: "+fmt.Sprintf("%#v", this.TotalPeakBytes)+",\n")
	s = append(s, "TotalResidualBytes: "+fmt.Sprintf("%#v", this.TotalResidualBytes)+",\n")
	s = append(s, "TotalOutputBytes: "+fmt.Sprintf("%#v", this.TotalOutputBytes)+",\n")
	s = append(s, "TotalParameters: "+fmt.Sprintf("%#v", this.TotalParameters)+",\n")
	s = append(s, "TotalFloatOps: "+fmt.Sprintf("%#v", this.TotalFloatOps)+",\n")
	if this.GraphNodes != nil {
		s = append(s, "GraphNodes: "+fmt.Sprintf("%#v", this.GraphNodes)+",\n")
	}
	if this.Children != nil {
		s = append(s, "Children: "+fmt.Sprintf("%#v", this.Children)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdviceProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_tfprof.AdviceProto{")
	keysForCheckers := make([]string, 0, len(this.Checkers))
	for k, _ := range this.Checkers {
		keysForCheckers = append(keysForCheckers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCheckers)
	mapStringForCheckers := "map[string]*AdviceProto_Checker{"
	for _, k := range keysForCheckers {
		mapStringForCheckers += fmt.Sprintf("%#v: %#v,", k, this.Checkers[k])
	}
	mapStringForCheckers += "}"
	if this.Checkers != nil {
		s = append(s, "Checkers: "+mapStringForCheckers+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdviceProto_Checker) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_tfprof.AdviceProto_Checker{")
	s = append(s, "Reports: "+fmt.Sprintf("%#v", this.Reports)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTfprofOutput(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TFProfTensorProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TFProfTensorProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dtype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.Dtype))
	}
	if len(m.ValueDouble) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(len(m.ValueDouble)*8))
		for _, num := range m.ValueDouble {
			f1 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f1)
			i++
			dAtA[i] = uint8(f1 >> 8)
			i++
			dAtA[i] = uint8(f1 >> 16)
			i++
			dAtA[i] = uint8(f1 >> 24)
			i++
			dAtA[i] = uint8(f1 >> 32)
			i++
			dAtA[i] = uint8(f1 >> 40)
			i++
			dAtA[i] = uint8(f1 >> 48)
			i++
			dAtA[i] = uint8(f1 >> 56)
			i++
		}
	}
	if len(m.ValueInt64) > 0 {
		dAtA3 := make([]byte, len(m.ValueInt64)*10)
		var j2 int
		for _, num1 := range m.ValueInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.ValueStr) > 0 {
		for _, s := range m.ValueStr {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *GraphNodeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphNodeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ExecMicros != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.ExecMicros))
	}
	if m.RequestedBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.RequestedBytes))
	}
	if m.Parameters != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.Parameters))
	}
	if m.TotalExecMicros != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalExecMicros))
	}
	if m.TotalRequestedBytes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalRequestedBytes))
	}
	if m.TotalParameters != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalParameters))
	}
	if len(m.Devices) > 0 {
		for _, s := range m.Devices {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Shapes) > 0 {
		for _, msg := range m.Shapes {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTfprofOutput(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x62
			i++
			i = encodeVarintTfprofOutput(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FloatOps != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.FloatOps))
	}
	if m.TotalFloatOps != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalFloatOps))
	}
	if m.TensorValue != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TensorValue.Size()))
		n4, err := m.TensorValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.InputShapes) > 0 {
		for k, _ := range m.InputShapes {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			v := m.InputShapes[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTfprofOutput(uint64(msgSize))
			}
			mapSize := 1 + sovTfprofOutput(uint64(k)) + msgSize
			i = encodeVarintTfprofOutput(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTfprofOutput(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTfprofOutput(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.AcceleratorExecMicros != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.AcceleratorExecMicros))
	}
	if m.CpuExecMicros != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.CpuExecMicros))
	}
	if m.TotalAcceleratorExecMicros != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalAcceleratorExecMicros))
	}
	if m.TotalCpuExecMicros != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalCpuExecMicros))
	}
	if m.RunCount != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.RunCount))
	}
	if m.TotalRunCount != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalRunCount))
	}
	if m.TotalDefinitionCount != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalDefinitionCount))
	}
	if m.PeakBytes != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.PeakBytes))
	}
	if m.ResidualBytes != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.ResidualBytes))
	}
	if m.OutputBytes != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.OutputBytes))
	}
	if m.TotalPeakBytes != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalPeakBytes))
	}
	if m.TotalResidualBytes != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalResidualBytes))
	}
	if m.TotalOutputBytes != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalOutputBytes))
	}
	return i, nil
}

func (m *MultiGraphNodeProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiGraphNodeProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ExecMicros != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.ExecMicros))
	}
	if m.RequestedBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.RequestedBytes))
	}
	if m.Parameters != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.Parameters))
	}
	if m.FloatOps != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.FloatOps))
	}
	if m.TotalExecMicros != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalExecMicros))
	}
	if m.TotalRequestedBytes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalRequestedBytes))
	}
	if m.TotalParameters != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalParameters))
	}
	if m.TotalFloatOps != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalFloatOps))
	}
	if len(m.GraphNodes) > 0 {
		for _, msg := range m.GraphNodes {
			dAtA[i] = 0x52
			i++
			i = encodeVarintTfprofOutput(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintTfprofOutput(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AcceleratorExecMicros != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.AcceleratorExecMicros))
	}
	if m.CpuExecMicros != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.CpuExecMicros))
	}
	if m.TotalAcceleratorExecMicros != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalAcceleratorExecMicros))
	}
	if m.TotalCpuExecMicros != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalCpuExecMicros))
	}
	if m.PeakBytes != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.PeakBytes))
	}
	if m.ResidualBytes != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.ResidualBytes))
	}
	if m.OutputBytes != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.OutputBytes))
	}
	if m.TotalPeakBytes != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalPeakBytes))
	}
	if m.TotalResidualBytes != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalResidualBytes))
	}
	if m.TotalOutputBytes != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTfprofOutput(dAtA, i, uint64(m.TotalOutputBytes))
	}
	return i, nil
}

func (m *AdviceProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdviceProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Checkers) > 0 {
		for k, _ := range m.Checkers {
			dAtA[i] = 0xa
			i++
			v := m.Checkers[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTfprofOutput(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTfprofOutput(uint64(len(k))) + msgSize
			i = encodeVarintTfprofOutput(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTfprofOutput(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTfprofOutput(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	return i, nil
}

func (m *AdviceProto_Checker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdviceProto_Checker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reports) > 0 {
		for _, s := range m.Reports {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeFixed64TfprofOutput(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32TfprofOutput(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTfprofOutput(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TFProfTensorProto) Size() (n int) {
	var l int
	_ = l
	if m.Dtype != 0 {
		n += 1 + sovTfprofOutput(uint64(m.Dtype))
	}
	if len(m.ValueDouble) > 0 {
		n += 1 + sovTfprofOutput(uint64(len(m.ValueDouble)*8)) + len(m.ValueDouble)*8
	}
	if len(m.ValueInt64) > 0 {
		l = 0
		for _, e := range m.ValueInt64 {
			l += sovTfprofOutput(uint64(e))
		}
		n += 1 + sovTfprofOutput(uint64(l)) + l
	}
	if len(m.ValueStr) > 0 {
		for _, s := range m.ValueStr {
			l = len(s)
			n += 1 + l + sovTfprofOutput(uint64(l))
		}
	}
	return n
}

func (m *GraphNodeProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTfprofOutput(uint64(l))
	}
	if m.ExecMicros != 0 {
		n += 1 + sovTfprofOutput(uint64(m.ExecMicros))
	}
	if m.RequestedBytes != 0 {
		n += 1 + sovTfprofOutput(uint64(m.RequestedBytes))
	}
	if m.Parameters != 0 {
		n += 1 + sovTfprofOutput(uint64(m.Parameters))
	}
	if m.TotalExecMicros != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalExecMicros))
	}
	if m.TotalRequestedBytes != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalRequestedBytes))
	}
	if m.TotalParameters != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalParameters))
	}
	if len(m.Devices) > 0 {
		for _, s := range m.Devices {
			l = len(s)
			n += 1 + l + sovTfprofOutput(uint64(l))
		}
	}
	if len(m.Shapes) > 0 {
		for _, e := range m.Shapes {
			l = e.Size()
			n += 1 + l + sovTfprofOutput(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovTfprofOutput(uint64(l))
		}
	}
	if m.FloatOps != 0 {
		n += 1 + sovTfprofOutput(uint64(m.FloatOps))
	}
	if m.TotalFloatOps != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalFloatOps))
	}
	if m.TensorValue != nil {
		l = m.TensorValue.Size()
		n += 1 + l + sovTfprofOutput(uint64(l))
	}
	if len(m.InputShapes) > 0 {
		for k, v := range m.InputShapes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTfprofOutput(uint64(l))
			}
			mapEntrySize := 1 + sovTfprofOutput(uint64(k)) + l
			n += mapEntrySize + 2 + sovTfprofOutput(uint64(mapEntrySize))
		}
	}
	if m.AcceleratorExecMicros != 0 {
		n += 2 + sovTfprofOutput(uint64(m.AcceleratorExecMicros))
	}
	if m.CpuExecMicros != 0 {
		n += 2 + sovTfprofOutput(uint64(m.CpuExecMicros))
	}
	if m.TotalAcceleratorExecMicros != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalAcceleratorExecMicros))
	}
	if m.TotalCpuExecMicros != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalCpuExecMicros))
	}
	if m.RunCount != 0 {
		n += 2 + sovTfprofOutput(uint64(m.RunCount))
	}
	if m.TotalRunCount != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalRunCount))
	}
	if m.TotalDefinitionCount != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalDefinitionCount))
	}
	if m.PeakBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.PeakBytes))
	}
	if m.ResidualBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.ResidualBytes))
	}
	if m.OutputBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.OutputBytes))
	}
	if m.TotalPeakBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalPeakBytes))
	}
	if m.TotalResidualBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalResidualBytes))
	}
	if m.TotalOutputBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalOutputBytes))
	}
	return n
}

func (m *MultiGraphNodeProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTfprofOutput(uint64(l))
	}
	if m.ExecMicros != 0 {
		n += 1 + sovTfprofOutput(uint64(m.ExecMicros))
	}
	if m.RequestedBytes != 0 {
		n += 1 + sovTfprofOutput(uint64(m.RequestedBytes))
	}
	if m.Parameters != 0 {
		n += 1 + sovTfprofOutput(uint64(m.Parameters))
	}
	if m.FloatOps != 0 {
		n += 1 + sovTfprofOutput(uint64(m.FloatOps))
	}
	if m.TotalExecMicros != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalExecMicros))
	}
	if m.TotalRequestedBytes != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalRequestedBytes))
	}
	if m.TotalParameters != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalParameters))
	}
	if m.TotalFloatOps != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalFloatOps))
	}
	if len(m.GraphNodes) > 0 {
		for _, e := range m.GraphNodes {
			l = e.Size()
			n += 1 + l + sovTfprofOutput(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovTfprofOutput(uint64(l))
		}
	}
	if m.AcceleratorExecMicros != 0 {
		n += 1 + sovTfprofOutput(uint64(m.AcceleratorExecMicros))
	}
	if m.CpuExecMicros != 0 {
		n += 1 + sovTfprofOutput(uint64(m.CpuExecMicros))
	}
	if m.TotalAcceleratorExecMicros != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalAcceleratorExecMicros))
	}
	if m.TotalCpuExecMicros != 0 {
		n += 1 + sovTfprofOutput(uint64(m.TotalCpuExecMicros))
	}
	if m.PeakBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.PeakBytes))
	}
	if m.ResidualBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.ResidualBytes))
	}
	if m.OutputBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.OutputBytes))
	}
	if m.TotalPeakBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalPeakBytes))
	}
	if m.TotalResidualBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalResidualBytes))
	}
	if m.TotalOutputBytes != 0 {
		n += 2 + sovTfprofOutput(uint64(m.TotalOutputBytes))
	}
	return n
}

func (m *AdviceProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Checkers) > 0 {
		for k, v := range m.Checkers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTfprofOutput(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTfprofOutput(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTfprofOutput(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AdviceProto_Checker) Size() (n int) {
	var l int
	_ = l
	if len(m.Reports) > 0 {
		for _, s := range m.Reports {
			l = len(s)
			n += 1 + l + sovTfprofOutput(uint64(l))
		}
	}
	return n
}

func sovTfprofOutput(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTfprofOutput(x uint64) (n int) {
	return sovTfprofOutput(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TFProfTensorProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TFProfTensorProto{`,
		`Dtype:` + fmt.Sprintf("%v", this.Dtype) + `,`,
		`ValueDouble:` + fmt.Sprintf("%v", this.ValueDouble) + `,`,
		`ValueInt64:` + fmt.Sprintf("%v", this.ValueInt64) + `,`,
		`ValueStr:` + fmt.Sprintf("%v", this.ValueStr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GraphNodeProto) String() string {
	if this == nil {
		return "nil"
	}
	keysForInputShapes := make([]int32, 0, len(this.InputShapes))
	for k, _ := range this.InputShapes {
		keysForInputShapes = append(keysForInputShapes, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInputShapes)
	mapStringForInputShapes := "map[int32]*tensorflow.TensorShapeProto{"
	for _, k := range keysForInputShapes {
		mapStringForInputShapes += fmt.Sprintf("%v: %v,", k, this.InputShapes[k])
	}
	mapStringForInputShapes += "}"
	s := strings.Join([]string{`&GraphNodeProto{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ExecMicros:` + fmt.Sprintf("%v", this.ExecMicros) + `,`,
		`RequestedBytes:` + fmt.Sprintf("%v", this.RequestedBytes) + `,`,
		`Parameters:` + fmt.Sprintf("%v", this.Parameters) + `,`,
		`TotalExecMicros:` + fmt.Sprintf("%v", this.TotalExecMicros) + `,`,
		`TotalRequestedBytes:` + fmt.Sprintf("%v", this.TotalRequestedBytes) + `,`,
		`TotalParameters:` + fmt.Sprintf("%v", this.TotalParameters) + `,`,
		`Devices:` + fmt.Sprintf("%v", this.Devices) + `,`,
		`Shapes:` + strings.Replace(fmt.Sprintf("%v", this.Shapes), "TensorShapeProto", "tensorflow.TensorShapeProto", 1) + `,`,
		`Children:` + strings.Replace(fmt.Sprintf("%v", this.Children), "GraphNodeProto", "GraphNodeProto", 1) + `,`,
		`FloatOps:` + fmt.Sprintf("%v", this.FloatOps) + `,`,
		`TotalFloatOps:` + fmt.Sprintf("%v", this.TotalFloatOps) + `,`,
		`TensorValue:` + strings.Replace(fmt.Sprintf("%v", this.TensorValue), "TFProfTensorProto", "TFProfTensorProto", 1) + `,`,
		`InputShapes:` + mapStringForInputShapes + `,`,
		`AcceleratorExecMicros:` + fmt.Sprintf("%v", this.AcceleratorExecMicros) + `,`,
		`CpuExecMicros:` + fmt.Sprintf("%v", this.CpuExecMicros) + `,`,
		`TotalAcceleratorExecMicros:` + fmt.Sprintf("%v", this.TotalAcceleratorExecMicros) + `,`,
		`TotalCpuExecMicros:` + fmt.Sprintf("%v", this.TotalCpuExecMicros) + `,`,
		`RunCount:` + fmt.Sprintf("%v", this.RunCount) + `,`,
		`TotalRunCount:` + fmt.Sprintf("%v", this.TotalRunCount) + `,`,
		`TotalDefinitionCount:` + fmt.Sprintf("%v", this.TotalDefinitionCount) + `,`,
		`PeakBytes:` + fmt.Sprintf("%v", this.PeakBytes) + `,`,
		`ResidualBytes:` + fmt.Sprintf("%v", this.ResidualBytes) + `,`,
		`OutputBytes:` + fmt.Sprintf("%v", this.OutputBytes) + `,`,
		`TotalPeakBytes:` + fmt.Sprintf("%v", this.TotalPeakBytes) + `,`,
		`TotalResidualBytes:` + fmt.Sprintf("%v", this.TotalResidualBytes) + `,`,
		`TotalOutputBytes:` + fmt.Sprintf("%v", this.TotalOutputBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiGraphNodeProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MultiGraphNodeProto{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ExecMicros:` + fmt.Sprintf("%v", this.ExecMicros) + `,`,
		`RequestedBytes:` + fmt.Sprintf("%v", this.RequestedBytes) + `,`,
		`Parameters:` + fmt.Sprintf("%v", this.Parameters) + `,`,
		`FloatOps:` + fmt.Sprintf("%v", this.FloatOps) + `,`,
		`TotalExecMicros:` + fmt.Sprintf("%v", this.TotalExecMicros) + `,`,
		`TotalRequestedBytes:` + fmt.Sprintf("%v", this.TotalRequestedBytes) + `,`,
		`TotalParameters:` + fmt.Sprintf("%v", this.TotalParameters) + `,`,
		`TotalFloatOps:` + fmt.Sprintf("%v", this.TotalFloatOps) + `,`,
		`GraphNodes:` + strings.Replace(fmt.Sprintf("%v", this.GraphNodes), "GraphNodeProto", "GraphNodeProto", 1) + `,`,
		`Children:` + strings.Replace(fmt.Sprintf("%v", this.Children), "MultiGraphNodeProto", "MultiGraphNodeProto", 1) + `,`,
		`AcceleratorExecMicros:` + fmt.Sprintf("%v", this.AcceleratorExecMicros) + `,`,
		`CpuExecMicros:` + fmt.Sprintf("%v", this.CpuExecMicros) + `,`,
		`TotalAcceleratorExecMicros:` + fmt.Sprintf("%v", this.TotalAcceleratorExecMicros) + `,`,
		`TotalCpuExecMicros:` + fmt.Sprintf("%v", this.TotalCpuExecMicros) + `,`,
		`PeakBytes:` + fmt.Sprintf("%v", this.PeakBytes) + `,`,
		`ResidualBytes:` + fmt.Sprintf("%v", this.ResidualBytes) + `,`,
		`OutputBytes:` + fmt.Sprintf("%v", this.OutputBytes) + `,`,
		`TotalPeakBytes:` + fmt.Sprintf("%v", this.TotalPeakBytes) + `,`,
		`TotalResidualBytes:` + fmt.Sprintf("%v", this.TotalResidualBytes) + `,`,
		`TotalOutputBytes:` + fmt.Sprintf("%v", this.TotalOutputBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdviceProto) String() string {
	if this == nil {
		return "nil"
	}
	keysForCheckers := make([]string, 0, len(this.Checkers))
	for k, _ := range this.Checkers {
		keysForCheckers = append(keysForCheckers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCheckers)
	mapStringForCheckers := "map[string]*AdviceProto_Checker{"
	for _, k := range keysForCheckers {
		mapStringForCheckers += fmt.Sprintf("%v: %v,", k, this.Checkers[k])
	}
	mapStringForCheckers += "}"
	s := strings.Join([]string{`&AdviceProto{`,
		`Checkers:` + mapStringForCheckers + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdviceProto_Checker) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdviceProto_Checker{`,
		`Reports:` + fmt.Sprintf("%v", this.Reports) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTfprofOutput(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TFProfTensorProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTfprofOutput
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TFProfTensorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TFProfTensorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= (tensorflow1.DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.ValueDouble = append(m.ValueDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTfprofOutput
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTfprofOutput
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.ValueDouble = append(m.ValueDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueDouble", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTfprofOutput
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ValueInt64 = append(m.ValueInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTfprofOutput
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTfprofOutput
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTfprofOutput
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ValueInt64 = append(m.ValueInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueInt64", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueStr = append(m.ValueStr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTfprofOutput(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GraphNodeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTfprofOutput
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphNodeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphNodeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecMicros", wireType)
			}
			m.ExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedBytes", wireType)
			}
			m.RequestedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			m.Parameters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parameters |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalExecMicros", wireType)
			}
			m.TotalExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRequestedBytes", wireType)
			}
			m.TotalRequestedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRequestedBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalParameters", wireType)
			}
			m.TotalParameters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalParameters |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shapes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shapes = append(m.Shapes, &tensorflow.TensorShapeProto{})
			if err := m.Shapes[len(m.Shapes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &GraphNodeProto{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatOps", wireType)
			}
			m.FloatOps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FloatOps |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFloatOps", wireType)
			}
			m.TotalFloatOps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFloatOps |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TensorValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TensorValue == nil {
				m.TensorValue = &TFProfTensorProto{}
			}
			if err := m.TensorValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputShapes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputShapes == nil {
				m.InputShapes = make(map[int32]*tensorflow.TensorShapeProto)
			}
			var mapkey int32
			var mapvalue *tensorflow.TensorShapeProto
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTfprofOutput
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTfprofOutput
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTfprofOutput
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTfprofOutput
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTfprofOutput
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &tensorflow.TensorShapeProto{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTfprofOutput(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTfprofOutput
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InputShapes[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceleratorExecMicros", wireType)
			}
			m.AcceleratorExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceleratorExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuExecMicros", wireType)
			}
			m.CpuExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAcceleratorExecMicros", wireType)
			}
			m.TotalAcceleratorExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAcceleratorExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCpuExecMicros", wireType)
			}
			m.TotalCpuExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCpuExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunCount", wireType)
			}
			m.RunCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRunCount", wireType)
			}
			m.TotalRunCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRunCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDefinitionCount", wireType)
			}
			m.TotalDefinitionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDefinitionCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakBytes", wireType)
			}
			m.PeakBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResidualBytes", wireType)
			}
			m.ResidualBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResidualBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBytes", wireType)
			}
			m.OutputBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPeakBytes", wireType)
			}
			m.TotalPeakBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPeakBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResidualBytes", wireType)
			}
			m.TotalResidualBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalResidualBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalOutputBytes", wireType)
			}
			m.TotalOutputBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalOutputBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTfprofOutput(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiGraphNodeProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTfprofOutput
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiGraphNodeProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiGraphNodeProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecMicros", wireType)
			}
			m.ExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedBytes", wireType)
			}
			m.RequestedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			m.Parameters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parameters |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatOps", wireType)
			}
			m.FloatOps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FloatOps |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalExecMicros", wireType)
			}
			m.TotalExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRequestedBytes", wireType)
			}
			m.TotalRequestedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRequestedBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalParameters", wireType)
			}
			m.TotalParameters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalParameters |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFloatOps", wireType)
			}
			m.TotalFloatOps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFloatOps |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphNodes = append(m.GraphNodes, &GraphNodeProto{})
			if err := m.GraphNodes[len(m.GraphNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &MultiGraphNodeProto{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceleratorExecMicros", wireType)
			}
			m.AcceleratorExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceleratorExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuExecMicros", wireType)
			}
			m.CpuExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAcceleratorExecMicros", wireType)
			}
			m.TotalAcceleratorExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAcceleratorExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCpuExecMicros", wireType)
			}
			m.TotalCpuExecMicros = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCpuExecMicros |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakBytes", wireType)
			}
			m.PeakBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResidualBytes", wireType)
			}
			m.ResidualBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResidualBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBytes", wireType)
			}
			m.OutputBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPeakBytes", wireType)
			}
			m.TotalPeakBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPeakBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResidualBytes", wireType)
			}
			m.TotalResidualBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalResidualBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalOutputBytes", wireType)
			}
			m.TotalOutputBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalOutputBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTfprofOutput(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdviceProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTfprofOutput
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdviceProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdviceProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkers == nil {
				m.Checkers = make(map[string]*AdviceProto_Checker)
			}
			var mapkey string
			var mapvalue *AdviceProto_Checker
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTfprofOutput
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTfprofOutput
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTfprofOutput
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTfprofOutput
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTfprofOutput
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTfprofOutput
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AdviceProto_Checker{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTfprofOutput(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTfprofOutput
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Checkers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTfprofOutput(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdviceProto_Checker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTfprofOutput
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Checker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Checker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reports = append(m.Reports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTfprofOutput(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTfprofOutput
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTfprofOutput(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTfprofOutput
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTfprofOutput
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTfprofOutput
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTfprofOutput
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTfprofOutput(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTfprofOutput = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTfprofOutput   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/core/profiler/tfprof_output.proto", fileDescriptorTfprofOutput)
}

var fileDescriptorTfprofOutput = []byte{
	// 994 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x72, 0xdc, 0x44,
	0x10, 0xb6, 0xbc, 0xfe, 0xdb, 0xde, 0xf5, 0xfe, 0x8c, 0xd7, 0x89, 0x58, 0xc7, 0x62, 0x6d, 0x88,
	0x59, 0x52, 0xae, 0x35, 0x2c, 0x26, 0x45, 0x51, 0x70, 0xf0, 0x4f, 0x12, 0x72, 0x08, 0x71, 0x29,
	0x86, 0x13, 0x55, 0x2a, 0x59, 0x9a, 0x8d, 0x55, 0x96, 0x35, 0x62, 0x34, 0x4a, 0xd8, 0x1b, 0x8f,
	0xc0, 0x23, 0x70, 0xe4, 0xc6, 0x85, 0x87, 0xe0, 0x98, 0x23, 0x47, 0xbc, 0x5c, 0x38, 0xe6, 0x11,
	0x52, 0xd3, 0x23, 0xad, 0xa4, 0xcd, 0xc6, 0xb1, 0x73, 0xca, 0x4d, 0xf3, 0xf5, 0xd7, 0xf3, 0xb5,
	0x66, 0xba, 0x3f, 0x09, 0xbe, 0x0c, 0x39, 0x13, 0xec, 0x24, 0x1e, 0xec, 0x08, 0x1a, 0x44, 0x8c,
	0x0f, 0x7c, 0xf6, 0x7c, 0xc7, 0x61, 0x9c, 0xee, 0x84, 0x9c, 0x0d, 0x3c, 0x9f, 0xf2, 0x1d, 0x31,
	0x90, 0x8f, 0x16, 0x8b, 0x45, 0x18, 0x8b, 0x1e, 0xf2, 0x49, 0x33, 0x63, 0xf7, 0x54, 0xbc, 0xbd,
	0x3d, 0xb9, 0xc1, 0x80, 0xdb, 0xe7, 0xf4, 0x39, 0xe3, 0x67, 0xc9, 0xd6, 0x56, 0x74, 0x6a, 0x87,
	0x54, 0x6d, 0xd0, 0xbe, 0x7d, 0x09, 0x7b, 0x18, 0xd2, 0x48, 0xd1, 0x36, 0x7f, 0xd7, 0xa0, 0x79,
	0x7c, 0xff, 0x88, 0xb3, 0xc1, 0x31, 0xf2, 0x8f, 0x50, 0xfd, 0x0e, 0xcc, 0xbb, 0x92, 0xa5, 0x6b,
	0x1d, 0xad, 0x5b, 0xeb, 0xb7, 0x7a, 0xb9, 0x6a, 0x0e, 0x6d, 0x61, 0x1f, 0x0f, 0x43, 0x6a, 0x2a,
	0x0a, 0xd9, 0x80, 0xea, 0x33, 0xdb, 0x8f, 0xa9, 0xe5, 0xb2, 0xf8, 0xc4, 0xa7, 0xfa, 0x6c, 0xa7,
	0xd4, 0xd5, 0xcc, 0x0a, 0x62, 0x87, 0x08, 0x91, 0x0f, 0x41, 0x2d, 0x2d, 0x2f, 0x10, 0x77, 0x77,
	0xf5, 0x52, 0xa7, 0xd4, 0x2d, 0x99, 0x80, 0xd0, 0x43, 0x89, 0x90, 0x35, 0x28, 0x2b, 0x42, 0x24,
	0xb8, 0x3e, 0xd7, 0x29, 0x75, 0xcb, 0xe6, 0x12, 0x02, 0x4f, 0x04, 0xdf, 0xfc, 0x13, 0xa0, 0xf6,
	0x80, 0xdb, 0xe1, 0xe9, 0xf7, 0xcc, 0xa5, 0xaa, 0x3e, 0x02, 0x73, 0x81, 0x7d, 0xae, 0xca, 0x2b,
	0x9b, 0xf8, 0x2c, 0x45, 0xe8, 0x2f, 0xd4, 0xb1, 0xce, 0x3d, 0x87, 0xb3, 0x48, 0x9f, 0xed, 0x68,
	0x52, 0x44, 0x42, 0x8f, 0x10, 0x21, 0x9f, 0x40, 0x9d, 0xd3, 0x9f, 0x63, 0x1a, 0x09, 0xea, 0x5a,
	0x27, 0x43, 0x41, 0x23, 0xbd, 0x84, 0xa4, 0xda, 0x18, 0xde, 0x97, 0x28, 0x31, 0x00, 0x42, 0x5b,
	0x9e, 0x96, 0xa0, 0x3c, 0xd2, 0xe7, 0xd4, 0x46, 0x19, 0x42, 0xee, 0x40, 0x53, 0x30, 0x61, 0xfb,
	0x56, 0x5e, 0x6f, 0x01, 0x69, 0x75, 0x0c, 0xdc, 0xcb, 0x44, 0xfb, 0xb0, 0xaa, 0xb8, 0x93, 0xd2,
	0x8b, 0xc8, 0x5f, 0xc1, 0xa0, 0x59, 0xd4, 0xff, 0x14, 0x1a, 0x2a, 0x27, 0x57, 0xc5, 0x52, 0x6e,
	0xfb, 0xa3, 0xac, 0x14, 0x1d, 0x16, 0x5d, 0xfa, 0xcc, 0x73, 0x68, 0xa4, 0x03, 0x1e, 0x5b, 0xba,
	0x24, 0xbb, 0xb0, 0x80, 0xed, 0x10, 0xe9, 0x95, 0x4e, 0xa9, 0x5b, 0xe9, 0xdf, 0xca, 0xdf, 0xa1,
	0xba, 0xeb, 0x27, 0x32, 0x8e, 0x07, 0x6a, 0x26, 0x5c, 0xf2, 0x2d, 0x2c, 0x39, 0xa7, 0x9e, 0xef,
	0x72, 0x1a, 0xe8, 0x55, 0xcc, 0xdb, 0xe8, 0xbd, 0xd6, 0x89, 0xbd, 0xe2, 0x6d, 0x98, 0xe3, 0x14,
	0x79, 0x8f, 0x03, 0x9f, 0xd9, 0xc2, 0x62, 0x61, 0xa4, 0x2f, 0x63, 0xc9, 0x4b, 0x08, 0x3c, 0x0e,
	0x23, 0xb2, 0x05, 0xaa, 0x7c, 0x2b, 0xa3, 0xd4, 0x90, 0xb2, 0x8c, 0xf0, 0xfd, 0x94, 0xf7, 0x00,
	0xaa, 0x49, 0x3f, 0x63, 0x0b, 0xe8, 0xf5, 0x8e, 0xd6, 0xad, 0xf4, 0x3f, 0x9e, 0x52, 0xc7, 0x6b,
	0x8d, 0x6b, 0x56, 0x14, 0xe9, 0x47, 0x99, 0x48, 0x7e, 0x80, 0xaa, 0x17, 0x84, 0xb1, 0xb0, 0x92,
	0x83, 0x68, 0xe0, 0x0b, 0xf5, 0xdf, 0xfa, 0x42, 0xbd, 0x87, 0x32, 0x0b, 0x4f, 0x27, 0xba, 0x17,
	0x08, 0x3e, 0x34, 0x2b, 0x5e, 0x86, 0x90, 0xbb, 0x70, 0xd3, 0x76, 0x1c, 0xea, 0x53, 0x6e, 0x0b,
	0xc6, 0x0b, 0x4d, 0xd0, 0xc4, 0xf7, 0x59, 0xcd, 0x85, 0x73, 0xad, 0xb0, 0x05, 0x75, 0x27, 0x8c,
	0x0b, 0x7c, 0xa2, 0xde, 0xdf, 0x09, 0xe3, 0x1c, 0x6f, 0x0f, 0xd6, 0xd5, 0x39, 0xbd, 0x49, 0x65,
	0x05, 0xb3, 0xda, 0x48, 0xda, 0x9b, 0x2a, 0xf5, 0x79, 0xda, 0x75, 0x93, 0x82, 0x2d, 0x4c, 0x25,
	0x18, 0x3c, 0x28, 0xa8, 0xae, 0x41, 0x99, 0xc7, 0x81, 0xe5, 0xb0, 0x38, 0x10, 0xfa, 0xaa, 0xba,
	0x3a, 0x1e, 0x07, 0x07, 0x72, 0x9d, 0x5d, 0x5d, 0x46, 0xb9, 0x91, 0xbb, 0x3a, 0x33, 0xe5, 0xed,
	0xc2, 0x0d, 0xc5, 0x73, 0xe9, 0xc0, 0x0b, 0x3c, 0xe1, 0xb1, 0x94, 0x7e, 0x13, 0xe9, 0x2d, 0x8c,
	0x1e, 0x8e, 0x83, 0x2a, 0x6b, 0x1d, 0x20, 0xa4, 0xf6, 0x59, 0x32, 0x18, 0x3a, 0x32, 0xcb, 0x12,
	0x51, 0xe3, 0x70, 0x1b, 0x6a, 0x9c, 0x46, 0x9e, 0x1b, 0xdb, 0x7e, 0x42, 0xf9, 0x40, 0x69, 0xa7,
	0xa8, 0xa2, 0x6d, 0x40, 0x55, 0x39, 0x68, 0x42, 0x6a, 0x23, 0xa9, 0xa2, 0x30, 0x45, 0xe9, 0x8e,
	0x07, 0x2b, 0x93, 0x5b, 0x53, 0x16, 0xa0, 0x06, 0x6b, 0xac, 0xf9, 0x19, 0xb4, 0xd2, 0xb1, 0x2d,
	0x28, 0xdf, 0xca, 0x9d, 0x9f, 0x59, 0x90, 0xdf, 0x06, 0x85, 0x5a, 0x85, 0x22, 0xd6, 0x91, 0xaf,
	0x54, 0x1f, 0x67, 0x95, 0xb4, 0x7f, 0x82, 0xc6, 0x64, 0x93, 0x91, 0x06, 0x94, 0xce, 0xe8, 0x10,
	0x3d, 0x6d, 0xde, 0x94, 0x8f, 0xa4, 0x0f, 0xf3, 0x6a, 0x04, 0x66, 0x71, 0x04, 0x2e, 0x1f, 0x61,
	0x45, 0xfd, 0x7a, 0xf6, 0x2b, 0x6d, 0xf3, 0xaf, 0x45, 0x58, 0x79, 0x14, 0xfb, 0xc2, 0x7b, 0xaf,
	0x6c, 0xb3, 0x60, 0x0e, 0xf3, 0x13, 0xe6, 0xf0, 0x1e, 0x79, 0xea, 0x14, 0x9f, 0x2a, 0x4f, 0xf3,
	0xa9, 0x7d, 0xa8, 0x3c, 0x95, 0xe7, 0x6b, 0x05, 0xcc, 0x4d, 0xfc, 0xf7, 0x4a, 0x76, 0x09, 0x4f,
	0xd3, 0xb5, 0xdc, 0x23, 0xf3, 0x5b, 0xe5, 0xd3, 0x5b, 0x53, 0x36, 0x98, 0x72, 0x97, 0x39, 0xd3,
	0xbd, 0xc4, 0x8f, 0xaa, 0xd7, 0xf4, 0xa3, 0xe5, 0x77, 0xf2, 0xa3, 0xda, 0xbb, 0xfb, 0x51, 0xfd,
	0x8d, 0x7e, 0x54, 0x34, 0x85, 0xc6, 0xdb, 0x4d, 0xa1, 0x79, 0x15, 0x53, 0x20, 0x57, 0x33, 0x85,
	0x95, 0x6b, 0x99, 0x42, 0xeb, 0x9a, 0xa6, 0xb0, 0x3a, 0xdd, 0x14, 0x36, 0x2f, 0x34, 0xa8, 0xec,
	0xb9, 0xf2, 0xf3, 0xad, 0xc6, 0xf5, 0x3b, 0xd9, 0x1c, 0xd4, 0x39, 0x93, 0xbd, 0xaa, 0x61, 0x73,
	0x6c, 0x4f, 0x69, 0x8e, 0x5c, 0x46, 0xef, 0x20, 0xa1, 0xab, 0xaf, 0xd6, 0x38, 0xbb, 0xed, 0xc0,
	0x72, 0x21, 0x94, 0xf7, 0x9a, 0xb2, 0xf2, 0x9a, 0x6f, 0x8a, 0x5e, 0xb3, 0x75, 0x35, 0xa5, 0x9c,
	0xeb, 0xb4, 0x3f, 0x82, 0xc5, 0x04, 0x95, 0xbf, 0x25, 0x9c, 0x86, 0x8c, 0x8b, 0x08, 0x7f, 0x07,
	0xcb, 0x66, 0xba, 0xdc, 0xdf, 0x7e, 0x71, 0x61, 0xcc, 0xfc, 0x73, 0x61, 0xcc, 0xbc, 0xbc, 0x30,
	0xb4, 0x5f, 0x47, 0x86, 0xf6, 0xc7, 0xc8, 0xd0, 0xfe, 0x1e, 0x19, 0xda, 0x8b, 0x91, 0xa1, 0xfd,
	0x3b, 0x32, 0xb4, 0xff, 0x47, 0xc6, 0xcc, 0xcb, 0x91, 0xa1, 0xfd, 0xf6, 0x9f, 0x31, 0x73, 0xb2,
	0x80, 0x3f, 0xa9, 0x5f, 0xbc, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x2b, 0x6d, 0x4f, 0x61, 0x45, 0x0b,
	0x00, 0x00,
}
