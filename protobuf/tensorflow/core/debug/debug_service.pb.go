// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/core/debug/debug_service.proto

/*
	Package tensorflow is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/core/debug/debug_service.proto

	It has these top-level messages:
		EventReply
*/
package tensorflow

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import tensorflow6 "github.com/d4l3k/pok/tensorflow/core/util"

import strconv "strconv"

import fmt "fmt"
import strings "strings"
import reflect "reflect"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EventReply_DebugOpStateChange_Change int32

const (
	DISABLE EventReply_DebugOpStateChange_Change = 0
	ENABLE  EventReply_DebugOpStateChange_Change = 1
)

var EventReply_DebugOpStateChange_Change_name = map[int32]string{
	0: "DISABLE",
	1: "ENABLE",
}
var EventReply_DebugOpStateChange_Change_value = map[string]int32{
	"DISABLE": 0,
	"ENABLE":  1,
}

func (EventReply_DebugOpStateChange_Change) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorDebugService, []int{0, 0, 0}
}

// Reply message from EventListener to the client, i.e., to the source of the
// Event protocol buffers, e.g., debug ops inserted by a debugged runtime to a
// TensorFlow graph being executed.
type EventReply struct {
	DebugOpStateChanges []*EventReply_DebugOpStateChange `protobuf:"bytes,1,rep,name=debug_op_state_changes,json=debugOpStateChanges" json:"debug_op_state_changes,omitempty"`
}

func (m *EventReply) Reset()                    { *m = EventReply{} }
func (*EventReply) ProtoMessage()               {}
func (*EventReply) Descriptor() ([]byte, []int) { return fileDescriptorDebugService, []int{0} }

func (m *EventReply) GetDebugOpStateChanges() []*EventReply_DebugOpStateChange {
	if m != nil {
		return m.DebugOpStateChanges
	}
	return nil
}

type EventReply_DebugOpStateChange struct {
	Change     EventReply_DebugOpStateChange_Change `protobuf:"varint,1,opt,name=change,proto3,enum=tensorflow.EventReply_DebugOpStateChange_Change" json:"change,omitempty"`
	NodeName   string                               `protobuf:"bytes,2,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	OutputSlot int32                                `protobuf:"varint,3,opt,name=output_slot,json=outputSlot,proto3" json:"output_slot,omitempty"`
	DebugOp    string                               `protobuf:"bytes,4,opt,name=debug_op,json=debugOp,proto3" json:"debug_op,omitempty"`
}

func (m *EventReply_DebugOpStateChange) Reset()      { *m = EventReply_DebugOpStateChange{} }
func (*EventReply_DebugOpStateChange) ProtoMessage() {}
func (*EventReply_DebugOpStateChange) Descriptor() ([]byte, []int) {
	return fileDescriptorDebugService, []int{0, 0}
}

func (m *EventReply_DebugOpStateChange) GetChange() EventReply_DebugOpStateChange_Change {
	if m != nil {
		return m.Change
	}
	return DISABLE
}

func (m *EventReply_DebugOpStateChange) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *EventReply_DebugOpStateChange) GetOutputSlot() int32 {
	if m != nil {
		return m.OutputSlot
	}
	return 0
}

func (m *EventReply_DebugOpStateChange) GetDebugOp() string {
	if m != nil {
		return m.DebugOp
	}
	return ""
}

func init() {
	proto.RegisterType((*EventReply)(nil), "tensorflow.EventReply")
	proto.RegisterType((*EventReply_DebugOpStateChange)(nil), "tensorflow.EventReply.DebugOpStateChange")
	proto.RegisterEnum("tensorflow.EventReply_DebugOpStateChange_Change", EventReply_DebugOpStateChange_Change_name, EventReply_DebugOpStateChange_Change_value)
}
func (x EventReply_DebugOpStateChange_Change) String() string {
	s, ok := EventReply_DebugOpStateChange_Change_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *EventReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EventReply)
	if !ok {
		that2, ok := that.(EventReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.DebugOpStateChanges) != len(that1.DebugOpStateChanges) {
		return false
	}
	for i := range this.DebugOpStateChanges {
		if !this.DebugOpStateChanges[i].Equal(that1.DebugOpStateChanges[i]) {
			return false
		}
	}
	return true
}
func (this *EventReply_DebugOpStateChange) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EventReply_DebugOpStateChange)
	if !ok {
		that2, ok := that.(EventReply_DebugOpStateChange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Change != that1.Change {
		return false
	}
	if this.NodeName != that1.NodeName {
		return false
	}
	if this.OutputSlot != that1.OutputSlot {
		return false
	}
	if this.DebugOp != that1.DebugOp {
		return false
	}
	return true
}
func (this *EventReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow.EventReply{")
	if this.DebugOpStateChanges != nil {
		s = append(s, "DebugOpStateChanges: "+fmt.Sprintf("%#v", this.DebugOpStateChanges)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EventReply_DebugOpStateChange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow.EventReply_DebugOpStateChange{")
	s = append(s, "Change: "+fmt.Sprintf("%#v", this.Change)+",\n")
	s = append(s, "NodeName: "+fmt.Sprintf("%#v", this.NodeName)+",\n")
	s = append(s, "OutputSlot: "+fmt.Sprintf("%#v", this.OutputSlot)+",\n")
	s = append(s, "DebugOp: "+fmt.Sprintf("%#v", this.DebugOp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDebugService(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EventListener service

type EventListenerClient interface {
	// Client(s) can use this RPC method to send the EventListener Event protos.
	// The Event protos can hold information such as:
	//   1) intermediate tensors from a debugged graph being executed, which can
	//      be sent from DebugIdentity ops configured with grpc URLs.
	//   2) GraphDefs of partition graphs, which can be sent from special debug
	//      ops that get executed immediately after the beginning of the graph
	//      execution.
	SendEvents(ctx context.Context, opts ...grpc.CallOption) (EventListener_SendEventsClient, error)
}

type eventListenerClient struct {
	cc *grpc.ClientConn
}

func NewEventListenerClient(cc *grpc.ClientConn) EventListenerClient {
	return &eventListenerClient{cc}
}

func (c *eventListenerClient) SendEvents(ctx context.Context, opts ...grpc.CallOption) (EventListener_SendEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EventListener_serviceDesc.Streams[0], c.cc, "/tensorflow.EventListener/SendEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventListenerSendEventsClient{stream}
	return x, nil
}

type EventListener_SendEventsClient interface {
	Send(*tensorflow6.Event) error
	Recv() (*EventReply, error)
	grpc.ClientStream
}

type eventListenerSendEventsClient struct {
	grpc.ClientStream
}

func (x *eventListenerSendEventsClient) Send(m *tensorflow6.Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventListenerSendEventsClient) Recv() (*EventReply, error) {
	m := new(EventReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EventListener service

type EventListenerServer interface {
	// Client(s) can use this RPC method to send the EventListener Event protos.
	// The Event protos can hold information such as:
	//   1) intermediate tensors from a debugged graph being executed, which can
	//      be sent from DebugIdentity ops configured with grpc URLs.
	//   2) GraphDefs of partition graphs, which can be sent from special debug
	//      ops that get executed immediately after the beginning of the graph
	//      execution.
	SendEvents(EventListener_SendEventsServer) error
}

func RegisterEventListenerServer(s *grpc.Server, srv EventListenerServer) {
	s.RegisterService(&_EventListener_serviceDesc, srv)
}

func _EventListener_SendEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventListenerServer).SendEvents(&eventListenerSendEventsServer{stream})
}

type EventListener_SendEventsServer interface {
	Send(*EventReply) error
	Recv() (*tensorflow6.Event, error)
	grpc.ServerStream
}

type eventListenerSendEventsServer struct {
	grpc.ServerStream
}

func (x *eventListenerSendEventsServer) Send(m *EventReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventListenerSendEventsServer) Recv() (*tensorflow6.Event, error) {
	m := new(tensorflow6.Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EventListener_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tensorflow.EventListener",
	HandlerType: (*EventListenerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendEvents",
			Handler:       _EventListener_SendEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "protobuf/tensorflow/core/debug/debug_service.proto",
}

func (m *EventReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DebugOpStateChanges) > 0 {
		for _, msg := range m.DebugOpStateChanges {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDebugService(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EventReply_DebugOpStateChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReply_DebugOpStateChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Change != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDebugService(dAtA, i, uint64(m.Change))
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDebugService(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if m.OutputSlot != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDebugService(dAtA, i, uint64(m.OutputSlot))
	}
	if len(m.DebugOp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDebugService(dAtA, i, uint64(len(m.DebugOp)))
		i += copy(dAtA[i:], m.DebugOp)
	}
	return i, nil
}

func encodeFixed64DebugService(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32DebugService(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDebugService(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EventReply) Size() (n int) {
	var l int
	_ = l
	if len(m.DebugOpStateChanges) > 0 {
		for _, e := range m.DebugOpStateChanges {
			l = e.Size()
			n += 1 + l + sovDebugService(uint64(l))
		}
	}
	return n
}

func (m *EventReply_DebugOpStateChange) Size() (n int) {
	var l int
	_ = l
	if m.Change != 0 {
		n += 1 + sovDebugService(uint64(m.Change))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovDebugService(uint64(l))
	}
	if m.OutputSlot != 0 {
		n += 1 + sovDebugService(uint64(m.OutputSlot))
	}
	l = len(m.DebugOp)
	if l > 0 {
		n += 1 + l + sovDebugService(uint64(l))
	}
	return n
}

func sovDebugService(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDebugService(x uint64) (n int) {
	return sovDebugService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *EventReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EventReply{`,
		`DebugOpStateChanges:` + strings.Replace(fmt.Sprintf("%v", this.DebugOpStateChanges), "EventReply_DebugOpStateChange", "EventReply_DebugOpStateChange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventReply_DebugOpStateChange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EventReply_DebugOpStateChange{`,
		`Change:` + fmt.Sprintf("%v", this.Change) + `,`,
		`NodeName:` + fmt.Sprintf("%v", this.NodeName) + `,`,
		`OutputSlot:` + fmt.Sprintf("%v", this.OutputSlot) + `,`,
		`DebugOp:` + fmt.Sprintf("%v", this.DebugOp) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringDebugService(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *EventReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugOpStateChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDebugService
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugOpStateChanges = append(m.DebugOpStateChanges, &EventReply_DebugOpStateChange{})
			if err := m.DebugOpStateChanges[len(m.DebugOpStateChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebugService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReply_DebugOpStateChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDebugService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugOpStateChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugOpStateChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			m.Change = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Change |= (EventReply_DebugOpStateChange_Change(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSlot", wireType)
			}
			m.OutputSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputSlot |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugOp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDebugService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDebugService
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugOp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDebugService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDebugService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDebugService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDebugService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebugService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDebugService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDebugService
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDebugService
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDebugService(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDebugService = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDebugService   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/core/debug/debug_service.proto", fileDescriptorDebugService)
}

var fileDescriptorDebugService = []byte{
	// 366 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x91, 0xcf, 0xaa, 0xd3, 0x40,
	0x14, 0xc6, 0x73, 0x5a, 0x4d, 0xdb, 0x53, 0x14, 0x1d, 0xa1, 0xc4, 0x0a, 0x63, 0xec, 0x2a, 0x82,
	0x24, 0x25, 0x2e, 0x5d, 0x59, 0x5b, 0x50, 0x28, 0x15, 0x92, 0xbd, 0x21, 0x6d, 0x4e, 0x6b, 0x21,
	0xcd, 0x84, 0xcc, 0xa4, 0xe2, 0xce, 0x47, 0xf0, 0x31, 0x7c, 0x14, 0xdd, 0x75, 0x29, 0xae, 0x6c,
	0xdc, 0xb8, 0xec, 0x23, 0x5c, 0xf2, 0xe7, 0x52, 0xb8, 0xbd, 0x8b, 0xbb, 0x19, 0x66, 0x3e, 0xbe,
	0xdf, 0xf9, 0xce, 0xc7, 0xa0, 0x9b, 0x66, 0x42, 0x89, 0x65, 0xbe, 0x76, 0x14, 0x25, 0x52, 0x64,
	0xeb, 0x58, 0x7c, 0x71, 0x56, 0x22, 0x23, 0x27, 0xa2, 0x65, 0xbe, 0xa9, 0xcf, 0x40, 0x52, 0xb6,
	0xdf, 0xae, 0xc8, 0xae, 0xcc, 0x0c, 0xcf, 0xd6, 0xa1, 0x79, 0x13, 0xcb, 0xd5, 0x36, 0x76, 0x68,
	0x4f, 0x89, 0xaa, 0xdd, 0xa3, 0x5f, 0x2d, 0xc4, 0x59, 0xf9, 0xf6, 0x28, 0x8d, 0xbf, 0xb2, 0x4f,
	0x38, 0xa8, 0x67, 0x8a, 0x34, 0x90, 0x2a, 0x54, 0x14, 0xac, 0x3e, 0x87, 0xc9, 0x86, 0xa4, 0x01,
	0x66, 0xdb, 0xea, 0xbb, 0x2f, 0xed, 0xf3, 0x44, 0xfb, 0xcc, 0xd9, 0xd3, 0x12, 0xfa, 0x98, 0xfa,
	0x25, 0xf2, 0xae, 0x22, 0xbc, 0x27, 0xd1, 0x85, 0x26, 0x87, 0x7f, 0x00, 0xd9, 0xa5, 0x97, 0xbd,
	0x47, 0xbd, 0xce, 0x31, 0xc0, 0x04, 0xeb, 0xa1, 0x3b, 0xbe, 0x73, 0x8c, 0xdd, 0xa4, 0x35, 0x3c,
	0x7b, 0x86, 0xbd, 0x44, 0x44, 0x14, 0x24, 0xe1, 0x8e, 0x8c, 0x96, 0x09, 0x56, 0xcf, 0xeb, 0x96,
	0xc2, 0x22, 0xdc, 0x11, 0x7b, 0x8e, 0x7d, 0x91, 0xab, 0x34, 0x57, 0x81, 0x8c, 0x85, 0x32, 0xda,
	0x26, 0x58, 0xf7, 0x3d, 0xac, 0x25, 0x3f, 0x16, 0x8a, 0x3d, 0xc5, 0xee, 0x75, 0x7d, 0xe3, 0x5e,
	0x05, 0x77, 0x9a, 0x16, 0xa3, 0x17, 0xa8, 0x37, 0xcb, 0xf6, 0xb1, 0x33, 0xfd, 0xe0, 0xbf, 0x9d,
	0xcc, 0x67, 0x8f, 0x34, 0x86, 0xa8, 0xcf, 0x16, 0xd5, 0x1d, 0xdc, 0x39, 0x3e, 0xa8, 0x76, 0x9d,
	0x6f, 0xa5, 0xa2, 0x84, 0x32, 0xf6, 0x06, 0xd1, 0xa7, 0x24, 0xaa, 0x44, 0xc9, 0x1e, 0x5f, 0x94,
	0x1a, 0x0e, 0x6e, 0xef, 0x69, 0xc1, 0x18, 0x26, 0xaf, 0x0e, 0x47, 0xae, 0xfd, 0x3e, 0x72, 0xed,
	0x74, 0xe4, 0xf0, 0xad, 0xe0, 0xf0, 0xa3, 0xe0, 0xf0, 0xb3, 0xe0, 0x70, 0x28, 0x38, 0xfc, 0x2d,
	0x38, 0xfc, 0x2f, 0xb8, 0x76, 0x2a, 0x38, 0x7c, 0xff, 0xc7, 0xb5, 0xa5, 0x5e, 0x7d, 0xe7, 0xeb,
	0xab, 0x00, 0x00, 0x00, 0xff, 0xff, 0x27, 0x85, 0x9b, 0x78, 0x32, 0x02, 0x00, 0x00,
}
