// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/contrib/boosted_trees/proto/learner.proto

/*
	Package tensorflow_boosted_trees_learner is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/contrib/boosted_trees/proto/learner.proto

	It has these top-level messages:
		TreeRegularizationConfig
		TreeConstraintsConfig
		LearningRateConfig
		LearningRateFixedConfig
		LearningRateLineSearchConfig
		AveragingConfig
		LearningRateDropoutDrivenConfig
		LearnerConfig
*/
package tensorflow_boosted_trees_learner

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strconv "strconv"

import fmt "fmt"
import strings "strings"
import reflect "reflect"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type LearnerConfig_PruningMode int32

const (
	PRE_PRUNE  LearnerConfig_PruningMode = 0
	POST_PRUNE LearnerConfig_PruningMode = 1
)

var LearnerConfig_PruningMode_name = map[int32]string{
	0: "PRE_PRUNE",
	1: "POST_PRUNE",
}
var LearnerConfig_PruningMode_value = map[string]int32{
	"PRE_PRUNE":  0,
	"POST_PRUNE": 1,
}

func (LearnerConfig_PruningMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorLearner, []int{7, 0}
}

type LearnerConfig_GrowingMode int32

const (
	WHOLE_TREE LearnerConfig_GrowingMode = 0
	// Layer by layer is only supported by the batch learner.
	LAYER_BY_LAYER LearnerConfig_GrowingMode = 1
)

var LearnerConfig_GrowingMode_name = map[int32]string{
	0: "WHOLE_TREE",
	1: "LAYER_BY_LAYER",
}
var LearnerConfig_GrowingMode_value = map[string]int32{
	"WHOLE_TREE":     0,
	"LAYER_BY_LAYER": 1,
}

func (LearnerConfig_GrowingMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorLearner, []int{7, 1}
}

type LearnerConfig_MultiClassStrategy int32

const (
	TREE_PER_CLASS   LearnerConfig_MultiClassStrategy = 0
	FULL_HESSIAN     LearnerConfig_MultiClassStrategy = 1
	DIAGONAL_HESSIAN LearnerConfig_MultiClassStrategy = 2
)

var LearnerConfig_MultiClassStrategy_name = map[int32]string{
	0: "TREE_PER_CLASS",
	1: "FULL_HESSIAN",
	2: "DIAGONAL_HESSIAN",
}
var LearnerConfig_MultiClassStrategy_value = map[string]int32{
	"TREE_PER_CLASS":   0,
	"FULL_HESSIAN":     1,
	"DIAGONAL_HESSIAN": 2,
}

func (LearnerConfig_MultiClassStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorLearner, []int{7, 2}
}

// Tree regularization config.
type TreeRegularizationConfig struct {
	// Classic L1/L2.
	L1 float32 `protobuf:"fixed32,1,opt,name=l1,proto3" json:"l1,omitempty"`
	L2 float32 `protobuf:"fixed32,2,opt,name=l2,proto3" json:"l2,omitempty"`
	// Tree complexity penalizes overall model complexity effectively
	// limiting how deep the tree can grow in regions with small gain.
	TreeComplexity float32 `protobuf:"fixed32,3,opt,name=tree_complexity,json=treeComplexity,proto3" json:"tree_complexity,omitempty"`
}

func (m *TreeRegularizationConfig) Reset()                    { *m = TreeRegularizationConfig{} }
func (*TreeRegularizationConfig) ProtoMessage()               {}
func (*TreeRegularizationConfig) Descriptor() ([]byte, []int) { return fileDescriptorLearner, []int{0} }

func (m *TreeRegularizationConfig) GetL1() float32 {
	if m != nil {
		return m.L1
	}
	return 0
}

func (m *TreeRegularizationConfig) GetL2() float32 {
	if m != nil {
		return m.L2
	}
	return 0
}

func (m *TreeRegularizationConfig) GetTreeComplexity() float32 {
	if m != nil {
		return m.TreeComplexity
	}
	return 0
}

// Tree constraints config.
type TreeConstraintsConfig struct {
	// Maximum depth of the trees.
	MaxTreeDepth uint32 `protobuf:"varint,1,opt,name=max_tree_depth,json=maxTreeDepth,proto3" json:"max_tree_depth,omitempty"`
	// Min hessian weight per node.
	MinNodeWeight float32 `protobuf:"fixed32,2,opt,name=min_node_weight,json=minNodeWeight,proto3" json:"min_node_weight,omitempty"`
}

func (m *TreeConstraintsConfig) Reset()                    { *m = TreeConstraintsConfig{} }
func (*TreeConstraintsConfig) ProtoMessage()               {}
func (*TreeConstraintsConfig) Descriptor() ([]byte, []int) { return fileDescriptorLearner, []int{1} }

func (m *TreeConstraintsConfig) GetMaxTreeDepth() uint32 {
	if m != nil {
		return m.MaxTreeDepth
	}
	return 0
}

func (m *TreeConstraintsConfig) GetMinNodeWeight() float32 {
	if m != nil {
		return m.MinNodeWeight
	}
	return 0
}

// LearningRateConfig describes all supported learning rate tuners.
type LearningRateConfig struct {
	// Types that are valid to be assigned to Tuner:
	//	*LearningRateConfig_Fixed
	//	*LearningRateConfig_Dropout
	//	*LearningRateConfig_LineSearch
	Tuner isLearningRateConfig_Tuner `protobuf_oneof:"tuner"`
}

func (m *LearningRateConfig) Reset()                    { *m = LearningRateConfig{} }
func (*LearningRateConfig) ProtoMessage()               {}
func (*LearningRateConfig) Descriptor() ([]byte, []int) { return fileDescriptorLearner, []int{2} }

type isLearningRateConfig_Tuner interface {
	isLearningRateConfig_Tuner()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LearningRateConfig_Fixed struct {
	Fixed *LearningRateFixedConfig `protobuf:"bytes,1,opt,name=fixed,oneof"`
}
type LearningRateConfig_Dropout struct {
	Dropout *LearningRateDropoutDrivenConfig `protobuf:"bytes,2,opt,name=dropout,oneof"`
}
type LearningRateConfig_LineSearch struct {
	LineSearch *LearningRateLineSearchConfig `protobuf:"bytes,3,opt,name=line_search,json=lineSearch,oneof"`
}

func (*LearningRateConfig_Fixed) isLearningRateConfig_Tuner()      {}
func (*LearningRateConfig_Dropout) isLearningRateConfig_Tuner()    {}
func (*LearningRateConfig_LineSearch) isLearningRateConfig_Tuner() {}

func (m *LearningRateConfig) GetTuner() isLearningRateConfig_Tuner {
	if m != nil {
		return m.Tuner
	}
	return nil
}

func (m *LearningRateConfig) GetFixed() *LearningRateFixedConfig {
	if x, ok := m.GetTuner().(*LearningRateConfig_Fixed); ok {
		return x.Fixed
	}
	return nil
}

func (m *LearningRateConfig) GetDropout() *LearningRateDropoutDrivenConfig {
	if x, ok := m.GetTuner().(*LearningRateConfig_Dropout); ok {
		return x.Dropout
	}
	return nil
}

func (m *LearningRateConfig) GetLineSearch() *LearningRateLineSearchConfig {
	if x, ok := m.GetTuner().(*LearningRateConfig_LineSearch); ok {
		return x.LineSearch
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LearningRateConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LearningRateConfig_OneofMarshaler, _LearningRateConfig_OneofUnmarshaler, _LearningRateConfig_OneofSizer, []interface{}{
		(*LearningRateConfig_Fixed)(nil),
		(*LearningRateConfig_Dropout)(nil),
		(*LearningRateConfig_LineSearch)(nil),
	}
}

func _LearningRateConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LearningRateConfig)
	// tuner
	switch x := m.Tuner.(type) {
	case *LearningRateConfig_Fixed:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Fixed); err != nil {
			return err
		}
	case *LearningRateConfig_Dropout:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dropout); err != nil {
			return err
		}
	case *LearningRateConfig_LineSearch:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LineSearch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LearningRateConfig.Tuner has unexpected type %T", x)
	}
	return nil
}

func _LearningRateConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LearningRateConfig)
	switch tag {
	case 1: // tuner.fixed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LearningRateFixedConfig)
		err := b.DecodeMessage(msg)
		m.Tuner = &LearningRateConfig_Fixed{msg}
		return true, err
	case 2: // tuner.dropout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LearningRateDropoutDrivenConfig)
		err := b.DecodeMessage(msg)
		m.Tuner = &LearningRateConfig_Dropout{msg}
		return true, err
	case 3: // tuner.line_search
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LearningRateLineSearchConfig)
		err := b.DecodeMessage(msg)
		m.Tuner = &LearningRateConfig_LineSearch{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LearningRateConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LearningRateConfig)
	// tuner
	switch x := m.Tuner.(type) {
	case *LearningRateConfig_Fixed:
		s := proto.Size(x.Fixed)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LearningRateConfig_Dropout:
		s := proto.Size(x.Dropout)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LearningRateConfig_LineSearch:
		s := proto.Size(x.LineSearch)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Config for a fixed learning rate.
type LearningRateFixedConfig struct {
	LearningRate float32 `protobuf:"fixed32,1,opt,name=learning_rate,json=learningRate,proto3" json:"learning_rate,omitempty"`
}

func (m *LearningRateFixedConfig) Reset()                    { *m = LearningRateFixedConfig{} }
func (*LearningRateFixedConfig) ProtoMessage()               {}
func (*LearningRateFixedConfig) Descriptor() ([]byte, []int) { return fileDescriptorLearner, []int{3} }

func (m *LearningRateFixedConfig) GetLearningRate() float32 {
	if m != nil {
		return m.LearningRate
	}
	return 0
}

// Config for a tuned learning rate.
type LearningRateLineSearchConfig struct {
	// Max learning rate. Must be strictly positive.
	MaxLearningRate float32 `protobuf:"fixed32,1,opt,name=max_learning_rate,json=maxLearningRate,proto3" json:"max_learning_rate,omitempty"`
	// Number of learning rate values to consider between [0, max_learning_rate).
	NumSteps int32 `protobuf:"varint,2,opt,name=num_steps,json=numSteps,proto3" json:"num_steps,omitempty"`
}

func (m *LearningRateLineSearchConfig) Reset()      { *m = LearningRateLineSearchConfig{} }
func (*LearningRateLineSearchConfig) ProtoMessage() {}
func (*LearningRateLineSearchConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorLearner, []int{4}
}

func (m *LearningRateLineSearchConfig) GetMaxLearningRate() float32 {
	if m != nil {
		return m.MaxLearningRate
	}
	return 0
}

func (m *LearningRateLineSearchConfig) GetNumSteps() int32 {
	if m != nil {
		return m.NumSteps
	}
	return 0
}

// When we have a sequence of trees 1, 2, 3 ... n, these essentially represent
// weights updates in functional space, and thus we can use averaging of weight
// updates to achieve better performance. For example, we can say that our final
// ensemble will be an average of ensembles of tree 1, and ensemble of tree 1
// and tree 2 etc .. ensemble of all trees.
// Note that this averaging will apply ONLY DURING PREDICTION. The training
// stays the same.
type AveragingConfig struct {
	// Types that are valid to be assigned to Config:
	//	*AveragingConfig_AverageLastNTrees
	//	*AveragingConfig_AverageLastPercentTrees
	Config isAveragingConfig_Config `protobuf_oneof:"config"`
}

func (m *AveragingConfig) Reset()                    { *m = AveragingConfig{} }
func (*AveragingConfig) ProtoMessage()               {}
func (*AveragingConfig) Descriptor() ([]byte, []int) { return fileDescriptorLearner, []int{5} }

type isAveragingConfig_Config interface {
	isAveragingConfig_Config()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AveragingConfig_AverageLastNTrees struct {
	AverageLastNTrees float32 `protobuf:"fixed32,1,opt,name=average_last_n_trees,json=averageLastNTrees,proto3,oneof"`
}
type AveragingConfig_AverageLastPercentTrees struct {
	AverageLastPercentTrees float32 `protobuf:"fixed32,2,opt,name=average_last_percent_trees,json=averageLastPercentTrees,proto3,oneof"`
}

func (*AveragingConfig_AverageLastNTrees) isAveragingConfig_Config()       {}
func (*AveragingConfig_AverageLastPercentTrees) isAveragingConfig_Config() {}

func (m *AveragingConfig) GetConfig() isAveragingConfig_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *AveragingConfig) GetAverageLastNTrees() float32 {
	if x, ok := m.GetConfig().(*AveragingConfig_AverageLastNTrees); ok {
		return x.AverageLastNTrees
	}
	return 0
}

func (m *AveragingConfig) GetAverageLastPercentTrees() float32 {
	if x, ok := m.GetConfig().(*AveragingConfig_AverageLastPercentTrees); ok {
		return x.AverageLastPercentTrees
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AveragingConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AveragingConfig_OneofMarshaler, _AveragingConfig_OneofUnmarshaler, _AveragingConfig_OneofSizer, []interface{}{
		(*AveragingConfig_AverageLastNTrees)(nil),
		(*AveragingConfig_AverageLastPercentTrees)(nil),
	}
}

func _AveragingConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AveragingConfig)
	// config
	switch x := m.Config.(type) {
	case *AveragingConfig_AverageLastNTrees:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.AverageLastNTrees)))
	case *AveragingConfig_AverageLastPercentTrees:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.AverageLastPercentTrees)))
	case nil:
	default:
		return fmt.Errorf("AveragingConfig.Config has unexpected type %T", x)
	}
	return nil
}

func _AveragingConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AveragingConfig)
	switch tag {
	case 1: // config.average_last_n_trees
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Config = &AveragingConfig_AverageLastNTrees{math.Float32frombits(uint32(x))}
		return true, err
	case 2: // config.average_last_percent_trees
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Config = &AveragingConfig_AverageLastPercentTrees{math.Float32frombits(uint32(x))}
		return true, err
	default:
		return false, nil
	}
}

func _AveragingConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AveragingConfig)
	// config
	switch x := m.Config.(type) {
	case *AveragingConfig_AverageLastNTrees:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *AveragingConfig_AverageLastPercentTrees:
		n += proto.SizeVarint(2<<3 | proto.WireFixed32)
		n += 4
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type LearningRateDropoutDrivenConfig struct {
	// Probability of dropping each tree in an existing so far ensemble.
	DropoutProbability float32 `protobuf:"fixed32,1,opt,name=dropout_probability,json=dropoutProbability,proto3" json:"dropout_probability,omitempty"`
	// When trees are built after dropout happen, they don't "advance" to the
	// optimal solution, they just rearrange the path. However you can still
	// choose to skip dropout periodically, to allow a new tree that "advances"
	// to be added.
	// For example, if running for 200 steps with probability of dropout 1/100,
	// you would expect the dropout to start happening for sure for all iterations
	// after 100. However you can add probability_of_skipping_dropout of 0.1, this
	// way iterations 100-200 will include approx 90 iterations of dropout and 10
	// iterations of normal steps.Set it to 0 if you want just keep building
	// the refinement trees after dropout kicks in.
	ProbabilityOfSkippingDropout float32 `protobuf:"fixed32,2,opt,name=probability_of_skipping_dropout,json=probabilityOfSkippingDropout,proto3" json:"probability_of_skipping_dropout,omitempty"`
	// Between 0 and 1.
	LearningRate float32 `protobuf:"fixed32,3,opt,name=learning_rate,json=learningRate,proto3" json:"learning_rate,omitempty"`
}

func (m *LearningRateDropoutDrivenConfig) Reset()      { *m = LearningRateDropoutDrivenConfig{} }
func (*LearningRateDropoutDrivenConfig) ProtoMessage() {}
func (*LearningRateDropoutDrivenConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorLearner, []int{6}
}

func (m *LearningRateDropoutDrivenConfig) GetDropoutProbability() float32 {
	if m != nil {
		return m.DropoutProbability
	}
	return 0
}

func (m *LearningRateDropoutDrivenConfig) GetProbabilityOfSkippingDropout() float32 {
	if m != nil {
		return m.ProbabilityOfSkippingDropout
	}
	return 0
}

func (m *LearningRateDropoutDrivenConfig) GetLearningRate() float32 {
	if m != nil {
		return m.LearningRate
	}
	return 0
}

type LearnerConfig struct {
	// Number of classes.
	NumClasses uint32 `protobuf:"varint,1,opt,name=num_classes,json=numClasses,proto3" json:"num_classes,omitempty"`
	// Fraction of features to consider in each tree sampled randomly
	// from all available features.
	//
	// Types that are valid to be assigned to FeatureFraction:
	//	*LearnerConfig_FeatureFractionPerTree
	//	*LearnerConfig_FeatureFractionPerLevel
	FeatureFraction isLearnerConfig_FeatureFraction `protobuf_oneof:"feature_fraction"`
	// Regularization.
	Regularization *TreeRegularizationConfig `protobuf:"bytes,4,opt,name=regularization" json:"regularization,omitempty"`
	// Constraints.
	Constraints *TreeConstraintsConfig `protobuf:"bytes,5,opt,name=constraints" json:"constraints,omitempty"`
	// Pruning.
	PruningMode LearnerConfig_PruningMode `protobuf:"varint,8,opt,name=pruning_mode,json=pruningMode,proto3,enum=tensorflow.boosted_trees.learner.LearnerConfig_PruningMode" json:"pruning_mode,omitempty"`
	// Growing Mode.
	GrowingMode LearnerConfig_GrowingMode `protobuf:"varint,9,opt,name=growing_mode,json=growingMode,proto3,enum=tensorflow.boosted_trees.learner.LearnerConfig_GrowingMode" json:"growing_mode,omitempty"`
	// Learning rate.
	LearningRateTuner *LearningRateConfig `protobuf:"bytes,6,opt,name=learning_rate_tuner,json=learningRateTuner" json:"learning_rate_tuner,omitempty"`
	// Multi-class strategy.
	MultiClassStrategy LearnerConfig_MultiClassStrategy `protobuf:"varint,10,opt,name=multi_class_strategy,json=multiClassStrategy,proto3,enum=tensorflow.boosted_trees.learner.LearnerConfig_MultiClassStrategy" json:"multi_class_strategy,omitempty"`
	// If you want to average the ensembles (for regularization), provide the
	// config below.
	AveragingConfig *AveragingConfig `protobuf:"bytes,11,opt,name=averaging_config,json=averagingConfig" json:"averaging_config,omitempty"`
}

func (m *LearnerConfig) Reset()                    { *m = LearnerConfig{} }
func (*LearnerConfig) ProtoMessage()               {}
func (*LearnerConfig) Descriptor() ([]byte, []int) { return fileDescriptorLearner, []int{7} }

type isLearnerConfig_FeatureFraction interface {
	isLearnerConfig_FeatureFraction()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LearnerConfig_FeatureFractionPerTree struct {
	FeatureFractionPerTree float32 `protobuf:"fixed32,2,opt,name=feature_fraction_per_tree,json=featureFractionPerTree,proto3,oneof"`
}
type LearnerConfig_FeatureFractionPerLevel struct {
	FeatureFractionPerLevel float32 `protobuf:"fixed32,3,opt,name=feature_fraction_per_level,json=featureFractionPerLevel,proto3,oneof"`
}

func (*LearnerConfig_FeatureFractionPerTree) isLearnerConfig_FeatureFraction()  {}
func (*LearnerConfig_FeatureFractionPerLevel) isLearnerConfig_FeatureFraction() {}

func (m *LearnerConfig) GetFeatureFraction() isLearnerConfig_FeatureFraction {
	if m != nil {
		return m.FeatureFraction
	}
	return nil
}

func (m *LearnerConfig) GetNumClasses() uint32 {
	if m != nil {
		return m.NumClasses
	}
	return 0
}

func (m *LearnerConfig) GetFeatureFractionPerTree() float32 {
	if x, ok := m.GetFeatureFraction().(*LearnerConfig_FeatureFractionPerTree); ok {
		return x.FeatureFractionPerTree
	}
	return 0
}

func (m *LearnerConfig) GetFeatureFractionPerLevel() float32 {
	if x, ok := m.GetFeatureFraction().(*LearnerConfig_FeatureFractionPerLevel); ok {
		return x.FeatureFractionPerLevel
	}
	return 0
}

func (m *LearnerConfig) GetRegularization() *TreeRegularizationConfig {
	if m != nil {
		return m.Regularization
	}
	return nil
}

func (m *LearnerConfig) GetConstraints() *TreeConstraintsConfig {
	if m != nil {
		return m.Constraints
	}
	return nil
}

func (m *LearnerConfig) GetPruningMode() LearnerConfig_PruningMode {
	if m != nil {
		return m.PruningMode
	}
	return PRE_PRUNE
}

func (m *LearnerConfig) GetGrowingMode() LearnerConfig_GrowingMode {
	if m != nil {
		return m.GrowingMode
	}
	return WHOLE_TREE
}

func (m *LearnerConfig) GetLearningRateTuner() *LearningRateConfig {
	if m != nil {
		return m.LearningRateTuner
	}
	return nil
}

func (m *LearnerConfig) GetMultiClassStrategy() LearnerConfig_MultiClassStrategy {
	if m != nil {
		return m.MultiClassStrategy
	}
	return TREE_PER_CLASS
}

func (m *LearnerConfig) GetAveragingConfig() *AveragingConfig {
	if m != nil {
		return m.AveragingConfig
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LearnerConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LearnerConfig_OneofMarshaler, _LearnerConfig_OneofUnmarshaler, _LearnerConfig_OneofSizer, []interface{}{
		(*LearnerConfig_FeatureFractionPerTree)(nil),
		(*LearnerConfig_FeatureFractionPerLevel)(nil),
	}
}

func _LearnerConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LearnerConfig)
	// feature_fraction
	switch x := m.FeatureFraction.(type) {
	case *LearnerConfig_FeatureFractionPerTree:
		_ = b.EncodeVarint(2<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.FeatureFractionPerTree)))
	case *LearnerConfig_FeatureFractionPerLevel:
		_ = b.EncodeVarint(3<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.FeatureFractionPerLevel)))
	case nil:
	default:
		return fmt.Errorf("LearnerConfig.FeatureFraction has unexpected type %T", x)
	}
	return nil
}

func _LearnerConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LearnerConfig)
	switch tag {
	case 2: // feature_fraction.feature_fraction_per_tree
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.FeatureFraction = &LearnerConfig_FeatureFractionPerTree{math.Float32frombits(uint32(x))}
		return true, err
	case 3: // feature_fraction.feature_fraction_per_level
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.FeatureFraction = &LearnerConfig_FeatureFractionPerLevel{math.Float32frombits(uint32(x))}
		return true, err
	default:
		return false, nil
	}
}

func _LearnerConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LearnerConfig)
	// feature_fraction
	switch x := m.FeatureFraction.(type) {
	case *LearnerConfig_FeatureFractionPerTree:
		n += proto.SizeVarint(2<<3 | proto.WireFixed32)
		n += 4
	case *LearnerConfig_FeatureFractionPerLevel:
		n += proto.SizeVarint(3<<3 | proto.WireFixed32)
		n += 4
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*TreeRegularizationConfig)(nil), "tensorflow.boosted_trees.learner.TreeRegularizationConfig")
	proto.RegisterType((*TreeConstraintsConfig)(nil), "tensorflow.boosted_trees.learner.TreeConstraintsConfig")
	proto.RegisterType((*LearningRateConfig)(nil), "tensorflow.boosted_trees.learner.LearningRateConfig")
	proto.RegisterType((*LearningRateFixedConfig)(nil), "tensorflow.boosted_trees.learner.LearningRateFixedConfig")
	proto.RegisterType((*LearningRateLineSearchConfig)(nil), "tensorflow.boosted_trees.learner.LearningRateLineSearchConfig")
	proto.RegisterType((*AveragingConfig)(nil), "tensorflow.boosted_trees.learner.AveragingConfig")
	proto.RegisterType((*LearningRateDropoutDrivenConfig)(nil), "tensorflow.boosted_trees.learner.LearningRateDropoutDrivenConfig")
	proto.RegisterType((*LearnerConfig)(nil), "tensorflow.boosted_trees.learner.LearnerConfig")
	proto.RegisterEnum("tensorflow.boosted_trees.learner.LearnerConfig_PruningMode", LearnerConfig_PruningMode_name, LearnerConfig_PruningMode_value)
	proto.RegisterEnum("tensorflow.boosted_trees.learner.LearnerConfig_GrowingMode", LearnerConfig_GrowingMode_name, LearnerConfig_GrowingMode_value)
	proto.RegisterEnum("tensorflow.boosted_trees.learner.LearnerConfig_MultiClassStrategy", LearnerConfig_MultiClassStrategy_name, LearnerConfig_MultiClassStrategy_value)
}
func (x LearnerConfig_PruningMode) String() string {
	s, ok := LearnerConfig_PruningMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LearnerConfig_GrowingMode) String() string {
	s, ok := LearnerConfig_GrowingMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LearnerConfig_MultiClassStrategy) String() string {
	s, ok := LearnerConfig_MultiClassStrategy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TreeRegularizationConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeRegularizationConfig)
	if !ok {
		that2, ok := that.(TreeRegularizationConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.L1 != that1.L1 {
		return false
	}
	if this.L2 != that1.L2 {
		return false
	}
	if this.TreeComplexity != that1.TreeComplexity {
		return false
	}
	return true
}
func (this *TreeConstraintsConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeConstraintsConfig)
	if !ok {
		that2, ok := that.(TreeConstraintsConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.MaxTreeDepth != that1.MaxTreeDepth {
		return false
	}
	if this.MinNodeWeight != that1.MinNodeWeight {
		return false
	}
	return true
}
func (this *LearningRateConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearningRateConfig)
	if !ok {
		that2, ok := that.(LearningRateConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Tuner == nil {
		if this.Tuner != nil {
			return false
		}
	} else if this.Tuner == nil {
		return false
	} else if !this.Tuner.Equal(that1.Tuner) {
		return false
	}
	return true
}
func (this *LearningRateConfig_Fixed) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearningRateConfig_Fixed)
	if !ok {
		that2, ok := that.(LearningRateConfig_Fixed)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Fixed.Equal(that1.Fixed) {
		return false
	}
	return true
}
func (this *LearningRateConfig_Dropout) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearningRateConfig_Dropout)
	if !ok {
		that2, ok := that.(LearningRateConfig_Dropout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Dropout.Equal(that1.Dropout) {
		return false
	}
	return true
}
func (this *LearningRateConfig_LineSearch) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearningRateConfig_LineSearch)
	if !ok {
		that2, ok := that.(LearningRateConfig_LineSearch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.LineSearch.Equal(that1.LineSearch) {
		return false
	}
	return true
}
func (this *LearningRateFixedConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearningRateFixedConfig)
	if !ok {
		that2, ok := that.(LearningRateFixedConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LearningRate != that1.LearningRate {
		return false
	}
	return true
}
func (this *LearningRateLineSearchConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearningRateLineSearchConfig)
	if !ok {
		that2, ok := that.(LearningRateLineSearchConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.MaxLearningRate != that1.MaxLearningRate {
		return false
	}
	if this.NumSteps != that1.NumSteps {
		return false
	}
	return true
}
func (this *AveragingConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AveragingConfig)
	if !ok {
		that2, ok := that.(AveragingConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Config == nil {
		if this.Config != nil {
			return false
		}
	} else if this.Config == nil {
		return false
	} else if !this.Config.Equal(that1.Config) {
		return false
	}
	return true
}
func (this *AveragingConfig_AverageLastNTrees) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AveragingConfig_AverageLastNTrees)
	if !ok {
		that2, ok := that.(AveragingConfig_AverageLastNTrees)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.AverageLastNTrees != that1.AverageLastNTrees {
		return false
	}
	return true
}
func (this *AveragingConfig_AverageLastPercentTrees) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AveragingConfig_AverageLastPercentTrees)
	if !ok {
		that2, ok := that.(AveragingConfig_AverageLastPercentTrees)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.AverageLastPercentTrees != that1.AverageLastPercentTrees {
		return false
	}
	return true
}
func (this *LearningRateDropoutDrivenConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearningRateDropoutDrivenConfig)
	if !ok {
		that2, ok := that.(LearningRateDropoutDrivenConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.DropoutProbability != that1.DropoutProbability {
		return false
	}
	if this.ProbabilityOfSkippingDropout != that1.ProbabilityOfSkippingDropout {
		return false
	}
	if this.LearningRate != that1.LearningRate {
		return false
	}
	return true
}
func (this *LearnerConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearnerConfig)
	if !ok {
		that2, ok := that.(LearnerConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NumClasses != that1.NumClasses {
		return false
	}
	if that1.FeatureFraction == nil {
		if this.FeatureFraction != nil {
			return false
		}
	} else if this.FeatureFraction == nil {
		return false
	} else if !this.FeatureFraction.Equal(that1.FeatureFraction) {
		return false
	}
	if !this.Regularization.Equal(that1.Regularization) {
		return false
	}
	if !this.Constraints.Equal(that1.Constraints) {
		return false
	}
	if this.PruningMode != that1.PruningMode {
		return false
	}
	if this.GrowingMode != that1.GrowingMode {
		return false
	}
	if !this.LearningRateTuner.Equal(that1.LearningRateTuner) {
		return false
	}
	if this.MultiClassStrategy != that1.MultiClassStrategy {
		return false
	}
	if !this.AveragingConfig.Equal(that1.AveragingConfig) {
		return false
	}
	return true
}
func (this *LearnerConfig_FeatureFractionPerTree) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearnerConfig_FeatureFractionPerTree)
	if !ok {
		that2, ok := that.(LearnerConfig_FeatureFractionPerTree)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FeatureFractionPerTree != that1.FeatureFractionPerTree {
		return false
	}
	return true
}
func (this *LearnerConfig_FeatureFractionPerLevel) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearnerConfig_FeatureFractionPerLevel)
	if !ok {
		that2, ok := that.(LearnerConfig_FeatureFractionPerLevel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FeatureFractionPerLevel != that1.FeatureFractionPerLevel {
		return false
	}
	return true
}
func (this *TreeRegularizationConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_boosted_trees_learner.TreeRegularizationConfig{")
	s = append(s, "L1: "+fmt.Sprintf("%#v", this.L1)+",\n")
	s = append(s, "L2: "+fmt.Sprintf("%#v", this.L2)+",\n")
	s = append(s, "TreeComplexity: "+fmt.Sprintf("%#v", this.TreeComplexity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreeConstraintsConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_boosted_trees_learner.TreeConstraintsConfig{")
	s = append(s, "MaxTreeDepth: "+fmt.Sprintf("%#v", this.MaxTreeDepth)+",\n")
	s = append(s, "MinNodeWeight: "+fmt.Sprintf("%#v", this.MinNodeWeight)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LearningRateConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_boosted_trees_learner.LearningRateConfig{")
	if this.Tuner != nil {
		s = append(s, "Tuner: "+fmt.Sprintf("%#v", this.Tuner)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LearningRateConfig_Fixed) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_learner.LearningRateConfig_Fixed{` +
		`Fixed:` + fmt.Sprintf("%#v", this.Fixed) + `}`}, ", ")
	return s
}
func (this *LearningRateConfig_Dropout) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_learner.LearningRateConfig_Dropout{` +
		`Dropout:` + fmt.Sprintf("%#v", this.Dropout) + `}`}, ", ")
	return s
}
func (this *LearningRateConfig_LineSearch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_learner.LearningRateConfig_LineSearch{` +
		`LineSearch:` + fmt.Sprintf("%#v", this.LineSearch) + `}`}, ", ")
	return s
}
func (this *LearningRateFixedConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_boosted_trees_learner.LearningRateFixedConfig{")
	s = append(s, "LearningRate: "+fmt.Sprintf("%#v", this.LearningRate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LearningRateLineSearchConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_boosted_trees_learner.LearningRateLineSearchConfig{")
	s = append(s, "MaxLearningRate: "+fmt.Sprintf("%#v", this.MaxLearningRate)+",\n")
	s = append(s, "NumSteps: "+fmt.Sprintf("%#v", this.NumSteps)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AveragingConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_boosted_trees_learner.AveragingConfig{")
	if this.Config != nil {
		s = append(s, "Config: "+fmt.Sprintf("%#v", this.Config)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AveragingConfig_AverageLastNTrees) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_learner.AveragingConfig_AverageLastNTrees{` +
		`AverageLastNTrees:` + fmt.Sprintf("%#v", this.AverageLastNTrees) + `}`}, ", ")
	return s
}
func (this *AveragingConfig_AverageLastPercentTrees) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_learner.AveragingConfig_AverageLastPercentTrees{` +
		`AverageLastPercentTrees:` + fmt.Sprintf("%#v", this.AverageLastPercentTrees) + `}`}, ", ")
	return s
}
func (this *LearningRateDropoutDrivenConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_boosted_trees_learner.LearningRateDropoutDrivenConfig{")
	s = append(s, "DropoutProbability: "+fmt.Sprintf("%#v", this.DropoutProbability)+",\n")
	s = append(s, "ProbabilityOfSkippingDropout: "+fmt.Sprintf("%#v", this.ProbabilityOfSkippingDropout)+",\n")
	s = append(s, "LearningRate: "+fmt.Sprintf("%#v", this.LearningRate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LearnerConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&tensorflow_boosted_trees_learner.LearnerConfig{")
	s = append(s, "NumClasses: "+fmt.Sprintf("%#v", this.NumClasses)+",\n")
	if this.FeatureFraction != nil {
		s = append(s, "FeatureFraction: "+fmt.Sprintf("%#v", this.FeatureFraction)+",\n")
	}
	if this.Regularization != nil {
		s = append(s, "Regularization: "+fmt.Sprintf("%#v", this.Regularization)+",\n")
	}
	if this.Constraints != nil {
		s = append(s, "Constraints: "+fmt.Sprintf("%#v", this.Constraints)+",\n")
	}
	s = append(s, "PruningMode: "+fmt.Sprintf("%#v", this.PruningMode)+",\n")
	s = append(s, "GrowingMode: "+fmt.Sprintf("%#v", this.GrowingMode)+",\n")
	if this.LearningRateTuner != nil {
		s = append(s, "LearningRateTuner: "+fmt.Sprintf("%#v", this.LearningRateTuner)+",\n")
	}
	s = append(s, "MultiClassStrategy: "+fmt.Sprintf("%#v", this.MultiClassStrategy)+",\n")
	if this.AveragingConfig != nil {
		s = append(s, "AveragingConfig: "+fmt.Sprintf("%#v", this.AveragingConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LearnerConfig_FeatureFractionPerTree) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_learner.LearnerConfig_FeatureFractionPerTree{` +
		`FeatureFractionPerTree:` + fmt.Sprintf("%#v", this.FeatureFractionPerTree) + `}`}, ", ")
	return s
}
func (this *LearnerConfig_FeatureFractionPerLevel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_learner.LearnerConfig_FeatureFractionPerLevel{` +
		`FeatureFractionPerLevel:` + fmt.Sprintf("%#v", this.FeatureFractionPerLevel) + `}`}, ", ")
	return s
}
func valueToGoStringLearner(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TreeRegularizationConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeRegularizationConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.L1 != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.L1))))
	}
	if m.L2 != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.L2))))
	}
	if m.TreeComplexity != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.TreeComplexity))))
	}
	return i, nil
}

func (m *TreeConstraintsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeConstraintsConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxTreeDepth != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.MaxTreeDepth))
	}
	if m.MinNodeWeight != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.MinNodeWeight))))
	}
	return i, nil
}

func (m *LearningRateConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearningRateConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tuner != nil {
		nn1, err := m.Tuner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *LearningRateConfig_Fixed) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Fixed != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.Fixed.Size()))
		n2, err := m.Fixed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *LearningRateConfig_Dropout) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Dropout != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.Dropout.Size()))
		n3, err := m.Dropout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *LearningRateConfig_LineSearch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LineSearch != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.LineSearch.Size()))
		n4, err := m.LineSearch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *LearningRateFixedConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearningRateFixedConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LearningRate != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.LearningRate))))
	}
	return i, nil
}

func (m *LearningRateLineSearchConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearningRateLineSearchConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxLearningRate != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.MaxLearningRate))))
	}
	if m.NumSteps != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.NumSteps))
	}
	return i, nil
}

func (m *AveragingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AveragingConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		nn5, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *AveragingConfig_AverageLastNTrees) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.AverageLastNTrees))))
	return i, nil
}
func (m *AveragingConfig_AverageLastPercentTrees) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.AverageLastPercentTrees))))
	return i, nil
}
func (m *LearningRateDropoutDrivenConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearningRateDropoutDrivenConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropoutProbability != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.DropoutProbability))))
	}
	if m.ProbabilityOfSkippingDropout != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.ProbabilityOfSkippingDropout))))
	}
	if m.LearningRate != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.LearningRate))))
	}
	return i, nil
}

func (m *LearnerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnerConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumClasses != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.NumClasses))
	}
	if m.FeatureFraction != nil {
		nn6, err := m.FeatureFraction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	if m.Regularization != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.Regularization.Size()))
		n7, err := m.Regularization.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Constraints != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.Constraints.Size()))
		n8, err := m.Constraints.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.LearningRateTuner != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.LearningRateTuner.Size()))
		n9, err := m.LearningRateTuner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.PruningMode != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.PruningMode))
	}
	if m.GrowingMode != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.GrowingMode))
	}
	if m.MultiClassStrategy != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.MultiClassStrategy))
	}
	if m.AveragingConfig != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLearner(dAtA, i, uint64(m.AveragingConfig.Size()))
		n10, err := m.AveragingConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *LearnerConfig_FeatureFractionPerTree) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x15
	i++
	i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.FeatureFractionPerTree))))
	return i, nil
}
func (m *LearnerConfig_FeatureFractionPerLevel) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1d
	i++
	i = encodeFixed32Learner(dAtA, i, uint32(math.Float32bits(float32(m.FeatureFractionPerLevel))))
	return i, nil
}
func encodeFixed64Learner(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Learner(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintLearner(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TreeRegularizationConfig) Size() (n int) {
	var l int
	_ = l
	if m.L1 != 0 {
		n += 5
	}
	if m.L2 != 0 {
		n += 5
	}
	if m.TreeComplexity != 0 {
		n += 5
	}
	return n
}

func (m *TreeConstraintsConfig) Size() (n int) {
	var l int
	_ = l
	if m.MaxTreeDepth != 0 {
		n += 1 + sovLearner(uint64(m.MaxTreeDepth))
	}
	if m.MinNodeWeight != 0 {
		n += 5
	}
	return n
}

func (m *LearningRateConfig) Size() (n int) {
	var l int
	_ = l
	if m.Tuner != nil {
		n += m.Tuner.Size()
	}
	return n
}

func (m *LearningRateConfig_Fixed) Size() (n int) {
	var l int
	_ = l
	if m.Fixed != nil {
		l = m.Fixed.Size()
		n += 1 + l + sovLearner(uint64(l))
	}
	return n
}
func (m *LearningRateConfig_Dropout) Size() (n int) {
	var l int
	_ = l
	if m.Dropout != nil {
		l = m.Dropout.Size()
		n += 1 + l + sovLearner(uint64(l))
	}
	return n
}
func (m *LearningRateConfig_LineSearch) Size() (n int) {
	var l int
	_ = l
	if m.LineSearch != nil {
		l = m.LineSearch.Size()
		n += 1 + l + sovLearner(uint64(l))
	}
	return n
}
func (m *LearningRateFixedConfig) Size() (n int) {
	var l int
	_ = l
	if m.LearningRate != 0 {
		n += 5
	}
	return n
}

func (m *LearningRateLineSearchConfig) Size() (n int) {
	var l int
	_ = l
	if m.MaxLearningRate != 0 {
		n += 5
	}
	if m.NumSteps != 0 {
		n += 1 + sovLearner(uint64(m.NumSteps))
	}
	return n
}

func (m *AveragingConfig) Size() (n int) {
	var l int
	_ = l
	if m.Config != nil {
		n += m.Config.Size()
	}
	return n
}

func (m *AveragingConfig_AverageLastNTrees) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *AveragingConfig_AverageLastPercentTrees) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *LearningRateDropoutDrivenConfig) Size() (n int) {
	var l int
	_ = l
	if m.DropoutProbability != 0 {
		n += 5
	}
	if m.ProbabilityOfSkippingDropout != 0 {
		n += 5
	}
	if m.LearningRate != 0 {
		n += 5
	}
	return n
}

func (m *LearnerConfig) Size() (n int) {
	var l int
	_ = l
	if m.NumClasses != 0 {
		n += 1 + sovLearner(uint64(m.NumClasses))
	}
	if m.FeatureFraction != nil {
		n += m.FeatureFraction.Size()
	}
	if m.Regularization != nil {
		l = m.Regularization.Size()
		n += 1 + l + sovLearner(uint64(l))
	}
	if m.Constraints != nil {
		l = m.Constraints.Size()
		n += 1 + l + sovLearner(uint64(l))
	}
	if m.LearningRateTuner != nil {
		l = m.LearningRateTuner.Size()
		n += 1 + l + sovLearner(uint64(l))
	}
	if m.PruningMode != 0 {
		n += 1 + sovLearner(uint64(m.PruningMode))
	}
	if m.GrowingMode != 0 {
		n += 1 + sovLearner(uint64(m.GrowingMode))
	}
	if m.MultiClassStrategy != 0 {
		n += 1 + sovLearner(uint64(m.MultiClassStrategy))
	}
	if m.AveragingConfig != nil {
		l = m.AveragingConfig.Size()
		n += 1 + l + sovLearner(uint64(l))
	}
	return n
}

func (m *LearnerConfig_FeatureFractionPerTree) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *LearnerConfig_FeatureFractionPerLevel) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}

func sovLearner(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLearner(x uint64) (n int) {
	return sovLearner(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TreeRegularizationConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeRegularizationConfig{`,
		`L1:` + fmt.Sprintf("%v", this.L1) + `,`,
		`L2:` + fmt.Sprintf("%v", this.L2) + `,`,
		`TreeComplexity:` + fmt.Sprintf("%v", this.TreeComplexity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeConstraintsConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeConstraintsConfig{`,
		`MaxTreeDepth:` + fmt.Sprintf("%v", this.MaxTreeDepth) + `,`,
		`MinNodeWeight:` + fmt.Sprintf("%v", this.MinNodeWeight) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearningRateConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearningRateConfig{`,
		`Tuner:` + fmt.Sprintf("%v", this.Tuner) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearningRateConfig_Fixed) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearningRateConfig_Fixed{`,
		`Fixed:` + strings.Replace(fmt.Sprintf("%v", this.Fixed), "LearningRateFixedConfig", "LearningRateFixedConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearningRateConfig_Dropout) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearningRateConfig_Dropout{`,
		`Dropout:` + strings.Replace(fmt.Sprintf("%v", this.Dropout), "LearningRateDropoutDrivenConfig", "LearningRateDropoutDrivenConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearningRateConfig_LineSearch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearningRateConfig_LineSearch{`,
		`LineSearch:` + strings.Replace(fmt.Sprintf("%v", this.LineSearch), "LearningRateLineSearchConfig", "LearningRateLineSearchConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearningRateFixedConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearningRateFixedConfig{`,
		`LearningRate:` + fmt.Sprintf("%v", this.LearningRate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearningRateLineSearchConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearningRateLineSearchConfig{`,
		`MaxLearningRate:` + fmt.Sprintf("%v", this.MaxLearningRate) + `,`,
		`NumSteps:` + fmt.Sprintf("%v", this.NumSteps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AveragingConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AveragingConfig{`,
		`Config:` + fmt.Sprintf("%v", this.Config) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AveragingConfig_AverageLastNTrees) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AveragingConfig_AverageLastNTrees{`,
		`AverageLastNTrees:` + fmt.Sprintf("%v", this.AverageLastNTrees) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AveragingConfig_AverageLastPercentTrees) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AveragingConfig_AverageLastPercentTrees{`,
		`AverageLastPercentTrees:` + fmt.Sprintf("%v", this.AverageLastPercentTrees) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearningRateDropoutDrivenConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearningRateDropoutDrivenConfig{`,
		`DropoutProbability:` + fmt.Sprintf("%v", this.DropoutProbability) + `,`,
		`ProbabilityOfSkippingDropout:` + fmt.Sprintf("%v", this.ProbabilityOfSkippingDropout) + `,`,
		`LearningRate:` + fmt.Sprintf("%v", this.LearningRate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearnerConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearnerConfig{`,
		`NumClasses:` + fmt.Sprintf("%v", this.NumClasses) + `,`,
		`FeatureFraction:` + fmt.Sprintf("%v", this.FeatureFraction) + `,`,
		`Regularization:` + strings.Replace(fmt.Sprintf("%v", this.Regularization), "TreeRegularizationConfig", "TreeRegularizationConfig", 1) + `,`,
		`Constraints:` + strings.Replace(fmt.Sprintf("%v", this.Constraints), "TreeConstraintsConfig", "TreeConstraintsConfig", 1) + `,`,
		`LearningRateTuner:` + strings.Replace(fmt.Sprintf("%v", this.LearningRateTuner), "LearningRateConfig", "LearningRateConfig", 1) + `,`,
		`PruningMode:` + fmt.Sprintf("%v", this.PruningMode) + `,`,
		`GrowingMode:` + fmt.Sprintf("%v", this.GrowingMode) + `,`,
		`MultiClassStrategy:` + fmt.Sprintf("%v", this.MultiClassStrategy) + `,`,
		`AveragingConfig:` + strings.Replace(fmt.Sprintf("%v", this.AveragingConfig), "AveragingConfig", "AveragingConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearnerConfig_FeatureFractionPerTree) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearnerConfig_FeatureFractionPerTree{`,
		`FeatureFractionPerTree:` + fmt.Sprintf("%v", this.FeatureFractionPerTree) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearnerConfig_FeatureFractionPerLevel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearnerConfig_FeatureFractionPerLevel{`,
		`FeatureFractionPerLevel:` + fmt.Sprintf("%v", this.FeatureFractionPerLevel) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringLearner(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TreeRegularizationConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeRegularizationConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeRegularizationConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.L1 = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.L2 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeComplexity", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.TreeComplexity = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLearner(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearner
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeConstraintsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeConstraintsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeConstraintsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTreeDepth", wireType)
			}
			m.MaxTreeDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTreeDepth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNodeWeight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.MinNodeWeight = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLearner(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearner
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearningRateConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearningRateConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearningRateConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearner
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearningRateFixedConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Tuner = &LearningRateConfig_Fixed{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dropout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearner
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearningRateDropoutDrivenConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Tuner = &LearningRateConfig_Dropout{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineSearch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearner
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LearningRateLineSearchConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Tuner = &LearningRateConfig_LineSearch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearner(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearner
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearningRateFixedConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearningRateFixedConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearningRateFixedConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearningRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.LearningRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLearner(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearner
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearningRateLineSearchConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearningRateLineSearchConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearningRateLineSearchConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLearningRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.MaxLearningRate = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSteps", wireType)
			}
			m.NumSteps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSteps |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLearner(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearner
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AveragingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AveragingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AveragingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageLastNTrees", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Config = &AveragingConfig_AverageLastNTrees{float32(math.Float32frombits(v))}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageLastPercentTrees", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Config = &AveragingConfig_AverageLastPercentTrees{float32(math.Float32frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipLearner(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearner
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearningRateDropoutDrivenConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearningRateDropoutDrivenConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearningRateDropoutDrivenConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropoutProbability", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DropoutProbability = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbabilityOfSkippingDropout", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ProbabilityOfSkippingDropout = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearningRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.LearningRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLearner(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearner
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumClasses", wireType)
			}
			m.NumClasses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumClasses |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureFractionPerTree", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.FeatureFraction = &LearnerConfig_FeatureFractionPerTree{float32(math.Float32frombits(v))}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureFractionPerLevel", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.FeatureFraction = &LearnerConfig_FeatureFractionPerLevel{float32(math.Float32frombits(v))}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regularization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearner
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Regularization == nil {
				m.Regularization = &TreeRegularizationConfig{}
			}
			if err := m.Regularization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearner
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Constraints == nil {
				m.Constraints = &TreeConstraintsConfig{}
			}
			if err := m.Constraints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearningRateTuner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearner
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearningRateTuner == nil {
				m.LearningRateTuner = &LearningRateConfig{}
			}
			if err := m.LearningRateTuner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PruningMode", wireType)
			}
			m.PruningMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PruningMode |= (LearnerConfig_PruningMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrowingMode", wireType)
			}
			m.GrowingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrowingMode |= (LearnerConfig_GrowingMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiClassStrategy", wireType)
			}
			m.MultiClassStrategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MultiClassStrategy |= (LearnerConfig_MultiClassStrategy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AveragingConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLearner
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AveragingConfig == nil {
				m.AveragingConfig = &AveragingConfig{}
			}
			if err := m.AveragingConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLearner(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLearner
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLearner(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLearner
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLearner
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLearner
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLearner
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLearner(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLearner = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLearner   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/contrib/boosted_trees/proto/learner.proto", fileDescriptorLearner)
}

var fileDescriptorLearner = []byte{
	// 972 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4f, 0x6f, 0x1b, 0xc5,
	0x1b, 0xf6, 0xba, 0xbf, 0xa4, 0xc9, 0xbb, 0xb1, 0xe3, 0x4c, 0xf3, 0xa3, 0x0b, 0x54, 0x9b, 0xc8,
	0x20, 0xa8, 0x10, 0xb2, 0x15, 0x83, 0x84, 0xa0, 0x6a, 0x25, 0x3b, 0x71, 0x9a, 0x4a, 0xdb, 0xc4,
	0xac, 0x5d, 0x55, 0x91, 0x80, 0xd1, 0xd8, 0x1e, 0x6f, 0x56, 0xec, 0xce, 0xae, 0x66, 0x67, 0x13,
	0x97, 0x13, 0x5f, 0x00, 0x89, 0x8f, 0xc1, 0x81, 0x13, 0x1f, 0x80, 0x33, 0xc7, 0x1e, 0x39, 0x12,
	0x73, 0xe1, 0xd8, 0x23, 0x47, 0x34, 0xb3, 0x13, 0x7b, 0x1d, 0xa7, 0xa4, 0xe1, 0xe6, 0x79, 0xe7,
	0x7d, 0x9e, 0x67, 0xf6, 0x79, 0xff, 0xc8, 0xf0, 0x30, 0xe6, 0x91, 0x88, 0xfa, 0xe9, 0xa8, 0x2e,
	0x28, 0x4b, 0x22, 0x3e, 0x0a, 0xa2, 0xb3, 0xfa, 0x20, 0x62, 0x82, 0xfb, 0xfd, 0x7a, 0x3f, 0x8a,
	0x12, 0x41, 0x87, 0x58, 0x70, 0x4a, 0x93, 0xba, 0xca, 0xac, 0x07, 0x94, 0x70, 0x46, 0x79, 0x4d,
	0x9d, 0xd0, 0xf6, 0x0c, 0x55, 0x9b, 0xcb, 0xae, 0xe9, 0xbc, 0xea, 0x00, 0xac, 0x1e, 0xa7, 0xd4,
	0xa5, 0x5e, 0x1a, 0x10, 0xee, 0x7f, 0x47, 0x84, 0x1f, 0xb1, 0xdd, 0x88, 0x8d, 0x7c, 0x0f, 0x95,
	0xa1, 0x18, 0xec, 0x58, 0xc6, 0xb6, 0x71, 0xbf, 0xe8, 0x16, 0x83, 0x1d, 0x75, 0x6e, 0x58, 0x45,
	0x7d, 0x6e, 0xa0, 0x0f, 0x61, 0x5d, 0x92, 0xe1, 0x41, 0x14, 0xc6, 0x01, 0x1d, 0xfb, 0xe2, 0x85,
	0x75, 0x4b, 0x5d, 0x96, 0x65, 0x78, 0x77, 0x1a, 0xad, 0x52, 0xf8, 0x7f, 0x4f, 0x45, 0x58, 0x22,
	0x38, 0xf1, 0x99, 0x48, 0xb4, 0xc2, 0xfb, 0x50, 0x0e, 0xc9, 0x58, 0x3d, 0x09, 0x0f, 0x69, 0x2c,
	0x4e, 0x94, 0x5a, 0xc9, 0x5d, 0x0b, 0xc9, 0x58, 0x22, 0xf6, 0x64, 0x0c, 0x7d, 0x00, 0xeb, 0xa1,
	0xcf, 0x30, 0x8b, 0x86, 0x14, 0x9f, 0x51, 0xdf, 0x3b, 0x11, 0xfa, 0x11, 0xa5, 0xd0, 0x67, 0x87,
	0xd1, 0x90, 0x3e, 0x57, 0xc1, 0xea, 0x2f, 0x45, 0x40, 0x8e, 0xfc, 0x2e, 0x9f, 0x79, 0x2e, 0x11,
	0x54, 0x8b, 0x7c, 0x09, 0x4b, 0x23, 0x7f, 0x4c, 0x87, 0x8a, 0xdb, 0x6c, 0x7c, 0x5e, 0xbb, 0xce,
	0x94, 0x5a, 0x9e, 0x64, 0x5f, 0x42, 0x33, 0xa6, 0x83, 0x82, 0x9b, 0x31, 0xa1, 0xaf, 0xe1, 0xf6,
	0x90, 0x47, 0x71, 0x94, 0x66, 0x2f, 0x31, 0x1b, 0xcd, 0x9b, 0x91, 0xee, 0x65, 0xe0, 0x3d, 0xee,
	0x9f, 0x52, 0x36, 0x25, 0xbf, 0xe0, 0x44, 0x04, 0xcc, 0xc0, 0x67, 0x14, 0x27, 0x94, 0xf0, 0xc1,
	0x89, 0x32, 0xd5, 0x6c, 0x3c, 0xba, 0x99, 0x84, 0xe3, 0x33, 0xda, 0x55, 0xf8, 0x29, 0x3f, 0x04,
	0xd3, 0x58, 0xeb, 0x36, 0x2c, 0x89, 0x54, 0x36, 0xc0, 0x23, 0xb8, 0xfb, 0x9a, 0xcf, 0x45, 0xef,
	0x41, 0x29, 0xd0, 0x57, 0x98, 0x13, 0x41, 0x75, 0x2b, 0xac, 0x05, 0xb9, 0xfc, 0xaa, 0x07, 0xf7,
	0xfe, 0x4d, 0x16, 0x7d, 0x04, 0x1b, 0xb2, 0xc4, 0x57, 0x11, 0xad, 0x87, 0x64, 0x9c, 0xc7, 0xa2,
	0x77, 0x61, 0x95, 0xa5, 0x21, 0x4e, 0x04, 0x8d, 0x13, 0x65, 0xec, 0x92, 0xbb, 0xc2, 0xd2, 0xb0,
	0x2b, 0xcf, 0xd5, 0x1f, 0x0c, 0x58, 0x6f, 0x9e, 0x52, 0x4e, 0x3c, 0x9f, 0x79, 0x9a, 0x7c, 0x07,
	0x36, 0x89, 0x0a, 0x51, 0x1c, 0x90, 0x44, 0x60, 0x96, 0x19, 0x92, 0xf1, 0x1f, 0x14, 0xdc, 0x0d,
	0x7d, 0xeb, 0x90, 0x44, 0x1c, 0xca, 0x86, 0x4a, 0xd0, 0x43, 0x78, 0x67, 0x0e, 0x12, 0x53, 0x3e,
	0xa0, 0x4c, 0x68, 0x60, 0x51, 0x03, 0xef, 0xe6, 0x80, 0x9d, 0x2c, 0x43, 0xc1, 0x5b, 0x2b, 0xb0,
	0x3c, 0x50, 0xda, 0xd5, 0x5f, 0x0d, 0xd8, 0xba, 0xa6, 0xa6, 0xa8, 0x0e, 0x77, 0x74, 0x4d, 0x71,
	0xcc, 0xa3, 0x3e, 0xe9, 0xfb, 0x81, 0x9c, 0x92, 0xec, 0xf3, 0x91, 0xbe, 0xea, 0xcc, 0x6e, 0x50,
	0x1b, 0xb6, 0x72, 0x89, 0x38, 0x1a, 0xe1, 0xe4, 0x5b, 0x3f, 0x8e, 0xa5, 0x71, 0xf9, 0x86, 0x2b,
	0xba, 0xf7, 0x72, 0x69, 0x47, 0xa3, 0xae, 0x4e, 0xd2, 0x6f, 0x58, 0xac, 0xdc, 0xad, 0x2b, 0x2a,
	0xf7, 0xf3, 0x0a, 0x94, 0x9c, 0xac, 0x73, 0xf4, 0x73, 0xb7, 0xc0, 0x94, 0xfe, 0x0f, 0x02, 0x92,
	0x24, 0xda, 0xc5, 0x92, 0x0b, 0x2c, 0x0d, 0x77, 0xb3, 0x08, 0x7a, 0x00, 0x6f, 0x8f, 0x28, 0x11,
	0x29, 0xa7, 0x78, 0xc4, 0xc9, 0x40, 0xee, 0x0a, 0x69, 0xa0, 0x32, 0x6f, 0xea, 0xdd, 0x5b, 0x3a,
	0x65, 0x5f, 0x67, 0x74, 0x28, 0x97, 0xde, 0x49, 0xe7, 0xaf, 0x04, 0x07, 0xf4, 0x94, 0x06, 0xd9,
	0x0b, 0xa5, 0xf3, 0x8b, 0x68, 0x47, 0x26, 0xa0, 0x3e, 0x94, 0xf9, 0xdc, 0x96, 0xb2, 0xfe, 0xa7,
	0xe6, 0xe2, 0x8b, 0xeb, 0xe7, 0xe2, 0x75, 0x1b, 0xce, 0xbd, 0xc4, 0x88, 0x8e, 0xc1, 0x1c, 0xcc,
	0x96, 0x94, 0xb5, 0xa4, 0x04, 0x3e, 0x7b, 0x33, 0x81, 0x85, 0xed, 0xe6, 0xe6, 0xb9, 0xd0, 0x10,
	0xee, 0xcc, 0x95, 0x04, 0xab, 0xf1, 0xb3, 0x96, 0x95, 0xc4, 0xa7, 0x37, 0x9b, 0x6d, 0xcd, 0xbf,
	0x91, 0x2f, 0x67, 0x4f, 0xd2, 0xa1, 0x6f, 0x60, 0x2d, 0xe6, 0xa9, 0x12, 0x09, 0xa3, 0x21, 0xb5,
	0x56, 0xb6, 0x8d, 0xfb, 0xe5, 0xc6, 0x83, 0x37, 0xa4, 0xbf, 0x68, 0x84, 0x5a, 0x27, 0xe3, 0x78,
	0x1a, 0x0d, 0xa9, 0x6b, 0xc6, 0xb3, 0x83, 0xe4, 0xf7, 0x78, 0x74, 0x36, 0xe5, 0x5f, 0xfd, 0x6f,
	0xfc, 0x8f, 0x33, 0x8e, 0x8c, 0xdf, 0x9b, 0x1d, 0x90, 0x80, 0xcd, 0x30, 0x0d, 0x84, 0x9f, 0xf5,
	0x20, 0x96, 0xee, 0x09, 0xea, 0xbd, 0xb0, 0x40, 0xe9, 0xb4, 0x6e, 0xaa, 0xf3, 0x54, 0x72, 0xa9,
	0xe6, 0xed, 0x6a, 0x26, 0x17, 0x85, 0x0b, 0x31, 0xf4, 0x15, 0x54, 0xc8, 0xc5, 0x66, 0xc1, 0xd9,
	0x78, 0x5b, 0xa6, 0x2a, 0xcc, 0xce, 0xf5, 0x8a, 0x97, 0x76, 0x92, 0xbb, 0x4e, 0xe6, 0x03, 0xd5,
	0x8f, 0xc1, 0xcc, 0xf9, 0x89, 0x4a, 0xb0, 0xda, 0x71, 0xdb, 0xb8, 0xe3, 0x3e, 0x3b, 0x6c, 0x57,
	0x0a, 0xa8, 0x0c, 0xd0, 0x39, 0xea, 0xf6, 0xf4, 0xd9, 0xa8, 0xee, 0x80, 0x99, 0x73, 0x47, 0x5e,
	0x3f, 0x3f, 0x38, 0x72, 0xda, 0xb8, 0xe7, 0xb6, 0x65, 0x3a, 0x82, 0xb2, 0xd3, 0x3c, 0x6e, 0xbb,
	0xb8, 0x75, 0x8c, 0xd5, 0x8f, 0x8a, 0x51, 0xed, 0x00, 0x5a, 0xfc, 0x50, 0x99, 0x29, 0x31, 0xb8,
	0xd3, 0x76, 0xf1, 0xae, 0xd3, 0xec, 0x76, 0x2b, 0x05, 0x54, 0x81, 0xb5, 0xfd, 0x67, 0x8e, 0x83,
	0x0f, 0xda, 0xdd, 0xee, 0x93, 0xe6, 0x61, 0xc5, 0x40, 0x9b, 0x50, 0xd9, 0x7b, 0xd2, 0x7c, 0x7c,
	0x74, 0xd8, 0x9c, 0x45, 0x8b, 0x2d, 0x04, 0x95, 0xcb, 0xa3, 0xda, 0xaa, 0xbf, 0x3c, 0xb7, 0x0b,
	0xbf, 0x9f, 0xdb, 0x85, 0x57, 0xe7, 0xb6, 0xf1, 0xfd, 0xc4, 0x36, 0x7e, 0x9a, 0xd8, 0xc6, 0x6f,
	0x13, 0xdb, 0x78, 0x39, 0xb1, 0x8d, 0x3f, 0x26, 0xb6, 0xf1, 0xd7, 0xc4, 0x2e, 0xbc, 0x9a, 0xd8,
	0xc6, 0x8f, 0x7f, 0xda, 0x85, 0xbf, 0x0d, 0xa3, 0xbf, 0xac, 0xfe, 0x83, 0x7c, 0xf2, 0x4f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x89, 0xd9, 0x27, 0xee, 0xc4, 0x08, 0x00, 0x00,
}
