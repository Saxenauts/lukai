// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/contrib/tensor_forest/proto/fertile_stats.proto

/*
	Package tensorflow_tensorforest is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/contrib/tensor_forest/proto/fertile_stats.proto

	It has these top-level messages:
		FertileStats
		GiniStats
		LeafStat
		FertileSlot
		SplitCandidate
		TreePath
*/
package tensorflow_tensorforest

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import tensorflow_decision_trees "github.com/d4l3k/pok/tensorflow/contrib/decision_trees/proto"

import fmt "fmt"
import strings "strings"
import reflect "reflect"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type FertileStats struct {
	// Tracks stats for each node.  node_to_slot[i] is the FertileSlot for node i.
	// This may be sized to max_nodes initially, or grow dynamically as needed.
	NodeToSlot []*FertileSlot `protobuf:"bytes,1,rep,name=node_to_slot,json=nodeToSlot" json:"node_to_slot,omitempty"`
}

func (m *FertileStats) Reset()                    { *m = FertileStats{} }
func (*FertileStats) ProtoMessage()               {}
func (*FertileStats) Descriptor() ([]byte, []int) { return fileDescriptorFertileStats, []int{0} }

func (m *FertileStats) GetNodeToSlot() []*FertileSlot {
	if m != nil {
		return m.NodeToSlot
	}
	return nil
}

type GiniStats struct {
	// This allows us to quickly track and calculate impurity (classification)
	//  by storing the sum of input weights and the sum of the squares of the
	// input weights.  Weighted gini is then: 1 - (square / sum * sum).
	// Updates to these numbers are:
	//   old_i = leaf->value(label)
	//   new_i = old_i + incoming_weight
	//   sum -> sum + incoming_weight
	//   square -> square - (old_i ^ 2) + (new_i ^ 2)
	//   total_left_sum -> total_left_sum - old_left_i * old_total_i +
	//                                      new_left_i * new_total_i
	Square float32 `protobuf:"fixed32,2,opt,name=square,proto3" json:"square,omitempty"`
}

func (m *GiniStats) Reset()                    { *m = GiniStats{} }
func (*GiniStats) ProtoMessage()               {}
func (*GiniStats) Descriptor() ([]byte, []int) { return fileDescriptorFertileStats, []int{1} }

func (m *GiniStats) GetSquare() float32 {
	if m != nil {
		return m.Square
	}
	return 0
}

type LeafStat struct {
	// The sum of the weights of the training examples that we have seen.
	// This is here, outside of the leaf_stat oneof, because almost all
	// types will want it.
	WeightSum float32 `protobuf:"fixed32,3,opt,name=weight_sum,json=weightSum,proto3" json:"weight_sum,omitempty"`
	// Types that are valid to be assigned to LeafStat:
	//	*LeafStat_Classification
	//	*LeafStat_Regression
	LeafStat isLeafStat_LeafStat `protobuf_oneof:"leaf_stat"`
}

func (m *LeafStat) Reset()                    { *m = LeafStat{} }
func (*LeafStat) ProtoMessage()               {}
func (*LeafStat) Descriptor() ([]byte, []int) { return fileDescriptorFertileStats, []int{2} }

type isLeafStat_LeafStat interface {
	isLeafStat_LeafStat()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LeafStat_Classification struct {
	Classification *LeafStat_GiniImpurityClassificationStats `protobuf:"bytes,1,opt,name=classification,oneof"`
}
type LeafStat_Regression struct {
	Regression *LeafStat_LeastSquaresRegressionStats `protobuf:"bytes,2,opt,name=regression,oneof"`
}

func (*LeafStat_Classification) isLeafStat_LeafStat() {}
func (*LeafStat_Regression) isLeafStat_LeafStat()     {}

func (m *LeafStat) GetLeafStat() isLeafStat_LeafStat {
	if m != nil {
		return m.LeafStat
	}
	return nil
}

func (m *LeafStat) GetWeightSum() float32 {
	if m != nil {
		return m.WeightSum
	}
	return 0
}

func (m *LeafStat) GetClassification() *LeafStat_GiniImpurityClassificationStats {
	if x, ok := m.GetLeafStat().(*LeafStat_Classification); ok {
		return x.Classification
	}
	return nil
}

func (m *LeafStat) GetRegression() *LeafStat_LeastSquaresRegressionStats {
	if x, ok := m.GetLeafStat().(*LeafStat_Regression); ok {
		return x.Regression
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LeafStat) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LeafStat_OneofMarshaler, _LeafStat_OneofUnmarshaler, _LeafStat_OneofSizer, []interface{}{
		(*LeafStat_Classification)(nil),
		(*LeafStat_Regression)(nil),
	}
}

func _LeafStat_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LeafStat)
	// leaf_stat
	switch x := m.LeafStat.(type) {
	case *LeafStat_Classification:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Classification); err != nil {
			return err
		}
	case *LeafStat_Regression:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Regression); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LeafStat.LeafStat has unexpected type %T", x)
	}
	return nil
}

func _LeafStat_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LeafStat)
	switch tag {
	case 1: // leaf_stat.classification
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LeafStat_GiniImpurityClassificationStats)
		err := b.DecodeMessage(msg)
		m.LeafStat = &LeafStat_Classification{msg}
		return true, err
	case 2: // leaf_stat.regression
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LeafStat_LeastSquaresRegressionStats)
		err := b.DecodeMessage(msg)
		m.LeafStat = &LeafStat_Regression{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LeafStat_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LeafStat)
	// leaf_stat
	switch x := m.LeafStat.(type) {
	case *LeafStat_Classification:
		s := proto.Size(x.Classification)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LeafStat_Regression:
		s := proto.Size(x.Regression)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TODO(thomaswc): Move the GiniStats out of LeafStats and into something
// that only tracks them for splits.
type LeafStat_GiniImpurityClassificationStats struct {
	// Types that are valid to be assigned to Counts:
	//	*LeafStat_GiniImpurityClassificationStats_DenseCounts
	//	*LeafStat_GiniImpurityClassificationStats_SparseCounts
	Counts isLeafStat_GiniImpurityClassificationStats_Counts `protobuf_oneof:"counts"`
	Gini   *GiniStats                                        `protobuf:"bytes,3,opt,name=gini" json:"gini,omitempty"`
}

func (m *LeafStat_GiniImpurityClassificationStats) Reset() {
	*m = LeafStat_GiniImpurityClassificationStats{}
}
func (*LeafStat_GiniImpurityClassificationStats) ProtoMessage() {}
func (*LeafStat_GiniImpurityClassificationStats) Descriptor() ([]byte, []int) {
	return fileDescriptorFertileStats, []int{2, 0}
}

type isLeafStat_GiniImpurityClassificationStats_Counts interface {
	isLeafStat_GiniImpurityClassificationStats_Counts()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LeafStat_GiniImpurityClassificationStats_DenseCounts struct {
	DenseCounts *tensorflow_decision_trees.Vector `protobuf:"bytes,1,opt,name=dense_counts,json=denseCounts,oneof"`
}
type LeafStat_GiniImpurityClassificationStats_SparseCounts struct {
	SparseCounts *tensorflow_decision_trees.SparseVector `protobuf:"bytes,2,opt,name=sparse_counts,json=sparseCounts,oneof"`
}

func (*LeafStat_GiniImpurityClassificationStats_DenseCounts) isLeafStat_GiniImpurityClassificationStats_Counts() {
}
func (*LeafStat_GiniImpurityClassificationStats_SparseCounts) isLeafStat_GiniImpurityClassificationStats_Counts() {
}

func (m *LeafStat_GiniImpurityClassificationStats) GetCounts() isLeafStat_GiniImpurityClassificationStats_Counts {
	if m != nil {
		return m.Counts
	}
	return nil
}

func (m *LeafStat_GiniImpurityClassificationStats) GetDenseCounts() *tensorflow_decision_trees.Vector {
	if x, ok := m.GetCounts().(*LeafStat_GiniImpurityClassificationStats_DenseCounts); ok {
		return x.DenseCounts
	}
	return nil
}

func (m *LeafStat_GiniImpurityClassificationStats) GetSparseCounts() *tensorflow_decision_trees.SparseVector {
	if x, ok := m.GetCounts().(*LeafStat_GiniImpurityClassificationStats_SparseCounts); ok {
		return x.SparseCounts
	}
	return nil
}

func (m *LeafStat_GiniImpurityClassificationStats) GetGini() *GiniStats {
	if m != nil {
		return m.Gini
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LeafStat_GiniImpurityClassificationStats) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LeafStat_GiniImpurityClassificationStats_OneofMarshaler, _LeafStat_GiniImpurityClassificationStats_OneofUnmarshaler, _LeafStat_GiniImpurityClassificationStats_OneofSizer, []interface{}{
		(*LeafStat_GiniImpurityClassificationStats_DenseCounts)(nil),
		(*LeafStat_GiniImpurityClassificationStats_SparseCounts)(nil),
	}
}

func _LeafStat_GiniImpurityClassificationStats_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LeafStat_GiniImpurityClassificationStats)
	// counts
	switch x := m.Counts.(type) {
	case *LeafStat_GiniImpurityClassificationStats_DenseCounts:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DenseCounts); err != nil {
			return err
		}
	case *LeafStat_GiniImpurityClassificationStats_SparseCounts:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparseCounts); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LeafStat_GiniImpurityClassificationStats.Counts has unexpected type %T", x)
	}
	return nil
}

func _LeafStat_GiniImpurityClassificationStats_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LeafStat_GiniImpurityClassificationStats)
	switch tag {
	case 1: // counts.dense_counts
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(tensorflow_decision_trees.Vector)
		err := b.DecodeMessage(msg)
		m.Counts = &LeafStat_GiniImpurityClassificationStats_DenseCounts{msg}
		return true, err
	case 2: // counts.sparse_counts
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(tensorflow_decision_trees.SparseVector)
		err := b.DecodeMessage(msg)
		m.Counts = &LeafStat_GiniImpurityClassificationStats_SparseCounts{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LeafStat_GiniImpurityClassificationStats_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LeafStat_GiniImpurityClassificationStats)
	// counts
	switch x := m.Counts.(type) {
	case *LeafStat_GiniImpurityClassificationStats_DenseCounts:
		s := proto.Size(x.DenseCounts)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LeafStat_GiniImpurityClassificationStats_SparseCounts:
		s := proto.Size(x.SparseCounts)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// This is the info needed for calculating variance for regression.
// Variance will still have to be summed over every output, but the
// number of outputs in regression problems is almost always 1.
type LeafStat_LeastSquaresRegressionStats struct {
	MeanOutput        *tensorflow_decision_trees.Vector `protobuf:"bytes,1,opt,name=mean_output,json=meanOutput" json:"mean_output,omitempty"`
	MeanOutputSquares *tensorflow_decision_trees.Vector `protobuf:"bytes,2,opt,name=mean_output_squares,json=meanOutputSquares" json:"mean_output_squares,omitempty"`
}

func (m *LeafStat_LeastSquaresRegressionStats) Reset()      { *m = LeafStat_LeastSquaresRegressionStats{} }
func (*LeafStat_LeastSquaresRegressionStats) ProtoMessage() {}
func (*LeafStat_LeastSquaresRegressionStats) Descriptor() ([]byte, []int) {
	return fileDescriptorFertileStats, []int{2, 1}
}

func (m *LeafStat_LeastSquaresRegressionStats) GetMeanOutput() *tensorflow_decision_trees.Vector {
	if m != nil {
		return m.MeanOutput
	}
	return nil
}

func (m *LeafStat_LeastSquaresRegressionStats) GetMeanOutputSquares() *tensorflow_decision_trees.Vector {
	if m != nil {
		return m.MeanOutputSquares
	}
	return nil
}

type FertileSlot struct {
	// The statistics for *all* the examples seen at this leaf.
	LeafStats  *LeafStat         `protobuf:"bytes,4,opt,name=leaf_stats,json=leafStats" json:"leaf_stats,omitempty"`
	Candidates []*SplitCandidate `protobuf:"bytes,1,rep,name=candidates" json:"candidates,omitempty"`
	// The statistics for the examples seen at this leaf after all the
	// splits have been initialized.  If post_init_leaf_stats.weight_sum
	// is > 0, then all candidates have been initialized.  We need to track
	// both leaf_stats and post_init_leaf_stats because the first is used
	// to create the decision_tree::Leaf and the second is used to infer
	// the statistics for the right side of a split (given the leaf side
	// stats).
	PostInitLeafStats *LeafStat `protobuf:"bytes,6,opt,name=post_init_leaf_stats,json=postInitLeafStats" json:"post_init_leaf_stats,omitempty"`
	NodeId            int32     `protobuf:"varint,5,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Depth             int32     `protobuf:"varint,7,opt,name=depth,proto3" json:"depth,omitempty"`
}

func (m *FertileSlot) Reset()                    { *m = FertileSlot{} }
func (*FertileSlot) ProtoMessage()               {}
func (*FertileSlot) Descriptor() ([]byte, []int) { return fileDescriptorFertileStats, []int{3} }

func (m *FertileSlot) GetLeafStats() *LeafStat {
	if m != nil {
		return m.LeafStats
	}
	return nil
}

func (m *FertileSlot) GetCandidates() []*SplitCandidate {
	if m != nil {
		return m.Candidates
	}
	return nil
}

func (m *FertileSlot) GetPostInitLeafStats() *LeafStat {
	if m != nil {
		return m.PostInitLeafStats
	}
	return nil
}

func (m *FertileSlot) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *FertileSlot) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

type SplitCandidate struct {
	// proto representing the potential node.
	Split *tensorflow_decision_trees.BinaryNode `protobuf:"bytes,1,opt,name=split" json:"split,omitempty"`
	// Right counts are inferred from FertileSlot.leaf_stats and left.
	LeftStats *LeafStat `protobuf:"bytes,4,opt,name=left_stats,json=leftStats" json:"left_stats,omitempty"`
	// Right stats (not full counts) are kept here.
	RightStats *LeafStat `protobuf:"bytes,5,opt,name=right_stats,json=rightStats" json:"right_stats,omitempty"`
	// Fields used when training with a graph runner.
	UniqueId string `protobuf:"bytes,6,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
}

func (m *SplitCandidate) Reset()                    { *m = SplitCandidate{} }
func (*SplitCandidate) ProtoMessage()               {}
func (*SplitCandidate) Descriptor() ([]byte, []int) { return fileDescriptorFertileStats, []int{4} }

func (m *SplitCandidate) GetSplit() *tensorflow_decision_trees.BinaryNode {
	if m != nil {
		return m.Split
	}
	return nil
}

func (m *SplitCandidate) GetLeftStats() *LeafStat {
	if m != nil {
		return m.LeftStats
	}
	return nil
}

func (m *SplitCandidate) GetRightStats() *LeafStat {
	if m != nil {
		return m.RightStats
	}
	return nil
}

func (m *SplitCandidate) GetUniqueId() string {
	if m != nil {
		return m.UniqueId
	}
	return ""
}

// Proto used for tracking tree paths during inference time.
type TreePath struct {
	// Nodes are listed in order that they were traversed. i.e. nodes_visited[0]
	// is the tree's root node.
	NodesVisited []*tensorflow_decision_trees.TreeNode `protobuf:"bytes,1,rep,name=nodes_visited,json=nodesVisited" json:"nodes_visited,omitempty"`
}

func (m *TreePath) Reset()                    { *m = TreePath{} }
func (*TreePath) ProtoMessage()               {}
func (*TreePath) Descriptor() ([]byte, []int) { return fileDescriptorFertileStats, []int{5} }

func (m *TreePath) GetNodesVisited() []*tensorflow_decision_trees.TreeNode {
	if m != nil {
		return m.NodesVisited
	}
	return nil
}

func init() {
	proto.RegisterType((*FertileStats)(nil), "tensorflow.tensorforest.FertileStats")
	proto.RegisterType((*GiniStats)(nil), "tensorflow.tensorforest.GiniStats")
	proto.RegisterType((*LeafStat)(nil), "tensorflow.tensorforest.LeafStat")
	proto.RegisterType((*LeafStat_GiniImpurityClassificationStats)(nil), "tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats")
	proto.RegisterType((*LeafStat_LeastSquaresRegressionStats)(nil), "tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats")
	proto.RegisterType((*FertileSlot)(nil), "tensorflow.tensorforest.FertileSlot")
	proto.RegisterType((*SplitCandidate)(nil), "tensorflow.tensorforest.SplitCandidate")
	proto.RegisterType((*TreePath)(nil), "tensorflow.tensorforest.TreePath")
}
func (this *FertileStats) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FertileStats)
	if !ok {
		that2, ok := that.(FertileStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.NodeToSlot) != len(that1.NodeToSlot) {
		return false
	}
	for i := range this.NodeToSlot {
		if !this.NodeToSlot[i].Equal(that1.NodeToSlot[i]) {
			return false
		}
	}
	return true
}
func (this *GiniStats) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GiniStats)
	if !ok {
		that2, ok := that.(GiniStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Square != that1.Square {
		return false
	}
	return true
}
func (this *LeafStat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafStat)
	if !ok {
		that2, ok := that.(LeafStat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.WeightSum != that1.WeightSum {
		return false
	}
	if that1.LeafStat == nil {
		if this.LeafStat != nil {
			return false
		}
	} else if this.LeafStat == nil {
		return false
	} else if !this.LeafStat.Equal(that1.LeafStat) {
		return false
	}
	return true
}
func (this *LeafStat_Classification) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafStat_Classification)
	if !ok {
		that2, ok := that.(LeafStat_Classification)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Classification.Equal(that1.Classification) {
		return false
	}
	return true
}
func (this *LeafStat_Regression) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafStat_Regression)
	if !ok {
		that2, ok := that.(LeafStat_Regression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Regression.Equal(that1.Regression) {
		return false
	}
	return true
}
func (this *LeafStat_GiniImpurityClassificationStats) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafStat_GiniImpurityClassificationStats)
	if !ok {
		that2, ok := that.(LeafStat_GiniImpurityClassificationStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Counts == nil {
		if this.Counts != nil {
			return false
		}
	} else if this.Counts == nil {
		return false
	} else if !this.Counts.Equal(that1.Counts) {
		return false
	}
	if !this.Gini.Equal(that1.Gini) {
		return false
	}
	return true
}
func (this *LeafStat_GiniImpurityClassificationStats_DenseCounts) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafStat_GiniImpurityClassificationStats_DenseCounts)
	if !ok {
		that2, ok := that.(LeafStat_GiniImpurityClassificationStats_DenseCounts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.DenseCounts.Equal(that1.DenseCounts) {
		return false
	}
	return true
}
func (this *LeafStat_GiniImpurityClassificationStats_SparseCounts) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafStat_GiniImpurityClassificationStats_SparseCounts)
	if !ok {
		that2, ok := that.(LeafStat_GiniImpurityClassificationStats_SparseCounts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SparseCounts.Equal(that1.SparseCounts) {
		return false
	}
	return true
}
func (this *LeafStat_LeastSquaresRegressionStats) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LeafStat_LeastSquaresRegressionStats)
	if !ok {
		that2, ok := that.(LeafStat_LeastSquaresRegressionStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.MeanOutput.Equal(that1.MeanOutput) {
		return false
	}
	if !this.MeanOutputSquares.Equal(that1.MeanOutputSquares) {
		return false
	}
	return true
}
func (this *FertileSlot) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FertileSlot)
	if !ok {
		that2, ok := that.(FertileSlot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.LeafStats.Equal(that1.LeafStats) {
		return false
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return false
	}
	for i := range this.Candidates {
		if !this.Candidates[i].Equal(that1.Candidates[i]) {
			return false
		}
	}
	if !this.PostInitLeafStats.Equal(that1.PostInitLeafStats) {
		return false
	}
	if this.NodeId != that1.NodeId {
		return false
	}
	if this.Depth != that1.Depth {
		return false
	}
	return true
}
func (this *SplitCandidate) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SplitCandidate)
	if !ok {
		that2, ok := that.(SplitCandidate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Split.Equal(that1.Split) {
		return false
	}
	if !this.LeftStats.Equal(that1.LeftStats) {
		return false
	}
	if !this.RightStats.Equal(that1.RightStats) {
		return false
	}
	if this.UniqueId != that1.UniqueId {
		return false
	}
	return true
}
func (this *TreePath) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreePath)
	if !ok {
		that2, ok := that.(TreePath)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.NodesVisited) != len(that1.NodesVisited) {
		return false
	}
	for i := range this.NodesVisited {
		if !this.NodesVisited[i].Equal(that1.NodesVisited[i]) {
			return false
		}
	}
	return true
}
func (this *FertileStats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_tensorforest.FertileStats{")
	if this.NodeToSlot != nil {
		s = append(s, "NodeToSlot: "+fmt.Sprintf("%#v", this.NodeToSlot)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GiniStats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_tensorforest.GiniStats{")
	s = append(s, "Square: "+fmt.Sprintf("%#v", this.Square)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LeafStat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_tensorforest.LeafStat{")
	s = append(s, "WeightSum: "+fmt.Sprintf("%#v", this.WeightSum)+",\n")
	if this.LeafStat != nil {
		s = append(s, "LeafStat: "+fmt.Sprintf("%#v", this.LeafStat)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LeafStat_Classification) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_tensorforest.LeafStat_Classification{` +
		`Classification:` + fmt.Sprintf("%#v", this.Classification) + `}`}, ", ")
	return s
}
func (this *LeafStat_Regression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_tensorforest.LeafStat_Regression{` +
		`Regression:` + fmt.Sprintf("%#v", this.Regression) + `}`}, ", ")
	return s
}
func (this *LeafStat_GiniImpurityClassificationStats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_tensorforest.LeafStat_GiniImpurityClassificationStats{")
	if this.Counts != nil {
		s = append(s, "Counts: "+fmt.Sprintf("%#v", this.Counts)+",\n")
	}
	if this.Gini != nil {
		s = append(s, "Gini: "+fmt.Sprintf("%#v", this.Gini)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LeafStat_GiniImpurityClassificationStats_DenseCounts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_tensorforest.LeafStat_GiniImpurityClassificationStats_DenseCounts{` +
		`DenseCounts:` + fmt.Sprintf("%#v", this.DenseCounts) + `}`}, ", ")
	return s
}
func (this *LeafStat_GiniImpurityClassificationStats_SparseCounts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_tensorforest.LeafStat_GiniImpurityClassificationStats_SparseCounts{` +
		`SparseCounts:` + fmt.Sprintf("%#v", this.SparseCounts) + `}`}, ", ")
	return s
}
func (this *LeafStat_LeastSquaresRegressionStats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_tensorforest.LeafStat_LeastSquaresRegressionStats{")
	if this.MeanOutput != nil {
		s = append(s, "MeanOutput: "+fmt.Sprintf("%#v", this.MeanOutput)+",\n")
	}
	if this.MeanOutputSquares != nil {
		s = append(s, "MeanOutputSquares: "+fmt.Sprintf("%#v", this.MeanOutputSquares)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FertileSlot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&tensorflow_tensorforest.FertileSlot{")
	if this.LeafStats != nil {
		s = append(s, "LeafStats: "+fmt.Sprintf("%#v", this.LeafStats)+",\n")
	}
	if this.Candidates != nil {
		s = append(s, "Candidates: "+fmt.Sprintf("%#v", this.Candidates)+",\n")
	}
	if this.PostInitLeafStats != nil {
		s = append(s, "PostInitLeafStats: "+fmt.Sprintf("%#v", this.PostInitLeafStats)+",\n")
	}
	s = append(s, "NodeId: "+fmt.Sprintf("%#v", this.NodeId)+",\n")
	s = append(s, "Depth: "+fmt.Sprintf("%#v", this.Depth)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SplitCandidate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_tensorforest.SplitCandidate{")
	if this.Split != nil {
		s = append(s, "Split: "+fmt.Sprintf("%#v", this.Split)+",\n")
	}
	if this.LeftStats != nil {
		s = append(s, "LeftStats: "+fmt.Sprintf("%#v", this.LeftStats)+",\n")
	}
	if this.RightStats != nil {
		s = append(s, "RightStats: "+fmt.Sprintf("%#v", this.RightStats)+",\n")
	}
	s = append(s, "UniqueId: "+fmt.Sprintf("%#v", this.UniqueId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreePath) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_tensorforest.TreePath{")
	if this.NodesVisited != nil {
		s = append(s, "NodesVisited: "+fmt.Sprintf("%#v", this.NodesVisited)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringFertileStats(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *FertileStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FertileStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeToSlot) > 0 {
		for _, msg := range m.NodeToSlot {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFertileStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GiniStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiniStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Square != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32FertileStats(dAtA, i, uint32(math.Float32bits(float32(m.Square))))
	}
	return i, nil
}

func (m *LeafStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeafStat != nil {
		nn1, err := m.LeafStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.WeightSum != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32FertileStats(dAtA, i, uint32(math.Float32bits(float32(m.WeightSum))))
	}
	return i, nil
}

func (m *LeafStat_Classification) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Classification != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.Classification.Size()))
		n2, err := m.Classification.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *LeafStat_Regression) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Regression != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.Regression.Size()))
		n3, err := m.Regression.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *LeafStat_GiniImpurityClassificationStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafStat_GiniImpurityClassificationStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Counts != nil {
		nn4, err := m.Counts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn4
	}
	if m.Gini != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.Gini.Size()))
		n5, err := m.Gini.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *LeafStat_GiniImpurityClassificationStats_DenseCounts) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DenseCounts != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.DenseCounts.Size()))
		n6, err := m.DenseCounts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *LeafStat_GiniImpurityClassificationStats_SparseCounts) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SparseCounts != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.SparseCounts.Size()))
		n7, err := m.SparseCounts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *LeafStat_LeastSquaresRegressionStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafStat_LeastSquaresRegressionStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MeanOutput != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.MeanOutput.Size()))
		n8, err := m.MeanOutput.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.MeanOutputSquares != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.MeanOutputSquares.Size()))
		n9, err := m.MeanOutputSquares.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *FertileSlot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FertileSlot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Candidates) > 0 {
		for _, msg := range m.Candidates {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFertileStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LeafStats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.LeafStats.Size()))
		n10, err := m.LeafStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.NodeId))
	}
	if m.PostInitLeafStats != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.PostInitLeafStats.Size()))
		n11, err := m.PostInitLeafStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Depth != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.Depth))
	}
	return i, nil
}

func (m *SplitCandidate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitCandidate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Split != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.Split.Size()))
		n12, err := m.Split.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.LeftStats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.LeftStats.Size()))
		n13, err := m.LeftStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.RightStats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(m.RightStats.Size()))
		n14, err := m.RightStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.UniqueId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintFertileStats(dAtA, i, uint64(len(m.UniqueId)))
		i += copy(dAtA[i:], m.UniqueId)
	}
	return i, nil
}

func (m *TreePath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreePath) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodesVisited) > 0 {
		for _, msg := range m.NodesVisited {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFertileStats(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64FertileStats(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32FertileStats(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFertileStats(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FertileStats) Size() (n int) {
	var l int
	_ = l
	if len(m.NodeToSlot) > 0 {
		for _, e := range m.NodeToSlot {
			l = e.Size()
			n += 1 + l + sovFertileStats(uint64(l))
		}
	}
	return n
}

func (m *GiniStats) Size() (n int) {
	var l int
	_ = l
	if m.Square != 0 {
		n += 5
	}
	return n
}

func (m *LeafStat) Size() (n int) {
	var l int
	_ = l
	if m.LeafStat != nil {
		n += m.LeafStat.Size()
	}
	if m.WeightSum != 0 {
		n += 5
	}
	return n
}

func (m *LeafStat_Classification) Size() (n int) {
	var l int
	_ = l
	if m.Classification != nil {
		l = m.Classification.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	return n
}
func (m *LeafStat_Regression) Size() (n int) {
	var l int
	_ = l
	if m.Regression != nil {
		l = m.Regression.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	return n
}
func (m *LeafStat_GiniImpurityClassificationStats) Size() (n int) {
	var l int
	_ = l
	if m.Counts != nil {
		n += m.Counts.Size()
	}
	if m.Gini != nil {
		l = m.Gini.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	return n
}

func (m *LeafStat_GiniImpurityClassificationStats_DenseCounts) Size() (n int) {
	var l int
	_ = l
	if m.DenseCounts != nil {
		l = m.DenseCounts.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	return n
}
func (m *LeafStat_GiniImpurityClassificationStats_SparseCounts) Size() (n int) {
	var l int
	_ = l
	if m.SparseCounts != nil {
		l = m.SparseCounts.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	return n
}
func (m *LeafStat_LeastSquaresRegressionStats) Size() (n int) {
	var l int
	_ = l
	if m.MeanOutput != nil {
		l = m.MeanOutput.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	if m.MeanOutputSquares != nil {
		l = m.MeanOutputSquares.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	return n
}

func (m *FertileSlot) Size() (n int) {
	var l int
	_ = l
	if len(m.Candidates) > 0 {
		for _, e := range m.Candidates {
			l = e.Size()
			n += 1 + l + sovFertileStats(uint64(l))
		}
	}
	if m.LeafStats != nil {
		l = m.LeafStats.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	if m.NodeId != 0 {
		n += 1 + sovFertileStats(uint64(m.NodeId))
	}
	if m.PostInitLeafStats != nil {
		l = m.PostInitLeafStats.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	if m.Depth != 0 {
		n += 1 + sovFertileStats(uint64(m.Depth))
	}
	return n
}

func (m *SplitCandidate) Size() (n int) {
	var l int
	_ = l
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	if m.LeftStats != nil {
		l = m.LeftStats.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	if m.RightStats != nil {
		l = m.RightStats.Size()
		n += 1 + l + sovFertileStats(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovFertileStats(uint64(l))
	}
	return n
}

func (m *TreePath) Size() (n int) {
	var l int
	_ = l
	if len(m.NodesVisited) > 0 {
		for _, e := range m.NodesVisited {
			l = e.Size()
			n += 1 + l + sovFertileStats(uint64(l))
		}
	}
	return n
}

func sovFertileStats(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFertileStats(x uint64) (n int) {
	return sovFertileStats(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *FertileStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FertileStats{`,
		`NodeToSlot:` + strings.Replace(fmt.Sprintf("%v", this.NodeToSlot), "FertileSlot", "FertileSlot", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GiniStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GiniStats{`,
		`Square:` + fmt.Sprintf("%v", this.Square) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeafStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeafStat{`,
		`LeafStat:` + fmt.Sprintf("%v", this.LeafStat) + `,`,
		`WeightSum:` + fmt.Sprintf("%v", this.WeightSum) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeafStat_Classification) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeafStat_Classification{`,
		`Classification:` + strings.Replace(fmt.Sprintf("%v", this.Classification), "LeafStat_GiniImpurityClassificationStats", "LeafStat_GiniImpurityClassificationStats", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeafStat_Regression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeafStat_Regression{`,
		`Regression:` + strings.Replace(fmt.Sprintf("%v", this.Regression), "LeafStat_LeastSquaresRegressionStats", "LeafStat_LeastSquaresRegressionStats", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeafStat_GiniImpurityClassificationStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeafStat_GiniImpurityClassificationStats{`,
		`Counts:` + fmt.Sprintf("%v", this.Counts) + `,`,
		`Gini:` + strings.Replace(fmt.Sprintf("%v", this.Gini), "GiniStats", "GiniStats", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeafStat_GiniImpurityClassificationStats_DenseCounts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeafStat_GiniImpurityClassificationStats_DenseCounts{`,
		`DenseCounts:` + strings.Replace(fmt.Sprintf("%v", this.DenseCounts), "Vector", "tensorflow_decision_trees.Vector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeafStat_GiniImpurityClassificationStats_SparseCounts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeafStat_GiniImpurityClassificationStats_SparseCounts{`,
		`SparseCounts:` + strings.Replace(fmt.Sprintf("%v", this.SparseCounts), "SparseVector", "tensorflow_decision_trees.SparseVector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeafStat_LeastSquaresRegressionStats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeafStat_LeastSquaresRegressionStats{`,
		`MeanOutput:` + strings.Replace(fmt.Sprintf("%v", this.MeanOutput), "Vector", "tensorflow_decision_trees.Vector", 1) + `,`,
		`MeanOutputSquares:` + strings.Replace(fmt.Sprintf("%v", this.MeanOutputSquares), "Vector", "tensorflow_decision_trees.Vector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FertileSlot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FertileSlot{`,
		`Candidates:` + strings.Replace(fmt.Sprintf("%v", this.Candidates), "SplitCandidate", "SplitCandidate", 1) + `,`,
		`LeafStats:` + strings.Replace(fmt.Sprintf("%v", this.LeafStats), "LeafStat", "LeafStat", 1) + `,`,
		`NodeId:` + fmt.Sprintf("%v", this.NodeId) + `,`,
		`PostInitLeafStats:` + strings.Replace(fmt.Sprintf("%v", this.PostInitLeafStats), "LeafStat", "LeafStat", 1) + `,`,
		`Depth:` + fmt.Sprintf("%v", this.Depth) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SplitCandidate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SplitCandidate{`,
		`Split:` + strings.Replace(fmt.Sprintf("%v", this.Split), "BinaryNode", "tensorflow_decision_trees.BinaryNode", 1) + `,`,
		`LeftStats:` + strings.Replace(fmt.Sprintf("%v", this.LeftStats), "LeafStat", "LeafStat", 1) + `,`,
		`RightStats:` + strings.Replace(fmt.Sprintf("%v", this.RightStats), "LeafStat", "LeafStat", 1) + `,`,
		`UniqueId:` + fmt.Sprintf("%v", this.UniqueId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreePath) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreePath{`,
		`NodesVisited:` + strings.Replace(fmt.Sprintf("%v", this.NodesVisited), "TreeNode", "tensorflow_decision_trees.TreeNode", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringFertileStats(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *FertileStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FertileStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FertileStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeToSlot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeToSlot = append(m.NodeToSlot, &FertileSlot{})
			if err := m.NodeToSlot[len(m.NodeToSlot)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFertileStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFertileStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiniStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiniStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiniStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Square", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Square = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFertileStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFertileStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Classification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LeafStat_GiniImpurityClassificationStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LeafStat = &LeafStat_Classification{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LeafStat_LeastSquaresRegressionStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LeafStat = &LeafStat_Regression{v}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightSum", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.WeightSum = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFertileStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFertileStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafStat_GiniImpurityClassificationStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiniImpurityClassificationStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiniImpurityClassificationStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &tensorflow_decision_trees.Vector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Counts = &LeafStat_GiniImpurityClassificationStats_DenseCounts{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &tensorflow_decision_trees.SparseVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Counts = &LeafStat_GiniImpurityClassificationStats_SparseCounts{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gini", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gini == nil {
				m.Gini = &GiniStats{}
			}
			if err := m.Gini.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFertileStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFertileStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafStat_LeastSquaresRegressionStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeastSquaresRegressionStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeastSquaresRegressionStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanOutput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeanOutput == nil {
				m.MeanOutput = &tensorflow_decision_trees.Vector{}
			}
			if err := m.MeanOutput.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeanOutputSquares", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeanOutputSquares == nil {
				m.MeanOutputSquares = &tensorflow_decision_trees.Vector{}
			}
			if err := m.MeanOutputSquares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFertileStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFertileStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FertileSlot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FertileSlot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FertileSlot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Candidates = append(m.Candidates, &SplitCandidate{})
			if err := m.Candidates[len(m.Candidates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeafStats == nil {
				m.LeafStats = &LeafStat{}
			}
			if err := m.LeafStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostInitLeafStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PostInitLeafStats == nil {
				m.PostInitLeafStats = &LeafStat{}
			}
			if err := m.PostInitLeafStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			m.Depth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Depth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFertileStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFertileStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitCandidate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitCandidate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitCandidate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &tensorflow_decision_trees.BinaryNode{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftStats == nil {
				m.LeftStats = &LeafStat{}
			}
			if err := m.LeftStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightStats == nil {
				m.RightStats = &LeafStat{}
			}
			if err := m.RightStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFertileStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFertileStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreePath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreePath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreePath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodesVisited", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFertileStats
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodesVisited = append(m.NodesVisited, &tensorflow_decision_trees.TreeNode{})
			if err := m.NodesVisited[len(m.NodesVisited)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFertileStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFertileStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFertileStats(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFertileStats
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFertileStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFertileStats
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFertileStats
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFertileStats(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFertileStats = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFertileStats   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/contrib/tensor_forest/proto/fertile_stats.proto", fileDescriptorFertileStats)
}

var fileDescriptorFertileStats = []byte{
	// 725 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4f, 0x4f, 0xdb, 0x48,
	0x14, 0xcf, 0x00, 0x09, 0xc9, 0x33, 0x20, 0xe1, 0x45, 0x4b, 0x04, 0x5a, 0x6f, 0x36, 0xec, 0x8a,
	0x9c, 0x12, 0x29, 0x2b, 0xed, 0x65, 0xb5, 0x12, 0x9b, 0x48, 0x40, 0x24, 0x44, 0x5b, 0x07, 0x71,
	0xb5, 0x8c, 0x3d, 0x0e, 0xa3, 0x3a, 0x33, 0x61, 0xe6, 0xb9, 0x88, 0x5b, 0x3f, 0x42, 0xef, 0xfd,
	0x02, 0xfd, 0x00, 0xbd, 0xf4, 0x1b, 0xf4, 0xc8, 0xb1, 0xc7, 0x92, 0x5e, 0x7a, 0xe4, 0x58, 0xa9,
	0x97, 0xca, 0x33, 0x4e, 0x08, 0x2d, 0x09, 0x51, 0x6f, 0x9e, 0xa7, 0xf9, 0xfd, 0x79, 0xbf, 0xf7,
	0xc6, 0xd0, 0x1e, 0x48, 0x81, 0xe2, 0x2c, 0x89, 0x1a, 0x48, 0xb9, 0x12, 0x32, 0x8a, 0xc5, 0x65,
	0x23, 0x10, 0x1c, 0x25, 0x3b, 0xcb, 0x4a, 0x5e, 0x24, 0x24, 0x55, 0xd8, 0xd0, 0x37, 0x1b, 0x11,
	0x95, 0xc8, 0x62, 0xea, 0x29, 0xf4, 0x51, 0xd5, 0x75, 0xcd, 0xde, 0xbc, 0xc3, 0xd6, 0xb3, 0x4f,
	0x0d, 0xd9, 0xda, 0x7b, 0x80, 0x34, 0xa4, 0x01, 0x53, 0x4c, 0x70, 0x0f, 0x25, 0xa5, 0x2a, 0x63,
	0xed, 0x51, 0x4e, 0x25, 0x0b, 0x74, 0xcd, 0xeb, 0x8b, 0x90, 0xc6, 0x86, 0xba, 0x7a, 0x0a, 0x2b,
	0xfb, 0x46, 0xb1, 0x9b, 0x0a, 0xda, 0xfb, 0xb0, 0xc2, 0x45, 0x48, 0x3d, 0x14, 0x9e, 0x8a, 0x05,
	0x96, 0x49, 0x65, 0xb1, 0x66, 0x35, 0xff, 0xac, 0x4f, 0x71, 0x50, 0x1f, 0x81, 0x63, 0x81, 0x2e,
	0xa4, 0xc8, 0x13, 0x91, 0x7e, 0x57, 0x77, 0xa0, 0x74, 0xc0, 0x38, 0x33, 0xa4, 0xbf, 0x42, 0x41,
	0x5d, 0x24, 0xbe, 0xa4, 0xe5, 0x85, 0x0a, 0xa9, 0x2d, 0xb8, 0xd9, 0xa9, 0xfa, 0x2e, 0x0f, 0xc5,
	0x23, 0xea, 0x47, 0xe9, 0x2d, 0xfb, 0x39, 0xac, 0x05, 0xb1, 0xaf, 0x14, 0x8b, 0x58, 0xe0, 0x23,
	0x13, 0xbc, 0x4c, 0x2a, 0xa4, 0x66, 0x35, 0xff, 0x9f, 0xaa, 0x3d, 0x82, 0xd6, 0x53, 0xa5, 0x4e,
	0x7f, 0x90, 0x48, 0x86, 0x57, 0xed, 0x7b, 0x1c, 0x5a, 0xff, 0x30, 0xe7, 0x7e, 0x47, 0x6d, 0x7b,
	0x00, 0x92, 0xf6, 0x24, 0x55, 0x69, 0x52, 0xda, 0x95, 0xd5, 0xfc, 0xef, 0x71, 0xa1, 0x23, 0xea,
	0x2b, 0xec, 0x6a, 0xf3, 0xca, 0x1d, 0xe3, 0x47, 0x22, 0x13, 0x94, 0xf6, 0x6f, 0x00, 0x97, 0x94,
	0xf5, 0xce, 0xd1, 0x53, 0x49, 0xbf, 0xbc, 0xa8, 0xdb, 0x2e, 0x99, 0x4a, 0x37, 0xe9, 0x6f, 0x7d,
	0x25, 0xf0, 0xfb, 0x23, 0xae, 0xd3, 0x51, 0x84, 0x94, 0x2b, 0xea, 0x05, 0x22, 0xe1, 0xa8, 0xb2,
	0x38, 0xfe, 0x98, 0x74, 0x79, 0x7f, 0xd6, 0xf5, 0x53, 0x1a, 0xa0, 0x90, 0x87, 0x39, 0xd7, 0xd2,
	0xc0, 0xb6, 0xc6, 0xd9, 0xc7, 0xb0, 0xaa, 0x06, 0xbe, 0xbc, 0x23, 0x32, 0xed, 0xee, 0xce, 0x20,
	0xea, 0xea, 0xfb, 0x63, 0xba, 0x15, 0x83, 0xcf, 0xf8, 0xfe, 0x81, 0xa5, 0x1e, 0xe3, 0x4c, 0x37,
	0x65, 0x35, 0xab, 0x53, 0x53, 0x1b, 0xcf, 0xdf, 0xd5, 0xf7, 0x5b, 0x45, 0x28, 0x18, 0x03, 0x5b,
	0x6f, 0x09, 0x6c, 0xcf, 0x88, 0xd2, 0x6e, 0x81, 0xd5, 0xa7, 0x3e, 0xf7, 0x44, 0x82, 0x83, 0x04,
	0xe7, 0x6e, 0xdc, 0x85, 0x14, 0xf5, 0x44, 0x83, 0xec, 0x67, 0xf0, 0xcb, 0x04, 0x87, 0x67, 0x36,
	0x6e, 0xd4, 0xfb, 0x1c, 0x5c, 0xeb, 0x77, 0x5c, 0x99, 0xcb, 0x96, 0x05, 0xa5, 0x98, 0xfa, 0x91,
	0x7e, 0x9a, 0xd5, 0xd7, 0x0b, 0x60, 0x4d, 0x2c, 0xbf, 0x7d, 0x00, 0x10, 0xf8, 0x3c, 0x64, 0xa1,
	0x8f, 0x54, 0x65, 0xcf, 0x66, 0x77, 0x6a, 0x36, 0xdd, 0x41, 0xcc, 0xb0, 0x3d, 0xba, 0xef, 0x4e,
	0x40, 0xed, 0x3d, 0x80, 0xb1, 0x8a, 0x2a, 0x2f, 0xfd, 0xe8, 0xf7, 0xc1, 0xd5, 0x74, 0xb5, 0x35,
	0x13, 0xdf, 0x26, 0x2c, 0xeb, 0x37, 0xcc, 0xc2, 0x72, 0xbe, 0x42, 0x6a, 0x79, 0xb7, 0x90, 0x1e,
	0x3b, 0xa1, 0xed, 0xc2, 0xc6, 0x40, 0x28, 0xf4, 0x18, 0x67, 0xe8, 0x4d, 0x88, 0x14, 0xe6, 0x15,
	0x59, 0x4f, 0xe1, 0x1d, 0xce, 0xf0, 0x68, 0x2c, 0xb6, 0x01, 0xf9, 0x90, 0x0e, 0xf0, 0xbc, 0xbc,
	0xac, 0xa5, 0xcc, 0xa1, 0x7a, 0x4b, 0x60, 0xed, 0x7e, 0x8f, 0xf6, 0xbf, 0x90, 0x57, 0x69, 0x25,
	0x1b, 0xe7, 0x5f, 0x33, 0x46, 0xd0, 0x62, 0xdc, 0x97, 0x57, 0xc7, 0x22, 0xa4, 0xae, 0xc1, 0x98,
	0x50, 0x22, 0xfc, 0x89, 0x50, 0x22, 0x1c, 0xef, 0x94, 0x34, 0xef, 0x51, 0x53, 0xe4, 0xe7, 0xa5,
	0x00, 0x8d, 0x32, 0x1c, 0xdb, 0x50, 0x4a, 0x38, 0xbb, 0x48, 0x74, 0xb4, 0x69, 0x68, 0x25, 0xb7,
	0x68, 0x0a, 0x9d, 0xb0, 0x7a, 0x02, 0xc5, 0x13, 0x49, 0xe9, 0x53, 0x1f, 0xcf, 0xed, 0x43, 0x58,
	0x4d, 0x23, 0x57, 0xde, 0x0b, 0xa6, 0x18, 0xd2, 0x30, 0xdb, 0x87, 0x9d, 0x19, 0x3d, 0xa7, 0x58,
	0xdd, 0xb1, 0xfe, 0xff, 0xaa, 0x53, 0x03, 0x6c, 0x35, 0xae, 0x6f, 0x9c, 0xdc, 0x87, 0x1b, 0x27,
	0x77, 0x7b, 0xe3, 0x90, 0x97, 0x43, 0x87, 0xbc, 0x19, 0x3a, 0xe4, 0xfd, 0xd0, 0x21, 0xd7, 0x43,
	0x87, 0x7c, 0x1c, 0x3a, 0xe4, 0xf3, 0xd0, 0xc9, 0xdd, 0x0e, 0x1d, 0xf2, 0xea, 0x93, 0x93, 0xfb,
	0x42, 0xc8, 0x59, 0x41, 0xff, 0xd7, 0xff, 0xfe, 0x16, 0x00, 0x00, 0xff, 0xff, 0x9b, 0x18, 0x40,
	0x78, 0x79, 0x06, 0x00, 0x00,
}
