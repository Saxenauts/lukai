// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/contrib/tensor_forest/proto/tensor_forest_params.proto

/*
	Package tensorflow_tensorforest is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/contrib/tensor_forest/proto/tensor_forest_params.proto

	It has these top-level messages:
		SplitPruningConfig
		SplitFinishConfig
		LinearParam
		ExponentialParam
		ThresholdParam
		DepthDependentParam
		TensorForestParams
*/
package tensorflow_tensorforest

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import tensorflow_decision_trees "github.com/d4l3k/pok/protobuf/tensorflow/contrib/decision_trees/proto"

import strconv "strconv"

import fmt "fmt"
import strings "strings"
import reflect "reflect"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Leaf models specify what is returned at inference time, and how it is
// stored in the decision_trees.Leaf protos.
type LeafModelType int32

const (
	MODEL_DENSE_CLASSIFICATION           LeafModelType = 0
	MODEL_SPARSE_CLASSIFICATION          LeafModelType = 1
	MODEL_REGRESSION                     LeafModelType = 2
	MODEL_SPARSE_OR_DENSE_CLASSIFICATION LeafModelType = 3
)

var LeafModelType_name = map[int32]string{
	0: "MODEL_DENSE_CLASSIFICATION",
	1: "MODEL_SPARSE_CLASSIFICATION",
	2: "MODEL_REGRESSION",
	3: "MODEL_SPARSE_OR_DENSE_CLASSIFICATION",
}
var LeafModelType_value = map[string]int32{
	"MODEL_DENSE_CLASSIFICATION":           0,
	"MODEL_SPARSE_CLASSIFICATION":          1,
	"MODEL_REGRESSION":                     2,
	"MODEL_SPARSE_OR_DENSE_CLASSIFICATION": 3,
}

func (LeafModelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{0}
}

// Stats models generally specify information that is collected which is
// necessary to choose a split at a node. Specifically, they operate on
// a SplitCandidate::LeafStat proto.
type StatsModelType int32

const (
	STATS_DENSE_GINI               StatsModelType = 0
	STATS_SPARSE_GINI              StatsModelType = 1
	STATS_LEAST_SQUARES_REGRESSION StatsModelType = 2
	STATS_SPARSE_THEN_DENSE_GINI   StatsModelType = 3
)

var StatsModelType_name = map[int32]string{
	0: "STATS_DENSE_GINI",
	1: "STATS_SPARSE_GINI",
	2: "STATS_LEAST_SQUARES_REGRESSION",
	3: "STATS_SPARSE_THEN_DENSE_GINI",
}
var StatsModelType_value = map[string]int32{
	"STATS_DENSE_GINI":               0,
	"STATS_SPARSE_GINI":              1,
	"STATS_LEAST_SQUARES_REGRESSION": 2,
	"STATS_SPARSE_THEN_DENSE_GINI":   3,
}

func (StatsModelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{1}
}

// Allows selection of operations on the collection of split candidates.
// Basic infers right split stats from the leaf stats and each candidate's
// left stats.
type SplitCollectionType int32

const (
	COLLECTION_BASIC        SplitCollectionType = 0
	GRAPH_RUNNER_COLLECTION SplitCollectionType = 1
)

var SplitCollectionType_name = map[int32]string{
	0: "COLLECTION_BASIC",
	1: "GRAPH_RUNNER_COLLECTION",
}
var SplitCollectionType_value = map[string]int32{
	"COLLECTION_BASIC":        0,
	"GRAPH_RUNNER_COLLECTION": 1,
}

func (SplitCollectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{2}
}

// Pruning strategies define how candidates are pruned over time.
// SPLIT_PRUNE_HALF prunes the worst half of splits every prune_ever_samples,
// etc.  Note that prune_every_samples plays against the depth-dependent
// split_after_samples, so they should be set together.
type SplitPruningStrategyType int32

const (
	SPLIT_PRUNE_NONE       SplitPruningStrategyType = 0
	SPLIT_PRUNE_HALF       SplitPruningStrategyType = 1
	SPLIT_PRUNE_QUARTER    SplitPruningStrategyType = 2
	SPLIT_PRUNE_10_PERCENT SplitPruningStrategyType = 3
	// SPLIT_PRUNE_HOEFFDING prunes splits whose Gini impurity is worst than
	// the best split's by more than the Hoeffding bound.
	SPLIT_PRUNE_HOEFFDING SplitPruningStrategyType = 4
)

var SplitPruningStrategyType_name = map[int32]string{
	0: "SPLIT_PRUNE_NONE",
	1: "SPLIT_PRUNE_HALF",
	2: "SPLIT_PRUNE_QUARTER",
	3: "SPLIT_PRUNE_10_PERCENT",
	4: "SPLIT_PRUNE_HOEFFDING",
}
var SplitPruningStrategyType_value = map[string]int32{
	"SPLIT_PRUNE_NONE":       0,
	"SPLIT_PRUNE_HALF":       1,
	"SPLIT_PRUNE_QUARTER":    2,
	"SPLIT_PRUNE_10_PERCENT": 3,
	"SPLIT_PRUNE_HOEFFDING":  4,
}

func (SplitPruningStrategyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{3}
}

// Finish strategies define when slots are considered finished.
// Basic requires at least split_after_samples, and doesn't allow slots to
// finish until the leaf has received more than one class. Hoeffding splits
// early after min_split_samples if one split is dominating the rest according
// to hoeffding bounds. Bootstrap does the same but compares gini's calculated
// with sampled smoothed counts.
type SplitFinishStrategyType int32

const (
	SPLIT_FINISH_BASIC              SplitFinishStrategyType = 0
	SPLIT_FINISH_DOMINATE_HOEFFDING SplitFinishStrategyType = 2
	SPLIT_FINISH_DOMINATE_BOOTSTRAP SplitFinishStrategyType = 3
)

var SplitFinishStrategyType_name = map[int32]string{
	0: "SPLIT_FINISH_BASIC",
	2: "SPLIT_FINISH_DOMINATE_HOEFFDING",
	3: "SPLIT_FINISH_DOMINATE_BOOTSTRAP",
}
var SplitFinishStrategyType_value = map[string]int32{
	"SPLIT_FINISH_BASIC":              0,
	"SPLIT_FINISH_DOMINATE_HOEFFDING": 2,
	"SPLIT_FINISH_DOMINATE_BOOTSTRAP": 3,
}

func (SplitFinishStrategyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{4}
}

type SplitPruningConfig struct {
	PruneEverySamples *DepthDependentParam     `protobuf:"bytes,1,opt,name=prune_every_samples,json=pruneEverySamples" json:"prune_every_samples,omitempty"`
	Type              SplitPruningStrategyType `protobuf:"varint,2,opt,name=type,proto3,enum=tensorflow.tensorforest.SplitPruningStrategyType" json:"type,omitempty"`
}

func (m *SplitPruningConfig) Reset()      { *m = SplitPruningConfig{} }
func (*SplitPruningConfig) ProtoMessage() {}
func (*SplitPruningConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{0}
}

func (m *SplitPruningConfig) GetPruneEverySamples() *DepthDependentParam {
	if m != nil {
		return m.PruneEverySamples
	}
	return nil
}

func (m *SplitPruningConfig) GetType() SplitPruningStrategyType {
	if m != nil {
		return m.Type
	}
	return SPLIT_PRUNE_NONE
}

type SplitFinishConfig struct {
	// Configure how often we check for finish, because some finish methods
	// are expensive to perform.
	CheckEverySteps *DepthDependentParam    `protobuf:"bytes,1,opt,name=check_every_steps,json=checkEverySteps" json:"check_every_steps,omitempty"`
	Type            SplitFinishStrategyType `protobuf:"varint,2,opt,name=type,proto3,enum=tensorflow.tensorforest.SplitFinishStrategyType" json:"type,omitempty"`
}

func (m *SplitFinishConfig) Reset()      { *m = SplitFinishConfig{} }
func (*SplitFinishConfig) ProtoMessage() {}
func (*SplitFinishConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{1}
}

func (m *SplitFinishConfig) GetCheckEverySteps() *DepthDependentParam {
	if m != nil {
		return m.CheckEverySteps
	}
	return nil
}

func (m *SplitFinishConfig) GetType() SplitFinishStrategyType {
	if m != nil {
		return m.Type
	}
	return SPLIT_FINISH_BASIC
}

// A parameter that changes linearly with depth, with upper and lower bounds.
type LinearParam struct {
	Slope      float32 `protobuf:"fixed32,1,opt,name=slope,proto3" json:"slope,omitempty"`
	YIntercept float32 `protobuf:"fixed32,2,opt,name=y_intercept,json=yIntercept,proto3" json:"y_intercept,omitempty"`
	MinVal     float32 `protobuf:"fixed32,3,opt,name=min_val,json=minVal,proto3" json:"min_val,omitempty"`
	MaxVal     float32 `protobuf:"fixed32,4,opt,name=max_val,json=maxVal,proto3" json:"max_val,omitempty"`
}

func (m *LinearParam) Reset()                    { *m = LinearParam{} }
func (*LinearParam) ProtoMessage()               {}
func (*LinearParam) Descriptor() ([]byte, []int) { return fileDescriptorTensorForestParams, []int{2} }

func (m *LinearParam) GetSlope() float32 {
	if m != nil {
		return m.Slope
	}
	return 0
}

func (m *LinearParam) GetYIntercept() float32 {
	if m != nil {
		return m.YIntercept
	}
	return 0
}

func (m *LinearParam) GetMinVal() float32 {
	if m != nil {
		return m.MinVal
	}
	return 0
}

func (m *LinearParam) GetMaxVal() float32 {
	if m != nil {
		return m.MaxVal
	}
	return 0
}

// A parameter that changes expoentially with the form
//     f = c + mb^(k*d)
// where:
//  c: constant bias
//  b: base
//  m: multiplier
//  k: depth multiplier
//  d: depth
type ExponentialParam struct {
	Bias            float32 `protobuf:"fixed32,1,opt,name=bias,proto3" json:"bias,omitempty"`
	Base            float32 `protobuf:"fixed32,2,opt,name=base,proto3" json:"base,omitempty"`
	Multiplier      float32 `protobuf:"fixed32,3,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
	DepthMultiplier float32 `protobuf:"fixed32,4,opt,name=depth_multiplier,json=depthMultiplier,proto3" json:"depth_multiplier,omitempty"`
}

func (m *ExponentialParam) Reset()      { *m = ExponentialParam{} }
func (*ExponentialParam) ProtoMessage() {}
func (*ExponentialParam) Descriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{3}
}

func (m *ExponentialParam) GetBias() float32 {
	if m != nil {
		return m.Bias
	}
	return 0
}

func (m *ExponentialParam) GetBase() float32 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *ExponentialParam) GetMultiplier() float32 {
	if m != nil {
		return m.Multiplier
	}
	return 0
}

func (m *ExponentialParam) GetDepthMultiplier() float32 {
	if m != nil {
		return m.DepthMultiplier
	}
	return 0
}

// A parameter that is 'off' until depth >= a threshold, then is 'on'.
type ThresholdParam struct {
	OnValue   float32 `protobuf:"fixed32,1,opt,name=on_value,json=onValue,proto3" json:"on_value,omitempty"`
	OffValue  float32 `protobuf:"fixed32,2,opt,name=off_value,json=offValue,proto3" json:"off_value,omitempty"`
	Threshold float32 `protobuf:"fixed32,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
}

func (m *ThresholdParam) Reset()                    { *m = ThresholdParam{} }
func (*ThresholdParam) ProtoMessage()               {}
func (*ThresholdParam) Descriptor() ([]byte, []int) { return fileDescriptorTensorForestParams, []int{4} }

func (m *ThresholdParam) GetOnValue() float32 {
	if m != nil {
		return m.OnValue
	}
	return 0
}

func (m *ThresholdParam) GetOffValue() float32 {
	if m != nil {
		return m.OffValue
	}
	return 0
}

func (m *ThresholdParam) GetThreshold() float32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// A parameter that may change with node depth.
type DepthDependentParam struct {
	// Types that are valid to be assigned to ParamType:
	//	*DepthDependentParam_ConstantValue
	//	*DepthDependentParam_Linear
	//	*DepthDependentParam_Exponential
	//	*DepthDependentParam_Threshold
	ParamType isDepthDependentParam_ParamType `protobuf_oneof:"ParamType"`
}

func (m *DepthDependentParam) Reset()      { *m = DepthDependentParam{} }
func (*DepthDependentParam) ProtoMessage() {}
func (*DepthDependentParam) Descriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{5}
}

type isDepthDependentParam_ParamType interface {
	isDepthDependentParam_ParamType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DepthDependentParam_ConstantValue struct {
	ConstantValue float32 `protobuf:"fixed32,1,opt,name=constant_value,json=constantValue,proto3,oneof"`
}
type DepthDependentParam_Linear struct {
	Linear *LinearParam `protobuf:"bytes,2,opt,name=linear,oneof"`
}
type DepthDependentParam_Exponential struct {
	Exponential *ExponentialParam `protobuf:"bytes,3,opt,name=exponential,oneof"`
}
type DepthDependentParam_Threshold struct {
	Threshold *ThresholdParam `protobuf:"bytes,4,opt,name=threshold,oneof"`
}

func (*DepthDependentParam_ConstantValue) isDepthDependentParam_ParamType() {}
func (*DepthDependentParam_Linear) isDepthDependentParam_ParamType()        {}
func (*DepthDependentParam_Exponential) isDepthDependentParam_ParamType()   {}
func (*DepthDependentParam_Threshold) isDepthDependentParam_ParamType()     {}

func (m *DepthDependentParam) GetParamType() isDepthDependentParam_ParamType {
	if m != nil {
		return m.ParamType
	}
	return nil
}

func (m *DepthDependentParam) GetConstantValue() float32 {
	if x, ok := m.GetParamType().(*DepthDependentParam_ConstantValue); ok {
		return x.ConstantValue
	}
	return 0
}

func (m *DepthDependentParam) GetLinear() *LinearParam {
	if x, ok := m.GetParamType().(*DepthDependentParam_Linear); ok {
		return x.Linear
	}
	return nil
}

func (m *DepthDependentParam) GetExponential() *ExponentialParam {
	if x, ok := m.GetParamType().(*DepthDependentParam_Exponential); ok {
		return x.Exponential
	}
	return nil
}

func (m *DepthDependentParam) GetThreshold() *ThresholdParam {
	if x, ok := m.GetParamType().(*DepthDependentParam_Threshold); ok {
		return x.Threshold
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DepthDependentParam) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DepthDependentParam_OneofMarshaler, _DepthDependentParam_OneofUnmarshaler, _DepthDependentParam_OneofSizer, []interface{}{
		(*DepthDependentParam_ConstantValue)(nil),
		(*DepthDependentParam_Linear)(nil),
		(*DepthDependentParam_Exponential)(nil),
		(*DepthDependentParam_Threshold)(nil),
	}
}

func _DepthDependentParam_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DepthDependentParam)
	// ParamType
	switch x := m.ParamType.(type) {
	case *DepthDependentParam_ConstantValue:
		_ = b.EncodeVarint(1<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.ConstantValue)))
	case *DepthDependentParam_Linear:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Linear); err != nil {
			return err
		}
	case *DepthDependentParam_Exponential:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Exponential); err != nil {
			return err
		}
	case *DepthDependentParam_Threshold:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Threshold); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DepthDependentParam.ParamType has unexpected type %T", x)
	}
	return nil
}

func _DepthDependentParam_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DepthDependentParam)
	switch tag {
	case 1: // ParamType.constant_value
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.ParamType = &DepthDependentParam_ConstantValue{math.Float32frombits(uint32(x))}
		return true, err
	case 2: // ParamType.linear
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LinearParam)
		err := b.DecodeMessage(msg)
		m.ParamType = &DepthDependentParam_Linear{msg}
		return true, err
	case 3: // ParamType.exponential
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExponentialParam)
		err := b.DecodeMessage(msg)
		m.ParamType = &DepthDependentParam_Exponential{msg}
		return true, err
	case 4: // ParamType.threshold
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ThresholdParam)
		err := b.DecodeMessage(msg)
		m.ParamType = &DepthDependentParam_Threshold{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DepthDependentParam_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DepthDependentParam)
	// ParamType
	switch x := m.ParamType.(type) {
	case *DepthDependentParam_ConstantValue:
		n += proto.SizeVarint(1<<3 | proto.WireFixed32)
		n += 4
	case *DepthDependentParam_Linear:
		s := proto.Size(x.Linear)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DepthDependentParam_Exponential:
		s := proto.Size(x.Exponential)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DepthDependentParam_Threshold:
		s := proto.Size(x.Threshold)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TensorForestParams struct {
	// ------------ Types that control training subsystems ------ //
	LeafType       LeafModelType       `protobuf:"varint,1,opt,name=leaf_type,json=leafType,proto3,enum=tensorflow.tensorforest.LeafModelType" json:"leaf_type,omitempty"`
	StatsType      StatsModelType      `protobuf:"varint,2,opt,name=stats_type,json=statsType,proto3,enum=tensorflow.tensorforest.StatsModelType" json:"stats_type,omitempty"`
	CollectionType SplitCollectionType `protobuf:"varint,3,opt,name=collection_type,json=collectionType,proto3,enum=tensorflow.tensorforest.SplitCollectionType" json:"collection_type,omitempty"`
	PruningType    *SplitPruningConfig `protobuf:"bytes,4,opt,name=pruning_type,json=pruningType" json:"pruning_type,omitempty"`
	FinishType     *SplitFinishConfig  `protobuf:"bytes,5,opt,name=finish_type,json=finishType" json:"finish_type,omitempty"`
	// --------- Parameters that can't change by definition --------------- //
	NumTrees           int32                                         `protobuf:"varint,6,opt,name=num_trees,json=numTrees,proto3" json:"num_trees,omitempty"`
	MaxNodes           int32                                         `protobuf:"varint,7,opt,name=max_nodes,json=maxNodes,proto3" json:"max_nodes,omitempty"`
	NumFeatures        int32                                         `protobuf:"varint,21,opt,name=num_features,json=numFeatures,proto3" json:"num_features,omitempty"`
	InequalityTestType tensorflow_decision_trees.InequalityTest_Type `protobuf:"varint,19,opt,name=inequality_test_type,json=inequalityTestType,proto3,enum=tensorflow.decision_trees.InequalityTest_Type" json:"inequality_test_type,omitempty"`
	// Some booleans controlling execution
	IsRegression            bool `protobuf:"varint,8,opt,name=is_regression,json=isRegression,proto3" json:"is_regression,omitempty"`
	DropFinalClass          bool `protobuf:"varint,9,opt,name=drop_final_class,json=dropFinalClass,proto3" json:"drop_final_class,omitempty"`
	CollateExamples         bool `protobuf:"varint,10,opt,name=collate_examples,json=collateExamples,proto3" json:"collate_examples,omitempty"`
	CheckpointStats         bool `protobuf:"varint,11,opt,name=checkpoint_stats,json=checkpointStats,proto3" json:"checkpoint_stats,omitempty"`
	UseRunningStatsMethod   bool `protobuf:"varint,20,opt,name=use_running_stats_method,json=useRunningStatsMethod,proto3" json:"use_running_stats_method,omitempty"`
	InitializeAverageSplits bool `protobuf:"varint,22,opt,name=initialize_average_splits,json=initializeAverageSplits,proto3" json:"initialize_average_splits,omitempty"`
	InferenceTreePaths      bool `protobuf:"varint,23,opt,name=inference_tree_paths,json=inferenceTreePaths,proto3" json:"inference_tree_paths,omitempty"`
	// Number of classes (classification) or targets (regression)
	NumOutputs int32 `protobuf:"varint,12,opt,name=num_outputs,json=numOutputs,proto3" json:"num_outputs,omitempty"`
	// --------- Parameters that could be depth-dependent --------------- //
	NumSplitsToConsider *DepthDependentParam `protobuf:"bytes,13,opt,name=num_splits_to_consider,json=numSplitsToConsider" json:"num_splits_to_consider,omitempty"`
	SplitAfterSamples   *DepthDependentParam `protobuf:"bytes,14,opt,name=split_after_samples,json=splitAfterSamples" json:"split_after_samples,omitempty"`
	DominateFraction    *DepthDependentParam `protobuf:"bytes,15,opt,name=dominate_fraction,json=dominateFraction" json:"dominate_fraction,omitempty"`
	MinSplitSamples     *DepthDependentParam `protobuf:"bytes,18,opt,name=min_split_samples,json=minSplitSamples" json:"min_split_samples,omitempty"`
	// --------- Parameters for experimental features ---------------------- //
	GraphDir          string `protobuf:"bytes,16,opt,name=graph_dir,json=graphDir,proto3" json:"graph_dir,omitempty"`
	NumSelectFeatures int32  `protobuf:"varint,17,opt,name=num_select_features,json=numSelectFeatures,proto3" json:"num_select_features,omitempty"`
}

func (m *TensorForestParams) Reset()      { *m = TensorForestParams{} }
func (*TensorForestParams) ProtoMessage() {}
func (*TensorForestParams) Descriptor() ([]byte, []int) {
	return fileDescriptorTensorForestParams, []int{6}
}

func (m *TensorForestParams) GetLeafType() LeafModelType {
	if m != nil {
		return m.LeafType
	}
	return MODEL_DENSE_CLASSIFICATION
}

func (m *TensorForestParams) GetStatsType() StatsModelType {
	if m != nil {
		return m.StatsType
	}
	return STATS_DENSE_GINI
}

func (m *TensorForestParams) GetCollectionType() SplitCollectionType {
	if m != nil {
		return m.CollectionType
	}
	return COLLECTION_BASIC
}

func (m *TensorForestParams) GetPruningType() *SplitPruningConfig {
	if m != nil {
		return m.PruningType
	}
	return nil
}

func (m *TensorForestParams) GetFinishType() *SplitFinishConfig {
	if m != nil {
		return m.FinishType
	}
	return nil
}

func (m *TensorForestParams) GetNumTrees() int32 {
	if m != nil {
		return m.NumTrees
	}
	return 0
}

func (m *TensorForestParams) GetMaxNodes() int32 {
	if m != nil {
		return m.MaxNodes
	}
	return 0
}

func (m *TensorForestParams) GetNumFeatures() int32 {
	if m != nil {
		return m.NumFeatures
	}
	return 0
}

func (m *TensorForestParams) GetInequalityTestType() tensorflow_decision_trees.InequalityTest_Type {
	if m != nil {
		return m.InequalityTestType
	}
	return tensorflow_decision_trees.LESS_OR_EQUAL
}

func (m *TensorForestParams) GetIsRegression() bool {
	if m != nil {
		return m.IsRegression
	}
	return false
}

func (m *TensorForestParams) GetDropFinalClass() bool {
	if m != nil {
		return m.DropFinalClass
	}
	return false
}

func (m *TensorForestParams) GetCollateExamples() bool {
	if m != nil {
		return m.CollateExamples
	}
	return false
}

func (m *TensorForestParams) GetCheckpointStats() bool {
	if m != nil {
		return m.CheckpointStats
	}
	return false
}

func (m *TensorForestParams) GetUseRunningStatsMethod() bool {
	if m != nil {
		return m.UseRunningStatsMethod
	}
	return false
}

func (m *TensorForestParams) GetInitializeAverageSplits() bool {
	if m != nil {
		return m.InitializeAverageSplits
	}
	return false
}

func (m *TensorForestParams) GetInferenceTreePaths() bool {
	if m != nil {
		return m.InferenceTreePaths
	}
	return false
}

func (m *TensorForestParams) GetNumOutputs() int32 {
	if m != nil {
		return m.NumOutputs
	}
	return 0
}

func (m *TensorForestParams) GetNumSplitsToConsider() *DepthDependentParam {
	if m != nil {
		return m.NumSplitsToConsider
	}
	return nil
}

func (m *TensorForestParams) GetSplitAfterSamples() *DepthDependentParam {
	if m != nil {
		return m.SplitAfterSamples
	}
	return nil
}

func (m *TensorForestParams) GetDominateFraction() *DepthDependentParam {
	if m != nil {
		return m.DominateFraction
	}
	return nil
}

func (m *TensorForestParams) GetMinSplitSamples() *DepthDependentParam {
	if m != nil {
		return m.MinSplitSamples
	}
	return nil
}

func (m *TensorForestParams) GetGraphDir() string {
	if m != nil {
		return m.GraphDir
	}
	return ""
}

func (m *TensorForestParams) GetNumSelectFeatures() int32 {
	if m != nil {
		return m.NumSelectFeatures
	}
	return 0
}

func init() {
	proto.RegisterType((*SplitPruningConfig)(nil), "tensorflow.tensorforest.SplitPruningConfig")
	proto.RegisterType((*SplitFinishConfig)(nil), "tensorflow.tensorforest.SplitFinishConfig")
	proto.RegisterType((*LinearParam)(nil), "tensorflow.tensorforest.LinearParam")
	proto.RegisterType((*ExponentialParam)(nil), "tensorflow.tensorforest.ExponentialParam")
	proto.RegisterType((*ThresholdParam)(nil), "tensorflow.tensorforest.ThresholdParam")
	proto.RegisterType((*DepthDependentParam)(nil), "tensorflow.tensorforest.DepthDependentParam")
	proto.RegisterType((*TensorForestParams)(nil), "tensorflow.tensorforest.TensorForestParams")
	proto.RegisterEnum("tensorflow.tensorforest.LeafModelType", LeafModelType_name, LeafModelType_value)
	proto.RegisterEnum("tensorflow.tensorforest.StatsModelType", StatsModelType_name, StatsModelType_value)
	proto.RegisterEnum("tensorflow.tensorforest.SplitCollectionType", SplitCollectionType_name, SplitCollectionType_value)
	proto.RegisterEnum("tensorflow.tensorforest.SplitPruningStrategyType", SplitPruningStrategyType_name, SplitPruningStrategyType_value)
	proto.RegisterEnum("tensorflow.tensorforest.SplitFinishStrategyType", SplitFinishStrategyType_name, SplitFinishStrategyType_value)
}
func (x LeafModelType) String() string {
	s, ok := LeafModelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StatsModelType) String() string {
	s, ok := StatsModelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SplitCollectionType) String() string {
	s, ok := SplitCollectionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SplitPruningStrategyType) String() string {
	s, ok := SplitPruningStrategyType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SplitFinishStrategyType) String() string {
	s, ok := SplitFinishStrategyType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *SplitPruningConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SplitPruningConfig)
	if !ok {
		that2, ok := that.(SplitPruningConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.PruneEverySamples.Equal(that1.PruneEverySamples) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *SplitFinishConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SplitFinishConfig)
	if !ok {
		that2, ok := that.(SplitFinishConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CheckEverySteps.Equal(that1.CheckEverySteps) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *LinearParam) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinearParam)
	if !ok {
		that2, ok := that.(LinearParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Slope != that1.Slope {
		return false
	}
	if this.YIntercept != that1.YIntercept {
		return false
	}
	if this.MinVal != that1.MinVal {
		return false
	}
	if this.MaxVal != that1.MaxVal {
		return false
	}
	return true
}
func (this *ExponentialParam) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ExponentialParam)
	if !ok {
		that2, ok := that.(ExponentialParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Bias != that1.Bias {
		return false
	}
	if this.Base != that1.Base {
		return false
	}
	if this.Multiplier != that1.Multiplier {
		return false
	}
	if this.DepthMultiplier != that1.DepthMultiplier {
		return false
	}
	return true
}
func (this *ThresholdParam) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ThresholdParam)
	if !ok {
		that2, ok := that.(ThresholdParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.OnValue != that1.OnValue {
		return false
	}
	if this.OffValue != that1.OffValue {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	return true
}
func (this *DepthDependentParam) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DepthDependentParam)
	if !ok {
		that2, ok := that.(DepthDependentParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.ParamType == nil {
		if this.ParamType != nil {
			return false
		}
	} else if this.ParamType == nil {
		return false
	} else if !this.ParamType.Equal(that1.ParamType) {
		return false
	}
	return true
}
func (this *DepthDependentParam_ConstantValue) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DepthDependentParam_ConstantValue)
	if !ok {
		that2, ok := that.(DepthDependentParam_ConstantValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ConstantValue != that1.ConstantValue {
		return false
	}
	return true
}
func (this *DepthDependentParam_Linear) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DepthDependentParam_Linear)
	if !ok {
		that2, ok := that.(DepthDependentParam_Linear)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Linear.Equal(that1.Linear) {
		return false
	}
	return true
}
func (this *DepthDependentParam_Exponential) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DepthDependentParam_Exponential)
	if !ok {
		that2, ok := that.(DepthDependentParam_Exponential)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Exponential.Equal(that1.Exponential) {
		return false
	}
	return true
}
func (this *DepthDependentParam_Threshold) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DepthDependentParam_Threshold)
	if !ok {
		that2, ok := that.(DepthDependentParam_Threshold)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Threshold.Equal(that1.Threshold) {
		return false
	}
	return true
}
func (this *TensorForestParams) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TensorForestParams)
	if !ok {
		that2, ok := that.(TensorForestParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LeafType != that1.LeafType {
		return false
	}
	if this.StatsType != that1.StatsType {
		return false
	}
	if this.CollectionType != that1.CollectionType {
		return false
	}
	if !this.PruningType.Equal(that1.PruningType) {
		return false
	}
	if !this.FinishType.Equal(that1.FinishType) {
		return false
	}
	if this.NumTrees != that1.NumTrees {
		return false
	}
	if this.MaxNodes != that1.MaxNodes {
		return false
	}
	if this.NumFeatures != that1.NumFeatures {
		return false
	}
	if this.InequalityTestType != that1.InequalityTestType {
		return false
	}
	if this.IsRegression != that1.IsRegression {
		return false
	}
	if this.DropFinalClass != that1.DropFinalClass {
		return false
	}
	if this.CollateExamples != that1.CollateExamples {
		return false
	}
	if this.CheckpointStats != that1.CheckpointStats {
		return false
	}
	if this.UseRunningStatsMethod != that1.UseRunningStatsMethod {
		return false
	}
	if this.InitializeAverageSplits != that1.InitializeAverageSplits {
		return false
	}
	if this.InferenceTreePaths != that1.InferenceTreePaths {
		return false
	}
	if this.NumOutputs != that1.NumOutputs {
		return false
	}
	if !this.NumSplitsToConsider.Equal(that1.NumSplitsToConsider) {
		return false
	}
	if !this.SplitAfterSamples.Equal(that1.SplitAfterSamples) {
		return false
	}
	if !this.DominateFraction.Equal(that1.DominateFraction) {
		return false
	}
	if !this.MinSplitSamples.Equal(that1.MinSplitSamples) {
		return false
	}
	if this.GraphDir != that1.GraphDir {
		return false
	}
	if this.NumSelectFeatures != that1.NumSelectFeatures {
		return false
	}
	return true
}
func (this *SplitPruningConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_tensorforest.SplitPruningConfig{")
	if this.PruneEverySamples != nil {
		s = append(s, "PruneEverySamples: "+fmt.Sprintf("%#v", this.PruneEverySamples)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SplitFinishConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_tensorforest.SplitFinishConfig{")
	if this.CheckEverySteps != nil {
		s = append(s, "CheckEverySteps: "+fmt.Sprintf("%#v", this.CheckEverySteps)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LinearParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_tensorforest.LinearParam{")
	s = append(s, "Slope: "+fmt.Sprintf("%#v", this.Slope)+",\n")
	s = append(s, "YIntercept: "+fmt.Sprintf("%#v", this.YIntercept)+",\n")
	s = append(s, "MinVal: "+fmt.Sprintf("%#v", this.MinVal)+",\n")
	s = append(s, "MaxVal: "+fmt.Sprintf("%#v", this.MaxVal)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExponentialParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_tensorforest.ExponentialParam{")
	s = append(s, "Bias: "+fmt.Sprintf("%#v", this.Bias)+",\n")
	s = append(s, "Base: "+fmt.Sprintf("%#v", this.Base)+",\n")
	s = append(s, "Multiplier: "+fmt.Sprintf("%#v", this.Multiplier)+",\n")
	s = append(s, "DepthMultiplier: "+fmt.Sprintf("%#v", this.DepthMultiplier)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ThresholdParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_tensorforest.ThresholdParam{")
	s = append(s, "OnValue: "+fmt.Sprintf("%#v", this.OnValue)+",\n")
	s = append(s, "OffValue: "+fmt.Sprintf("%#v", this.OffValue)+",\n")
	s = append(s, "Threshold: "+fmt.Sprintf("%#v", this.Threshold)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DepthDependentParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_tensorforest.DepthDependentParam{")
	if this.ParamType != nil {
		s = append(s, "ParamType: "+fmt.Sprintf("%#v", this.ParamType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DepthDependentParam_ConstantValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_tensorforest.DepthDependentParam_ConstantValue{` +
		`ConstantValue:` + fmt.Sprintf("%#v", this.ConstantValue) + `}`}, ", ")
	return s
}
func (this *DepthDependentParam_Linear) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_tensorforest.DepthDependentParam_Linear{` +
		`Linear:` + fmt.Sprintf("%#v", this.Linear) + `}`}, ", ")
	return s
}
func (this *DepthDependentParam_Exponential) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_tensorforest.DepthDependentParam_Exponential{` +
		`Exponential:` + fmt.Sprintf("%#v", this.Exponential) + `}`}, ", ")
	return s
}
func (this *DepthDependentParam_Threshold) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_tensorforest.DepthDependentParam_Threshold{` +
		`Threshold:` + fmt.Sprintf("%#v", this.Threshold) + `}`}, ", ")
	return s
}
func (this *TensorForestParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&tensorflow_tensorforest.TensorForestParams{")
	s = append(s, "LeafType: "+fmt.Sprintf("%#v", this.LeafType)+",\n")
	s = append(s, "StatsType: "+fmt.Sprintf("%#v", this.StatsType)+",\n")
	s = append(s, "CollectionType: "+fmt.Sprintf("%#v", this.CollectionType)+",\n")
	if this.PruningType != nil {
		s = append(s, "PruningType: "+fmt.Sprintf("%#v", this.PruningType)+",\n")
	}
	if this.FinishType != nil {
		s = append(s, "FinishType: "+fmt.Sprintf("%#v", this.FinishType)+",\n")
	}
	s = append(s, "NumTrees: "+fmt.Sprintf("%#v", this.NumTrees)+",\n")
	s = append(s, "MaxNodes: "+fmt.Sprintf("%#v", this.MaxNodes)+",\n")
	s = append(s, "NumFeatures: "+fmt.Sprintf("%#v", this.NumFeatures)+",\n")
	s = append(s, "InequalityTestType: "+fmt.Sprintf("%#v", this.InequalityTestType)+",\n")
	s = append(s, "IsRegression: "+fmt.Sprintf("%#v", this.IsRegression)+",\n")
	s = append(s, "DropFinalClass: "+fmt.Sprintf("%#v", this.DropFinalClass)+",\n")
	s = append(s, "CollateExamples: "+fmt.Sprintf("%#v", this.CollateExamples)+",\n")
	s = append(s, "CheckpointStats: "+fmt.Sprintf("%#v", this.CheckpointStats)+",\n")
	s = append(s, "UseRunningStatsMethod: "+fmt.Sprintf("%#v", this.UseRunningStatsMethod)+",\n")
	s = append(s, "InitializeAverageSplits: "+fmt.Sprintf("%#v", this.InitializeAverageSplits)+",\n")
	s = append(s, "InferenceTreePaths: "+fmt.Sprintf("%#v", this.InferenceTreePaths)+",\n")
	s = append(s, "NumOutputs: "+fmt.Sprintf("%#v", this.NumOutputs)+",\n")
	if this.NumSplitsToConsider != nil {
		s = append(s, "NumSplitsToConsider: "+fmt.Sprintf("%#v", this.NumSplitsToConsider)+",\n")
	}
	if this.SplitAfterSamples != nil {
		s = append(s, "SplitAfterSamples: "+fmt.Sprintf("%#v", this.SplitAfterSamples)+",\n")
	}
	if this.DominateFraction != nil {
		s = append(s, "DominateFraction: "+fmt.Sprintf("%#v", this.DominateFraction)+",\n")
	}
	if this.MinSplitSamples != nil {
		s = append(s, "MinSplitSamples: "+fmt.Sprintf("%#v", this.MinSplitSamples)+",\n")
	}
	s = append(s, "GraphDir: "+fmt.Sprintf("%#v", this.GraphDir)+",\n")
	s = append(s, "NumSelectFeatures: "+fmt.Sprintf("%#v", this.NumSelectFeatures)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTensorForestParams(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SplitPruningConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitPruningConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PruneEverySamples != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.PruneEverySamples.Size()))
		n1, err := m.PruneEverySamples.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *SplitFinishConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitFinishConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CheckEverySteps != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.CheckEverySteps.Size()))
		n2, err := m.CheckEverySteps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *LinearParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinearParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Slope != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.Slope))))
	}
	if m.YIntercept != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.YIntercept))))
	}
	if m.MinVal != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.MinVal))))
	}
	if m.MaxVal != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.MaxVal))))
	}
	return i, nil
}

func (m *ExponentialParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExponentialParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bias != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.Bias))))
	}
	if m.Base != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.Base))))
	}
	if m.Multiplier != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.Multiplier))))
	}
	if m.DepthMultiplier != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.DepthMultiplier))))
	}
	return i, nil
}

func (m *ThresholdParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OnValue != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.OnValue))))
	}
	if m.OffValue != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.OffValue))))
	}
	if m.Threshold != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.Threshold))))
	}
	return i, nil
}

func (m *DepthDependentParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepthDependentParam) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ParamType != nil {
		nn3, err := m.ParamType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *DepthDependentParam_ConstantValue) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xd
	i++
	i = encodeFixed32TensorForestParams(dAtA, i, uint32(math.Float32bits(float32(m.ConstantValue))))
	return i, nil
}
func (m *DepthDependentParam_Linear) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Linear != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.Linear.Size()))
		n4, err := m.Linear.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *DepthDependentParam_Exponential) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Exponential != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.Exponential.Size()))
		n5, err := m.Exponential.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *DepthDependentParam_Threshold) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Threshold != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.Threshold.Size()))
		n6, err := m.Threshold.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *TensorForestParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TensorForestParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeafType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.LeafType))
	}
	if m.StatsType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.StatsType))
	}
	if m.CollectionType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.CollectionType))
	}
	if m.PruningType != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.PruningType.Size()))
		n7, err := m.PruningType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.FinishType != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.FinishType.Size()))
		n8, err := m.FinishType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.NumTrees != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.NumTrees))
	}
	if m.MaxNodes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.MaxNodes))
	}
	if m.IsRegression {
		dAtA[i] = 0x40
		i++
		if m.IsRegression {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropFinalClass {
		dAtA[i] = 0x48
		i++
		if m.DropFinalClass {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CollateExamples {
		dAtA[i] = 0x50
		i++
		if m.CollateExamples {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CheckpointStats {
		dAtA[i] = 0x58
		i++
		if m.CheckpointStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NumOutputs != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.NumOutputs))
	}
	if m.NumSplitsToConsider != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.NumSplitsToConsider.Size()))
		n9, err := m.NumSplitsToConsider.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.SplitAfterSamples != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.SplitAfterSamples.Size()))
		n10, err := m.SplitAfterSamples.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DominateFraction != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.DominateFraction.Size()))
		n11, err := m.DominateFraction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.GraphDir) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(len(m.GraphDir)))
		i += copy(dAtA[i:], m.GraphDir)
	}
	if m.NumSelectFeatures != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.NumSelectFeatures))
	}
	if m.MinSplitSamples != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.MinSplitSamples.Size()))
		n12, err := m.MinSplitSamples.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.InequalityTestType != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.InequalityTestType))
	}
	if m.UseRunningStatsMethod {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.UseRunningStatsMethod {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NumFeatures != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTensorForestParams(dAtA, i, uint64(m.NumFeatures))
	}
	if m.InitializeAverageSplits {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.InitializeAverageSplits {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InferenceTreePaths {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.InferenceTreePaths {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64TensorForestParams(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32TensorForestParams(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTensorForestParams(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SplitPruningConfig) Size() (n int) {
	var l int
	_ = l
	if m.PruneEverySamples != nil {
		l = m.PruneEverySamples.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTensorForestParams(uint64(m.Type))
	}
	return n
}

func (m *SplitFinishConfig) Size() (n int) {
	var l int
	_ = l
	if m.CheckEverySteps != nil {
		l = m.CheckEverySteps.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTensorForestParams(uint64(m.Type))
	}
	return n
}

func (m *LinearParam) Size() (n int) {
	var l int
	_ = l
	if m.Slope != 0 {
		n += 5
	}
	if m.YIntercept != 0 {
		n += 5
	}
	if m.MinVal != 0 {
		n += 5
	}
	if m.MaxVal != 0 {
		n += 5
	}
	return n
}

func (m *ExponentialParam) Size() (n int) {
	var l int
	_ = l
	if m.Bias != 0 {
		n += 5
	}
	if m.Base != 0 {
		n += 5
	}
	if m.Multiplier != 0 {
		n += 5
	}
	if m.DepthMultiplier != 0 {
		n += 5
	}
	return n
}

func (m *ThresholdParam) Size() (n int) {
	var l int
	_ = l
	if m.OnValue != 0 {
		n += 5
	}
	if m.OffValue != 0 {
		n += 5
	}
	if m.Threshold != 0 {
		n += 5
	}
	return n
}

func (m *DepthDependentParam) Size() (n int) {
	var l int
	_ = l
	if m.ParamType != nil {
		n += m.ParamType.Size()
	}
	return n
}

func (m *DepthDependentParam_ConstantValue) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *DepthDependentParam_Linear) Size() (n int) {
	var l int
	_ = l
	if m.Linear != nil {
		l = m.Linear.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	return n
}
func (m *DepthDependentParam_Exponential) Size() (n int) {
	var l int
	_ = l
	if m.Exponential != nil {
		l = m.Exponential.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	return n
}
func (m *DepthDependentParam_Threshold) Size() (n int) {
	var l int
	_ = l
	if m.Threshold != nil {
		l = m.Threshold.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	return n
}
func (m *TensorForestParams) Size() (n int) {
	var l int
	_ = l
	if m.LeafType != 0 {
		n += 1 + sovTensorForestParams(uint64(m.LeafType))
	}
	if m.StatsType != 0 {
		n += 1 + sovTensorForestParams(uint64(m.StatsType))
	}
	if m.CollectionType != 0 {
		n += 1 + sovTensorForestParams(uint64(m.CollectionType))
	}
	if m.PruningType != nil {
		l = m.PruningType.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	if m.FinishType != nil {
		l = m.FinishType.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	if m.NumTrees != 0 {
		n += 1 + sovTensorForestParams(uint64(m.NumTrees))
	}
	if m.MaxNodes != 0 {
		n += 1 + sovTensorForestParams(uint64(m.MaxNodes))
	}
	if m.IsRegression {
		n += 2
	}
	if m.DropFinalClass {
		n += 2
	}
	if m.CollateExamples {
		n += 2
	}
	if m.CheckpointStats {
		n += 2
	}
	if m.NumOutputs != 0 {
		n += 1 + sovTensorForestParams(uint64(m.NumOutputs))
	}
	if m.NumSplitsToConsider != nil {
		l = m.NumSplitsToConsider.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	if m.SplitAfterSamples != nil {
		l = m.SplitAfterSamples.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	if m.DominateFraction != nil {
		l = m.DominateFraction.Size()
		n += 1 + l + sovTensorForestParams(uint64(l))
	}
	l = len(m.GraphDir)
	if l > 0 {
		n += 2 + l + sovTensorForestParams(uint64(l))
	}
	if m.NumSelectFeatures != 0 {
		n += 2 + sovTensorForestParams(uint64(m.NumSelectFeatures))
	}
	if m.MinSplitSamples != nil {
		l = m.MinSplitSamples.Size()
		n += 2 + l + sovTensorForestParams(uint64(l))
	}
	if m.InequalityTestType != 0 {
		n += 2 + sovTensorForestParams(uint64(m.InequalityTestType))
	}
	if m.UseRunningStatsMethod {
		n += 3
	}
	if m.NumFeatures != 0 {
		n += 2 + sovTensorForestParams(uint64(m.NumFeatures))
	}
	if m.InitializeAverageSplits {
		n += 3
	}
	if m.InferenceTreePaths {
		n += 3
	}
	return n
}

func sovTensorForestParams(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTensorForestParams(x uint64) (n int) {
	return sovTensorForestParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SplitPruningConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SplitPruningConfig{`,
		`PruneEverySamples:` + strings.Replace(fmt.Sprintf("%v", this.PruneEverySamples), "DepthDependentParam", "DepthDependentParam", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SplitFinishConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SplitFinishConfig{`,
		`CheckEverySteps:` + strings.Replace(fmt.Sprintf("%v", this.CheckEverySteps), "DepthDependentParam", "DepthDependentParam", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinearParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinearParam{`,
		`Slope:` + fmt.Sprintf("%v", this.Slope) + `,`,
		`YIntercept:` + fmt.Sprintf("%v", this.YIntercept) + `,`,
		`MinVal:` + fmt.Sprintf("%v", this.MinVal) + `,`,
		`MaxVal:` + fmt.Sprintf("%v", this.MaxVal) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExponentialParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExponentialParam{`,
		`Bias:` + fmt.Sprintf("%v", this.Bias) + `,`,
		`Base:` + fmt.Sprintf("%v", this.Base) + `,`,
		`Multiplier:` + fmt.Sprintf("%v", this.Multiplier) + `,`,
		`DepthMultiplier:` + fmt.Sprintf("%v", this.DepthMultiplier) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ThresholdParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ThresholdParam{`,
		`OnValue:` + fmt.Sprintf("%v", this.OnValue) + `,`,
		`OffValue:` + fmt.Sprintf("%v", this.OffValue) + `,`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DepthDependentParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DepthDependentParam{`,
		`ParamType:` + fmt.Sprintf("%v", this.ParamType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DepthDependentParam_ConstantValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DepthDependentParam_ConstantValue{`,
		`ConstantValue:` + fmt.Sprintf("%v", this.ConstantValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DepthDependentParam_Linear) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DepthDependentParam_Linear{`,
		`Linear:` + strings.Replace(fmt.Sprintf("%v", this.Linear), "LinearParam", "LinearParam", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DepthDependentParam_Exponential) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DepthDependentParam_Exponential{`,
		`Exponential:` + strings.Replace(fmt.Sprintf("%v", this.Exponential), "ExponentialParam", "ExponentialParam", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DepthDependentParam_Threshold) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DepthDependentParam_Threshold{`,
		`Threshold:` + strings.Replace(fmt.Sprintf("%v", this.Threshold), "ThresholdParam", "ThresholdParam", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TensorForestParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TensorForestParams{`,
		`LeafType:` + fmt.Sprintf("%v", this.LeafType) + `,`,
		`StatsType:` + fmt.Sprintf("%v", this.StatsType) + `,`,
		`CollectionType:` + fmt.Sprintf("%v", this.CollectionType) + `,`,
		`PruningType:` + strings.Replace(fmt.Sprintf("%v", this.PruningType), "SplitPruningConfig", "SplitPruningConfig", 1) + `,`,
		`FinishType:` + strings.Replace(fmt.Sprintf("%v", this.FinishType), "SplitFinishConfig", "SplitFinishConfig", 1) + `,`,
		`NumTrees:` + fmt.Sprintf("%v", this.NumTrees) + `,`,
		`MaxNodes:` + fmt.Sprintf("%v", this.MaxNodes) + `,`,
		`IsRegression:` + fmt.Sprintf("%v", this.IsRegression) + `,`,
		`DropFinalClass:` + fmt.Sprintf("%v", this.DropFinalClass) + `,`,
		`CollateExamples:` + fmt.Sprintf("%v", this.CollateExamples) + `,`,
		`CheckpointStats:` + fmt.Sprintf("%v", this.CheckpointStats) + `,`,
		`NumOutputs:` + fmt.Sprintf("%v", this.NumOutputs) + `,`,
		`NumSplitsToConsider:` + strings.Replace(fmt.Sprintf("%v", this.NumSplitsToConsider), "DepthDependentParam", "DepthDependentParam", 1) + `,`,
		`SplitAfterSamples:` + strings.Replace(fmt.Sprintf("%v", this.SplitAfterSamples), "DepthDependentParam", "DepthDependentParam", 1) + `,`,
		`DominateFraction:` + strings.Replace(fmt.Sprintf("%v", this.DominateFraction), "DepthDependentParam", "DepthDependentParam", 1) + `,`,
		`GraphDir:` + fmt.Sprintf("%v", this.GraphDir) + `,`,
		`NumSelectFeatures:` + fmt.Sprintf("%v", this.NumSelectFeatures) + `,`,
		`MinSplitSamples:` + strings.Replace(fmt.Sprintf("%v", this.MinSplitSamples), "DepthDependentParam", "DepthDependentParam", 1) + `,`,
		`InequalityTestType:` + fmt.Sprintf("%v", this.InequalityTestType) + `,`,
		`UseRunningStatsMethod:` + fmt.Sprintf("%v", this.UseRunningStatsMethod) + `,`,
		`NumFeatures:` + fmt.Sprintf("%v", this.NumFeatures) + `,`,
		`InitializeAverageSplits:` + fmt.Sprintf("%v", this.InitializeAverageSplits) + `,`,
		`InferenceTreePaths:` + fmt.Sprintf("%v", this.InferenceTreePaths) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTensorForestParams(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SplitPruningConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorForestParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitPruningConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitPruningConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PruneEverySamples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PruneEverySamples == nil {
				m.PruneEverySamples = &DepthDependentParam{}
			}
			if err := m.PruneEverySamples.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SplitPruningStrategyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTensorForestParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitFinishConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorForestParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitFinishConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitFinishConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckEverySteps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckEverySteps == nil {
				m.CheckEverySteps = &DepthDependentParam{}
			}
			if err := m.CheckEverySteps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SplitFinishStrategyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTensorForestParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinearParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorForestParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinearParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinearParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slope", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Slope = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field YIntercept", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.YIntercept = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVal", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.MinVal = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVal", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.MaxVal = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTensorForestParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExponentialParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorForestParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExponentialParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExponentialParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bias", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Bias = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Base = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Multiplier = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepthMultiplier", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DepthMultiplier = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTensorForestParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorForestParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.OnValue = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.OffValue = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Threshold = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTensorForestParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepthDependentParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorForestParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepthDependentParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepthDependentParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstantValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.ParamType = &DepthDependentParam_ConstantValue{float32(math.Float32frombits(v))}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linear", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LinearParam{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ParamType = &DepthDependentParam_Linear{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponential", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExponentialParam{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ParamType = &DepthDependentParam_Exponential{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ThresholdParam{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ParamType = &DepthDependentParam_Threshold{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTensorForestParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TensorForestParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTensorForestParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TensorForestParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TensorForestParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafType", wireType)
			}
			m.LeafType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafType |= (LeafModelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsType", wireType)
			}
			m.StatsType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatsType |= (StatsModelType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionType", wireType)
			}
			m.CollectionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectionType |= (SplitCollectionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PruningType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PruningType == nil {
				m.PruningType = &SplitPruningConfig{}
			}
			if err := m.PruningType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinishType == nil {
				m.FinishType = &SplitFinishConfig{}
			}
			if err := m.FinishType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTrees", wireType)
			}
			m.NumTrees = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTrees |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNodes", wireType)
			}
			m.MaxNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNodes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRegression", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRegression = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropFinalClass", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropFinalClass = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateExamples", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollateExamples = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckpointStats = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOutputs", wireType)
			}
			m.NumOutputs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOutputs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSplitsToConsider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NumSplitsToConsider == nil {
				m.NumSplitsToConsider = &DepthDependentParam{}
			}
			if err := m.NumSplitsToConsider.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitAfterSamples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitAfterSamples == nil {
				m.SplitAfterSamples = &DepthDependentParam{}
			}
			if err := m.SplitAfterSamples.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DominateFraction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DominateFraction == nil {
				m.DominateFraction = &DepthDependentParam{}
			}
			if err := m.DominateFraction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraphDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GraphDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSelectFeatures", wireType)
			}
			m.NumSelectFeatures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSelectFeatures |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSplitSamples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinSplitSamples == nil {
				m.MinSplitSamples = &DepthDependentParam{}
			}
			if err := m.MinSplitSamples.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InequalityTestType", wireType)
			}
			m.InequalityTestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InequalityTestType |= (tensorflow_decision_trees.InequalityTest_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRunningStatsMethod", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseRunningStatsMethod = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumFeatures", wireType)
			}
			m.NumFeatures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumFeatures |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeAverageSplits", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitializeAverageSplits = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferenceTreePaths", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InferenceTreePaths = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTensorForestParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTensorForestParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTensorForestParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTensorForestParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTensorForestParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTensorForestParams
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTensorForestParams
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTensorForestParams(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTensorForestParams = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTensorForestParams   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/contrib/tensor_forest/proto/tensor_forest_params.proto", fileDescriptorTensorForestParams)
}

var fileDescriptorTensorForestParams = []byte{
	// 1461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x4d, 0x73, 0x1b, 0x4d,
	0x11, 0xd6, 0xda, 0x8e, 0x63, 0xb5, 0xfc, 0xb1, 0x1e, 0x7f, 0x6d, 0xe2, 0xb7, 0x14, 0xe3, 0x37,
	0x45, 0x1c, 0x93, 0x72, 0x12, 0x73, 0xa0, 0x8a, 0x03, 0x85, 0x2c, 0xad, 0x2c, 0x81, 0x2c, 0x89,
	0xdd, 0x75, 0x0a, 0xaa, 0xa8, 0x1a, 0xd6, 0xd2, 0xac, 0x35, 0xc5, 0x6a, 0x76, 0xd9, 0x9d, 0x35,
	0x36, 0x5c, 0xa8, 0x02, 0xee, 0x39, 0xf1, 0x07, 0xb8, 0x70, 0xe7, 0xc4, 0x3f, 0xe0, 0x98, 0x23,
	0x47, 0x62, 0x2e, 0x1c, 0xf3, 0x13, 0xa8, 0xe9, 0x59, 0xc9, 0x52, 0xb0, 0x52, 0x29, 0xdf, 0xb4,
	0x4f, 0x77, 0x3f, 0xd3, 0xfd, 0xcc, 0x74, 0xcf, 0x08, 0x7e, 0x12, 0x27, 0x91, 0x8c, 0x2e, 0xb2,
	0xe0, 0xb5, 0x64, 0x22, 0x8d, 0x92, 0x20, 0x8c, 0x7e, 0xfb, 0xba, 0x17, 0x09, 0x99, 0xf0, 0x8b,
	0x1c, 0xa2, 0x41, 0x94, 0xb0, 0x54, 0xbe, 0x46, 0xcf, 0x69, 0x8c, 0xc6, 0x7e, 0xe2, 0x0f, 0xd3,
	0x23, 0x34, 0x91, 0x9d, 0x3b, 0x8a, 0xa3, 0xfc, 0x27, 0x7a, 0x3d, 0xfd, 0xf1, 0x3d, 0xdc, 0x7d,
	0xd6, 0xe3, 0x29, 0x8f, 0x04, 0x95, 0x09, 0x63, 0x69, 0x4e, 0x7e, 0xc9, 0x04, 0x4b, 0x78, 0x0f,
	0x31, 0x3a, 0x8c, 0xfa, 0x2c, 0xd4, 0xd4, 0xfb, 0xff, 0x30, 0x80, 0xb8, 0x71, 0xc8, 0x65, 0x37,
	0xc9, 0x04, 0x17, 0x97, 0xd5, 0x48, 0x04, 0xfc, 0x92, 0xfc, 0x12, 0x36, 0xe2, 0x24, 0x13, 0x8c,
	0xb2, 0x2b, 0x96, 0xdc, 0xd0, 0xd4, 0x1f, 0xc6, 0x21, 0x4b, 0x2d, 0x63, 0xcf, 0x38, 0x28, 0x1d,
	0xbf, 0x3a, 0x9a, 0x91, 0xcf, 0x51, 0x8d, 0xc5, 0x72, 0x50, 0x63, 0x31, 0x13, 0x7d, 0x26, 0x64,
	0x57, 0xd5, 0xe0, 0xac, 0x23, 0x91, 0xad, 0x78, 0x5c, 0x4d, 0x43, 0x6c, 0x58, 0x90, 0x37, 0x31,
	0xb3, 0xe6, 0xf6, 0x8c, 0x83, 0xd5, 0xe3, 0xb7, 0x33, 0xe9, 0x26, 0x13, 0x73, 0x65, 0xe2, 0x4b,
	0x76, 0x79, 0xe3, 0xdd, 0xc4, 0xcc, 0xc1, 0xf0, 0xfd, 0xbf, 0x1b, 0xb0, 0x8e, 0x2e, 0x75, 0x2e,
	0x78, 0x3a, 0xc8, 0x53, 0xff, 0x39, 0xac, 0xf7, 0x06, 0xac, 0xf7, 0xeb, 0x51, 0xea, 0x92, 0xc5,
	0x0f, 0x4b, 0x7c, 0x0d, 0x69, 0x74, 0xe2, 0x8a, 0x84, 0xd4, 0xa6, 0xd2, 0x7e, 0xf3, 0xe5, 0xb4,
	0x75, 0x4e, 0xf7, 0x64, 0x7d, 0x05, 0xa5, 0x16, 0x17, 0xcc, 0x4f, 0x70, 0x15, 0xb2, 0x09, 0x8f,
	0xd2, 0x30, 0x8a, 0x19, 0xa6, 0x38, 0xe7, 0xe8, 0x0f, 0xf2, 0x0c, 0x4a, 0x37, 0x94, 0x0b, 0xc9,
	0x92, 0x1e, 0x8b, 0x25, 0xae, 0x38, 0xe7, 0xc0, 0x4d, 0x73, 0x84, 0x90, 0x1d, 0x78, 0x3c, 0xe4,
	0x82, 0x5e, 0xf9, 0xa1, 0x35, 0x8f, 0xc6, 0xc5, 0x21, 0x17, 0xef, 0xfc, 0x10, 0x0d, 0xfe, 0x35,
	0x1a, 0x16, 0x72, 0x83, 0x7f, 0xfd, 0xce, 0x0f, 0xf7, 0xff, 0x6c, 0x80, 0x69, 0x5f, 0xc7, 0x91,
	0x60, 0x42, 0x72, 0x3f, 0xd4, 0xab, 0x13, 0x58, 0xb8, 0xe0, 0x7e, 0x9a, 0x2f, 0x8e, 0xbf, 0x11,
	0xf3, 0x53, 0x96, 0x2f, 0x8a, 0xbf, 0x49, 0x19, 0x60, 0x98, 0x85, 0x92, 0xc7, 0x21, 0x67, 0x49,
	0xbe, 0xe2, 0x04, 0x42, 0x5e, 0x82, 0xd9, 0x57, 0x12, 0xd2, 0x09, 0x2f, 0xbd, 0xfc, 0x1a, 0xe2,
	0x67, 0x63, 0x78, 0x3f, 0x80, 0x55, 0x6f, 0x90, 0xb0, 0x74, 0x10, 0x85, 0x7d, 0x9d, 0xc4, 0x13,
	0x58, 0x8a, 0xb0, 0x94, 0x6c, 0xa4, 0xc2, 0xe3, 0x48, 0xd5, 0x92, 0x31, 0xb2, 0x0b, 0xc5, 0x28,
	0x08, 0x72, 0x9b, 0x4e, 0x68, 0x29, 0x0a, 0x02, 0x6d, 0xfc, 0x06, 0x8a, 0x72, 0xc4, 0x94, 0xe7,
	0x74, 0x07, 0xec, 0xff, 0x75, 0x0e, 0x36, 0xee, 0xd9, 0x56, 0xf2, 0x02, 0x56, 0x7b, 0x91, 0x48,
	0xa5, 0x2f, 0xe4, 0xe4, 0x9a, 0x8d, 0x82, 0xb3, 0x32, 0xc2, 0x35, 0xfd, 0x8f, 0x60, 0x31, 0xc4,
	0x8d, 0xc2, 0x85, 0x4b, 0xc7, 0xcf, 0x67, 0x6e, 0xf8, 0xc4, 0x7e, 0x36, 0x0a, 0x4e, 0x1e, 0x45,
	0xce, 0xa0, 0xc4, 0xee, 0xf4, 0xc6, 0x04, 0x4b, 0xc7, 0x2f, 0x67, 0x92, 0x7c, 0xbe, 0x37, 0x8d,
	0x82, 0x33, 0x19, 0x4f, 0x4e, 0x27, 0xab, 0x5d, 0x40, 0xb2, 0x17, 0x33, 0xc9, 0xa6, 0x15, 0x6e,
	0x14, 0x26, 0x84, 0x39, 0x29, 0x41, 0x11, 0x51, 0x75, 0x26, 0xf7, 0xff, 0x54, 0x02, 0xe2, 0x61,
	0x64, 0x1d, 0x23, 0xd1, 0x92, 0x92, 0x2a, 0x14, 0x43, 0xe6, 0x07, 0x14, 0xcf, 0xbb, 0x81, 0xe7,
	0xfd, 0xbb, 0xb3, 0xcb, 0x67, 0x7e, 0x70, 0xa6, 0x66, 0x0a, 0x9e, 0xf2, 0x25, 0x15, 0xa8, 0x7e,
	0x91, 0x3a, 0x40, 0x2a, 0x7d, 0x99, 0xd2, 0x89, 0xae, 0x99, 0x9d, 0xb2, 0xab, 0x5c, 0xef, 0x68,
	0x8a, 0x18, 0x8a, 0x3c, 0xe7, 0xb0, 0xd6, 0x8b, 0xc2, 0x90, 0xf5, 0x24, 0x8e, 0x35, 0x45, 0x36,
	0x8f, 0x64, 0xaf, 0xbe, 0xdc, 0x82, 0xd5, 0x71, 0x10, 0x32, 0xae, 0xf6, 0xa6, 0xbe, 0x49, 0x1b,
	0x96, 0x63, 0x3d, 0x5b, 0x34, 0xa7, 0xd6, 0xf4, 0x7b, 0x5f, 0x35, 0x8d, 0xf4, 0xac, 0x71, 0x4a,
	0x39, 0x01, 0xf2, 0xfd, 0x14, 0x4a, 0x01, 0x36, 0xbd, 0xa6, 0x7b, 0x84, 0x74, 0x87, 0x5f, 0x33,
	0x25, 0x72, 0x36, 0xd0, 0xe1, 0x48, 0xb6, 0x0b, 0x45, 0x91, 0x0d, 0xf5, 0x0c, 0xb7, 0x16, 0xf7,
	0x8c, 0x83, 0x47, 0xce, 0x92, 0xc8, 0x86, 0x9e, 0xfa, 0x56, 0x46, 0xd5, 0xe3, 0x22, 0xea, 0xb3,
	0xd4, 0x7a, 0xac, 0x8d, 0x43, 0xff, 0xba, 0xad, 0xbe, 0xc9, 0xb7, 0xb0, 0xc2, 0x53, 0x9a, 0xb0,
	0xcb, 0x84, 0xa5, 0xea, 0x1e, 0xb0, 0x96, 0xf6, 0x8c, 0x83, 0x25, 0x67, 0x99, 0xa7, 0xce, 0x18,
	0x23, 0x07, 0x60, 0xf6, 0x93, 0x28, 0xa6, 0x01, 0x17, 0x7e, 0x48, 0x7b, 0xa1, 0x9f, 0xa6, 0x56,
	0x11, 0xfd, 0x56, 0x15, 0x5e, 0x57, 0x70, 0x55, 0xa1, 0xaa, 0xb3, 0x95, 0x6e, 0xbe, 0x64, 0x94,
	0x5d, 0xe7, 0xd7, 0x00, 0xa0, 0xe7, 0x5a, 0x8e, 0xdb, 0x39, 0x8c, 0xae, 0x6a, 0x64, 0xc6, 0x11,
	0x17, 0x92, 0xe2, 0xfe, 0x59, 0xa5, 0xdc, 0x75, 0x8c, 0xe3, 0x36, 0xab, 0xf9, 0xa6, 0xca, 0x8b,
	0x32, 0x19, 0x67, 0x32, 0xb5, 0x96, 0xb1, 0x06, 0x10, 0xd9, 0xb0, 0xa3, 0x11, 0xe2, 0xc3, 0xb6,
	0x72, 0x48, 0x95, 0x48, 0x29, 0x95, 0x11, 0x55, 0xbd, 0xc9, 0xfb, 0x2c, 0xb1, 0x56, 0x1e, 0x30,
	0xca, 0x37, 0x44, 0x36, 0x44, 0xbd, 0x53, 0x2f, 0xaa, 0xe6, 0x44, 0xea, 0x8e, 0x43, 0x7a, 0xea,
	0x07, 0x92, 0x25, 0xe3, 0x3b, 0x6e, 0xf5, 0x21, 0x77, 0x1c, 0x12, 0x55, 0x14, 0xcf, 0xe8, 0x8e,
	0xfb, 0x05, 0xac, 0xf7, 0xa3, 0x21, 0x17, 0x4a, 0xb8, 0x20, 0xf1, 0xf1, 0xd8, 0x59, 0x6b, 0x0f,
	0xe0, 0x36, 0x47, 0x34, 0xf5, 0x9c, 0x45, 0x6d, 0xff, 0x65, 0xe2, 0xc7, 0x03, 0xda, 0xe7, 0x89,
	0x65, 0xee, 0x19, 0x07, 0x45, 0x67, 0x09, 0x81, 0x1a, 0x4f, 0xc8, 0x11, 0x6c, 0xa0, 0x70, 0x4c,
	0x1d, 0x75, 0x1a, 0x30, 0x5f, 0x66, 0x09, 0x4b, 0xad, 0x75, 0x54, 0x78, 0x5d, 0xe9, 0x80, 0x96,
	0x7a, 0x6e, 0x50, 0xd7, 0xa5, 0xba, 0x48, 0xb4, 0x12, 0x23, 0x0d, 0xc8, 0x43, 0xae, 0xcb, 0x21,
	0x17, 0xa8, 0xf1, 0x48, 0x81, 0x5f, 0xc1, 0x26, 0x17, 0xec, 0x37, 0x99, 0x1f, 0x72, 0x79, 0x43,
	0xa5, 0x7a, 0xd5, 0x60, 0x63, 0x6c, 0x60, 0xef, 0x1e, 0x4d, 0x92, 0x4f, 0xbf, 0x59, 0x8e, 0x9a,
	0xe3, 0x30, 0x0f, 0x87, 0x99, 0xea, 0x5e, 0xc2, 0xa7, 0x40, 0x6c, 0x92, 0x1f, 0x80, 0x95, 0xa5,
	0x8c, 0x26, 0x99, 0xc0, 0x2e, 0xd6, 0xc3, 0x66, 0xc8, 0xe4, 0x20, 0xea, 0x5b, 0x9b, 0x78, 0xf0,
	0xb6, 0xb2, 0x94, 0x39, 0xda, 0xac, 0xe7, 0x0b, 0x1a, 0xc9, 0x77, 0x60, 0x59, 0x89, 0x34, 0x56,
	0x67, 0x0b, 0xd5, 0x51, 0x47, 0x72, 0xac, 0xcb, 0x0f, 0xe1, 0x09, 0x17, 0x5c, 0x4d, 0x5e, 0xfe,
	0x3b, 0x46, 0xfd, 0x2b, 0x96, 0xf8, 0x97, 0x2c, 0x3f, 0x8f, 0xd6, 0x36, 0x92, 0xef, 0xdc, 0x39,
	0x54, 0xb4, 0x5d, 0x9f, 0x31, 0xf2, 0x46, 0x55, 0x1e, 0xb0, 0x84, 0x89, 0x1e, 0xd3, 0x4f, 0xae,
	0xd8, 0x97, 0x83, 0xd4, 0xda, 0xc1, 0x30, 0x32, 0xb6, 0xa9, 0x6e, 0xee, 0x2a, 0xcb, 0xe1, 0x7b,
	0x03, 0x56, 0xa6, 0xc6, 0x28, 0x29, 0xc3, 0xd3, 0xb3, 0x4e, 0xcd, 0x6e, 0xd1, 0x9a, 0xdd, 0x76,
	0x6d, 0x5a, 0x6d, 0x55, 0x5c, 0xb7, 0x59, 0x6f, 0x56, 0x2b, 0x5e, 0xb3, 0xd3, 0x36, 0x0b, 0xe4,
	0x19, 0xec, 0x6a, 0xbb, 0xdb, 0xad, 0x38, 0xff, 0xef, 0x60, 0x90, 0x4d, 0x30, 0xb5, 0x83, 0x63,
	0x9f, 0x3a, 0xb6, 0xeb, 0x2a, 0x74, 0x8e, 0x1c, 0xc0, 0xf3, 0xa9, 0xb0, 0x8e, 0x73, 0xff, 0x02,
	0xf3, 0x87, 0x7f, 0x34, 0x60, 0x75, 0x7a, 0x26, 0x2b, 0x4a, 0xd7, 0xab, 0x78, 0x6e, 0x1e, 0x72,
	0xda, 0x6c, 0x37, 0xcd, 0x02, 0xd9, 0x82, 0x75, 0x8d, 0xe6, 0x94, 0x08, 0x1b, 0x64, 0x1f, 0xca,
	0x1a, 0x6e, 0xd9, 0x15, 0xd7, 0xa3, 0xee, 0xcf, 0xce, 0x2b, 0x8e, 0xed, 0x4e, 0x67, 0xb3, 0x07,
	0xdf, 0x4c, 0x85, 0x7a, 0x0d, 0xbb, 0x3d, 0x49, 0x3e, 0x7f, 0xd8, 0x80, 0x8d, 0x7b, 0x66, 0xb9,
	0xca, 0xa4, 0xda, 0x69, 0xb5, 0xec, 0xaa, 0x4a, 0x96, 0x9e, 0x54, 0xdc, 0x66, 0xd5, 0x2c, 0x90,
	0x5d, 0xd8, 0x39, 0x75, 0x2a, 0xdd, 0x06, 0x75, 0xce, 0xdb, 0x6d, 0xdb, 0xa1, 0x77, 0x2e, 0xa6,
	0x71, 0xf8, 0x17, 0x03, 0xac, 0x59, 0x0f, 0x4a, 0xac, 0xac, 0xdb, 0x6a, 0x7a, 0xb4, 0xeb, 0x9c,
	0xb7, 0x6d, 0xda, 0xee, 0xb4, 0x6d, 0xb3, 0xf0, 0x39, 0xda, 0xa8, 0xb4, 0xea, 0xa6, 0x41, 0x76,
	0x60, 0x63, 0x12, 0x55, 0x75, 0x79, 0xb6, 0x63, 0xce, 0x91, 0xa7, 0xb0, 0x3d, 0x69, 0x78, 0xfb,
	0x86, 0x76, 0x6d, 0xa7, 0x6a, 0xb7, 0x3d, 0x73, 0x9e, 0x3c, 0x81, 0xad, 0x29, 0xaa, 0x8e, 0x5d,
	0xaf, 0xd7, 0x9a, 0xed, 0x53, 0x73, 0xe1, 0xf0, 0xf7, 0xb0, 0x33, 0xe3, 0xc5, 0x48, 0xb6, 0x81,
	0xe8, 0xa8, 0x7a, 0xb3, 0xdd, 0x74, 0x1b, 0xe3, 0x42, 0xbf, 0x85, 0x67, 0x53, 0x78, 0xad, 0x73,
	0xd6, 0x6c, 0x57, 0xbc, 0x49, 0xde, 0xb9, 0xd9, 0x4e, 0x27, 0x9d, 0x8e, 0xe7, 0x7a, 0x4e, 0xa5,
	0x6b, 0xce, 0x9f, 0xbc, 0xfa, 0xf0, 0xb1, 0x5c, 0xf8, 0xd7, 0xc7, 0x72, 0xe1, 0xd3, 0xc7, 0xb2,
	0xf1, 0x87, 0xdb, 0xb2, 0xf1, 0xb7, 0xdb, 0xb2, 0xf1, 0xcf, 0xdb, 0xb2, 0xf1, 0xe1, 0xb6, 0x6c,
	0xfc, 0xfb, 0xb6, 0x6c, 0xfc, 0xf7, 0xb6, 0x5c, 0xf8, 0x74, 0x5b, 0x36, 0xde, 0xff, 0xa7, 0x5c,
	0xb8, 0x58, 0xc4, 0x3f, 0x0d, 0xdf, 0xff, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0xc8, 0xc5,
	0x43, 0xdd, 0x0c, 0x00, 0x00,
}
