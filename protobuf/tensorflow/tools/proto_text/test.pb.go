// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/tools/proto_text/test.proto

/*
	Package tensorflow_test is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/tools/proto_text/test.proto

	It has these top-level messages:
		TestAllTypes
		NestedTestAllTypes
		ForeignMessage
		TestEmptyMessage
*/
package tensorflow_test

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strconv "strconv"

import bytes "bytes"

import fmt "fmt"
import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ForeignEnum int32

const (
	FOREIGN_ZERO ForeignEnum = 0
	FOREIGN_FOO  ForeignEnum = 4
	FOREIGN_BAR  ForeignEnum = 5
	FOREIGN_BAZ  ForeignEnum = 6
)

var ForeignEnum_name = map[int32]string{
	0: "FOREIGN_ZERO",
	4: "FOREIGN_FOO",
	5: "FOREIGN_BAR",
	6: "FOREIGN_BAZ",
}
var ForeignEnum_value = map[string]int32{
	"FOREIGN_ZERO": 0,
	"FOREIGN_FOO":  4,
	"FOREIGN_BAR":  5,
	"FOREIGN_BAZ":  6,
}

func (ForeignEnum) EnumDescriptor() ([]byte, []int) { return fileDescriptorTest, []int{0} }

type TestAllTypes_NestedEnum int32

const (
	ZERO TestAllTypes_NestedEnum = 0
	FOO  TestAllTypes_NestedEnum = 1
	BAR  TestAllTypes_NestedEnum = 2
	BAZ  TestAllTypes_NestedEnum = 3
	NEG  TestAllTypes_NestedEnum = -1
)

var TestAllTypes_NestedEnum_name = map[int32]string{
	0:  "ZERO",
	1:  "FOO",
	2:  "BAR",
	3:  "BAZ",
	-1: "NEG",
}
var TestAllTypes_NestedEnum_value = map[string]int32{
	"ZERO": 0,
	"FOO":  1,
	"BAR":  2,
	"BAZ":  3,
	"NEG":  -1,
}

func (TestAllTypes_NestedEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTest, []int{0, 0}
}

type TestAllTypes struct {
	// Singular
	OptionalInt32          int32                       `protobuf:"varint,1000,opt,name=optional_int32,json=optionalInt32,proto3" json:"optional_int32,omitempty"`
	OptionalInt64          int64                       `protobuf:"varint,2,opt,name=optional_int64,json=optionalInt64,proto3" json:"optional_int64,omitempty"`
	OptionalUint32         uint32                      `protobuf:"varint,3,opt,name=optional_uint32,json=optionalUint32,proto3" json:"optional_uint32,omitempty"`
	OptionalUint64         uint64                      `protobuf:"varint,999,opt,name=optional_uint64,json=optionalUint64,proto3" json:"optional_uint64,omitempty"`
	OptionalSint32         int32                       `protobuf:"zigzag32,5,opt,name=optional_sint32,json=optionalSint32,proto3" json:"optional_sint32,omitempty"`
	OptionalSint64         int64                       `protobuf:"zigzag64,6,opt,name=optional_sint64,json=optionalSint64,proto3" json:"optional_sint64,omitempty"`
	OptionalFixed32        uint32                      `protobuf:"fixed32,7,opt,name=optional_fixed32,json=optionalFixed32,proto3" json:"optional_fixed32,omitempty"`
	OptionalFixed64        uint64                      `protobuf:"fixed64,8,opt,name=optional_fixed64,json=optionalFixed64,proto3" json:"optional_fixed64,omitempty"`
	OptionalSfixed32       int32                       `protobuf:"fixed32,9,opt,name=optional_sfixed32,json=optionalSfixed32,proto3" json:"optional_sfixed32,omitempty"`
	OptionalSfixed64       int64                       `protobuf:"fixed64,10,opt,name=optional_sfixed64,json=optionalSfixed64,proto3" json:"optional_sfixed64,omitempty"`
	OptionalFloat          float32                     `protobuf:"fixed32,11,opt,name=optional_float,json=optionalFloat,proto3" json:"optional_float,omitempty"`
	OptionalDouble         float64                     `protobuf:"fixed64,12,opt,name=optional_double,json=optionalDouble,proto3" json:"optional_double,omitempty"`
	OptionalBool           bool                        `protobuf:"varint,13,opt,name=optional_bool,json=optionalBool,proto3" json:"optional_bool,omitempty"`
	OptionalString         string                      `protobuf:"bytes,14,opt,name=optional_string,json=optionalString,proto3" json:"optional_string,omitempty"`
	OptionalBytes          []byte                      `protobuf:"bytes,15,opt,name=optional_bytes,json=optionalBytes,proto3" json:"optional_bytes,omitempty"`
	OptionalNestedMessage  *TestAllTypes_NestedMessage `protobuf:"bytes,18,opt,name=optional_nested_message,json=optionalNestedMessage" json:"optional_nested_message,omitempty"`
	OptionalForeignMessage *ForeignMessage             `protobuf:"bytes,19,opt,name=optional_foreign_message,json=optionalForeignMessage" json:"optional_foreign_message,omitempty"`
	OptionalNestedEnum     TestAllTypes_NestedEnum     `protobuf:"varint,21,opt,name=optional_nested_enum,json=optionalNestedEnum,proto3,enum=tensorflow.test.TestAllTypes_NestedEnum" json:"optional_nested_enum,omitempty"`
	OptionalForeignEnum    ForeignEnum                 `protobuf:"varint,22,opt,name=optional_foreign_enum,json=optionalForeignEnum,proto3,enum=tensorflow.test.ForeignEnum" json:"optional_foreign_enum,omitempty"`
	OptionalCord           string                      `protobuf:"bytes,25,opt,name=optional_cord,json=optionalCord,proto3" json:"optional_cord,omitempty"`
	// Repeated
	RepeatedInt32         []int32                       `protobuf:"varint,31,rep,packed,name=repeated_int32,json=repeatedInt32" json:"repeated_int32,omitempty"`
	RepeatedInt64         []int64                       `protobuf:"varint,32,rep,packed,name=repeated_int64,json=repeatedInt64" json:"repeated_int64,omitempty"`
	RepeatedUint32        []uint32                      `protobuf:"varint,33,rep,packed,name=repeated_uint32,json=repeatedUint32" json:"repeated_uint32,omitempty"`
	RepeatedUint64        []uint64                      `protobuf:"varint,34,rep,packed,name=repeated_uint64,json=repeatedUint64" json:"repeated_uint64,omitempty"`
	RepeatedSint32        []int32                       `protobuf:"zigzag32,35,rep,packed,name=repeated_sint32,json=repeatedSint32" json:"repeated_sint32,omitempty"`
	RepeatedSint64        []int64                       `protobuf:"zigzag64,36,rep,packed,name=repeated_sint64,json=repeatedSint64" json:"repeated_sint64,omitempty"`
	RepeatedFixed32       []uint32                      `protobuf:"fixed32,37,rep,packed,name=repeated_fixed32,json=repeatedFixed32" json:"repeated_fixed32,omitempty"`
	RepeatedFixed64       []uint64                      `protobuf:"fixed64,38,rep,packed,name=repeated_fixed64,json=repeatedFixed64" json:"repeated_fixed64,omitempty"`
	RepeatedSfixed32      []int32                       `protobuf:"fixed32,39,rep,packed,name=repeated_sfixed32,json=repeatedSfixed32" json:"repeated_sfixed32,omitempty"`
	RepeatedSfixed64      []int64                       `protobuf:"fixed64,40,rep,packed,name=repeated_sfixed64,json=repeatedSfixed64" json:"repeated_sfixed64,omitempty"`
	RepeatedFloat         []float32                     `protobuf:"fixed32,41,rep,packed,name=repeated_float,json=repeatedFloat" json:"repeated_float,omitempty"`
	RepeatedDouble        []float64                     `protobuf:"fixed64,42,rep,packed,name=repeated_double,json=repeatedDouble" json:"repeated_double,omitempty"`
	RepeatedBool          []bool                        `protobuf:"varint,43,rep,packed,name=repeated_bool,json=repeatedBool" json:"repeated_bool,omitempty"`
	RepeatedString        []string                      `protobuf:"bytes,44,rep,name=repeated_string,json=repeatedString" json:"repeated_string,omitempty"`
	RepeatedBytes         [][]byte                      `protobuf:"bytes,45,rep,name=repeated_bytes,json=repeatedBytes" json:"repeated_bytes,omitempty"`
	RepeatedNestedMessage []*TestAllTypes_NestedMessage `protobuf:"bytes,48,rep,name=repeated_nested_message,json=repeatedNestedMessage" json:"repeated_nested_message,omitempty"`
	RepeatedNestedEnum    []TestAllTypes_NestedEnum     `protobuf:"varint,51,rep,packed,name=repeated_nested_enum,json=repeatedNestedEnum,enum=tensorflow.test.TestAllTypes_NestedEnum" json:"repeated_nested_enum,omitempty"`
	RepeatedCord          []string                      `protobuf:"bytes,55,rep,name=repeated_cord,json=repeatedCord" json:"repeated_cord,omitempty"`
	// Types that are valid to be assigned to OneofField:
	//	*TestAllTypes_OneofUint32
	//	*TestAllTypes_OneofNestedMessage
	//	*TestAllTypes_OneofString
	//	*TestAllTypes_OneofBytes
	//	*TestAllTypes_OneofEnum
	OneofField                isTestAllTypes_OneofField              `protobuf_oneof:"oneof_field"`
	MapStringToMessage        map[string]*TestAllTypes_NestedMessage `protobuf:"bytes,58,rep,name=map_string_to_message,json=mapStringToMessage" json:"map_string_to_message,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	MapInt32ToMessage         map[int32]*TestAllTypes_NestedMessage  `protobuf:"bytes,59,rep,name=map_int32_to_message,json=mapInt32ToMessage" json:"map_int32_to_message,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	MapInt64ToMessage         map[int64]*TestAllTypes_NestedMessage  `protobuf:"bytes,60,rep,name=map_int64_to_message,json=mapInt64ToMessage" json:"map_int64_to_message,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	MapBoolToMessage          map[bool]*TestAllTypes_NestedMessage   `protobuf:"bytes,61,rep,name=map_bool_to_message,json=mapBoolToMessage" json:"map_bool_to_message,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	MapStringToInt64          map[string]int64                       `protobuf:"bytes,62,rep,name=map_string_to_int64,json=mapStringToInt64" json:"map_string_to_int64,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MapInt64ToString          map[int64]string                       `protobuf:"bytes,63,rep,name=map_int64_to_string,json=mapInt64ToString" json:"map_int64_to_string,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AnotherMapStringToMessage map[string]*TestAllTypes_NestedMessage `protobuf:"bytes,65,rep,name=another_map_string_to_message,json=anotherMapStringToMessage" json:"another_map_string_to_message,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	PackedRepeatedInt64       []int64                                `protobuf:"varint,64,rep,packed,name=packed_repeated_int64,json=packedRepeatedInt64" json:"packed_repeated_int64,omitempty"`
}

func (m *TestAllTypes) Reset()                    { *m = TestAllTypes{} }
func (*TestAllTypes) ProtoMessage()               {}
func (*TestAllTypes) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{0} }

type isTestAllTypes_OneofField interface {
	isTestAllTypes_OneofField()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TestAllTypes_OneofUint32 struct {
	OneofUint32 uint32 `protobuf:"varint,111,opt,name=oneof_uint32,json=oneofUint32,proto3,oneof"`
}
type TestAllTypes_OneofNestedMessage struct {
	OneofNestedMessage *TestAllTypes_NestedMessage `protobuf:"bytes,112,opt,name=oneof_nested_message,json=oneofNestedMessage,oneof"`
}
type TestAllTypes_OneofString struct {
	OneofString string `protobuf:"bytes,113,opt,name=oneof_string,json=oneofString,proto3,oneof"`
}
type TestAllTypes_OneofBytes struct {
	OneofBytes []byte `protobuf:"bytes,114,opt,name=oneof_bytes,json=oneofBytes,proto3,oneof"`
}
type TestAllTypes_OneofEnum struct {
	OneofEnum TestAllTypes_NestedEnum `protobuf:"varint,100,opt,name=oneof_enum,json=oneofEnum,proto3,enum=tensorflow.test.TestAllTypes_NestedEnum,oneof"`
}

func (*TestAllTypes_OneofUint32) isTestAllTypes_OneofField()        {}
func (*TestAllTypes_OneofNestedMessage) isTestAllTypes_OneofField() {}
func (*TestAllTypes_OneofString) isTestAllTypes_OneofField()        {}
func (*TestAllTypes_OneofBytes) isTestAllTypes_OneofField()         {}
func (*TestAllTypes_OneofEnum) isTestAllTypes_OneofField()          {}

func (m *TestAllTypes) GetOneofField() isTestAllTypes_OneofField {
	if m != nil {
		return m.OneofField
	}
	return nil
}

func (m *TestAllTypes) GetOptionalInt32() int32 {
	if m != nil {
		return m.OptionalInt32
	}
	return 0
}

func (m *TestAllTypes) GetOptionalInt64() int64 {
	if m != nil {
		return m.OptionalInt64
	}
	return 0
}

func (m *TestAllTypes) GetOptionalUint32() uint32 {
	if m != nil {
		return m.OptionalUint32
	}
	return 0
}

func (m *TestAllTypes) GetOptionalUint64() uint64 {
	if m != nil {
		return m.OptionalUint64
	}
	return 0
}

func (m *TestAllTypes) GetOptionalSint32() int32 {
	if m != nil {
		return m.OptionalSint32
	}
	return 0
}

func (m *TestAllTypes) GetOptionalSint64() int64 {
	if m != nil {
		return m.OptionalSint64
	}
	return 0
}

func (m *TestAllTypes) GetOptionalFixed32() uint32 {
	if m != nil {
		return m.OptionalFixed32
	}
	return 0
}

func (m *TestAllTypes) GetOptionalFixed64() uint64 {
	if m != nil {
		return m.OptionalFixed64
	}
	return 0
}

func (m *TestAllTypes) GetOptionalSfixed32() int32 {
	if m != nil {
		return m.OptionalSfixed32
	}
	return 0
}

func (m *TestAllTypes) GetOptionalSfixed64() int64 {
	if m != nil {
		return m.OptionalSfixed64
	}
	return 0
}

func (m *TestAllTypes) GetOptionalFloat() float32 {
	if m != nil {
		return m.OptionalFloat
	}
	return 0
}

func (m *TestAllTypes) GetOptionalDouble() float64 {
	if m != nil {
		return m.OptionalDouble
	}
	return 0
}

func (m *TestAllTypes) GetOptionalBool() bool {
	if m != nil {
		return m.OptionalBool
	}
	return false
}

func (m *TestAllTypes) GetOptionalString() string {
	if m != nil {
		return m.OptionalString
	}
	return ""
}

func (m *TestAllTypes) GetOptionalBytes() []byte {
	if m != nil {
		return m.OptionalBytes
	}
	return nil
}

func (m *TestAllTypes) GetOptionalNestedMessage() *TestAllTypes_NestedMessage {
	if m != nil {
		return m.OptionalNestedMessage
	}
	return nil
}

func (m *TestAllTypes) GetOptionalForeignMessage() *ForeignMessage {
	if m != nil {
		return m.OptionalForeignMessage
	}
	return nil
}

func (m *TestAllTypes) GetOptionalNestedEnum() TestAllTypes_NestedEnum {
	if m != nil {
		return m.OptionalNestedEnum
	}
	return ZERO
}

func (m *TestAllTypes) GetOptionalForeignEnum() ForeignEnum {
	if m != nil {
		return m.OptionalForeignEnum
	}
	return FOREIGN_ZERO
}

func (m *TestAllTypes) GetOptionalCord() string {
	if m != nil {
		return m.OptionalCord
	}
	return ""
}

func (m *TestAllTypes) GetRepeatedInt32() []int32 {
	if m != nil {
		return m.RepeatedInt32
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedInt64() []int64 {
	if m != nil {
		return m.RepeatedInt64
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedUint32() []uint32 {
	if m != nil {
		return m.RepeatedUint32
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedUint64() []uint64 {
	if m != nil {
		return m.RepeatedUint64
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedSint32() []int32 {
	if m != nil {
		return m.RepeatedSint32
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedSint64() []int64 {
	if m != nil {
		return m.RepeatedSint64
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedFixed32() []uint32 {
	if m != nil {
		return m.RepeatedFixed32
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedFixed64() []uint64 {
	if m != nil {
		return m.RepeatedFixed64
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedSfixed32() []int32 {
	if m != nil {
		return m.RepeatedSfixed32
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedSfixed64() []int64 {
	if m != nil {
		return m.RepeatedSfixed64
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedFloat() []float32 {
	if m != nil {
		return m.RepeatedFloat
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedDouble() []float64 {
	if m != nil {
		return m.RepeatedDouble
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedBool() []bool {
	if m != nil {
		return m.RepeatedBool
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedString() []string {
	if m != nil {
		return m.RepeatedString
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedBytes() [][]byte {
	if m != nil {
		return m.RepeatedBytes
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedNestedMessage() []*TestAllTypes_NestedMessage {
	if m != nil {
		return m.RepeatedNestedMessage
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedNestedEnum() []TestAllTypes_NestedEnum {
	if m != nil {
		return m.RepeatedNestedEnum
	}
	return nil
}

func (m *TestAllTypes) GetRepeatedCord() []string {
	if m != nil {
		return m.RepeatedCord
	}
	return nil
}

func (m *TestAllTypes) GetOneofUint32() uint32 {
	if x, ok := m.GetOneofField().(*TestAllTypes_OneofUint32); ok {
		return x.OneofUint32
	}
	return 0
}

func (m *TestAllTypes) GetOneofNestedMessage() *TestAllTypes_NestedMessage {
	if x, ok := m.GetOneofField().(*TestAllTypes_OneofNestedMessage); ok {
		return x.OneofNestedMessage
	}
	return nil
}

func (m *TestAllTypes) GetOneofString() string {
	if x, ok := m.GetOneofField().(*TestAllTypes_OneofString); ok {
		return x.OneofString
	}
	return ""
}

func (m *TestAllTypes) GetOneofBytes() []byte {
	if x, ok := m.GetOneofField().(*TestAllTypes_OneofBytes); ok {
		return x.OneofBytes
	}
	return nil
}

func (m *TestAllTypes) GetOneofEnum() TestAllTypes_NestedEnum {
	if x, ok := m.GetOneofField().(*TestAllTypes_OneofEnum); ok {
		return x.OneofEnum
	}
	return ZERO
}

func (m *TestAllTypes) GetMapStringToMessage() map[string]*TestAllTypes_NestedMessage {
	if m != nil {
		return m.MapStringToMessage
	}
	return nil
}

func (m *TestAllTypes) GetMapInt32ToMessage() map[int32]*TestAllTypes_NestedMessage {
	if m != nil {
		return m.MapInt32ToMessage
	}
	return nil
}

func (m *TestAllTypes) GetMapInt64ToMessage() map[int64]*TestAllTypes_NestedMessage {
	if m != nil {
		return m.MapInt64ToMessage
	}
	return nil
}

func (m *TestAllTypes) GetMapBoolToMessage() map[bool]*TestAllTypes_NestedMessage {
	if m != nil {
		return m.MapBoolToMessage
	}
	return nil
}

func (m *TestAllTypes) GetMapStringToInt64() map[string]int64 {
	if m != nil {
		return m.MapStringToInt64
	}
	return nil
}

func (m *TestAllTypes) GetMapInt64ToString() map[int64]string {
	if m != nil {
		return m.MapInt64ToString
	}
	return nil
}

func (m *TestAllTypes) GetAnotherMapStringToMessage() map[string]*TestAllTypes_NestedMessage {
	if m != nil {
		return m.AnotherMapStringToMessage
	}
	return nil
}

func (m *TestAllTypes) GetPackedRepeatedInt64() []int64 {
	if m != nil {
		return m.PackedRepeatedInt64
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TestAllTypes) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TestAllTypes_OneofMarshaler, _TestAllTypes_OneofUnmarshaler, _TestAllTypes_OneofSizer, []interface{}{
		(*TestAllTypes_OneofUint32)(nil),
		(*TestAllTypes_OneofNestedMessage)(nil),
		(*TestAllTypes_OneofString)(nil),
		(*TestAllTypes_OneofBytes)(nil),
		(*TestAllTypes_OneofEnum)(nil),
	}
}

func _TestAllTypes_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TestAllTypes)
	// oneof_field
	switch x := m.OneofField.(type) {
	case *TestAllTypes_OneofUint32:
		_ = b.EncodeVarint(111<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.OneofUint32))
	case *TestAllTypes_OneofNestedMessage:
		_ = b.EncodeVarint(112<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OneofNestedMessage); err != nil {
			return err
		}
	case *TestAllTypes_OneofString:
		_ = b.EncodeVarint(113<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.OneofString)
	case *TestAllTypes_OneofBytes:
		_ = b.EncodeVarint(114<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.OneofBytes)
	case *TestAllTypes_OneofEnum:
		_ = b.EncodeVarint(100<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.OneofEnum))
	case nil:
	default:
		return fmt.Errorf("TestAllTypes.OneofField has unexpected type %T", x)
	}
	return nil
}

func _TestAllTypes_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TestAllTypes)
	switch tag {
	case 111: // oneof_field.oneof_uint32
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.OneofField = &TestAllTypes_OneofUint32{uint32(x)}
		return true, err
	case 112: // oneof_field.oneof_nested_message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestAllTypes_NestedMessage)
		err := b.DecodeMessage(msg)
		m.OneofField = &TestAllTypes_OneofNestedMessage{msg}
		return true, err
	case 113: // oneof_field.oneof_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.OneofField = &TestAllTypes_OneofString{x}
		return true, err
	case 114: // oneof_field.oneof_bytes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.OneofField = &TestAllTypes_OneofBytes{x}
		return true, err
	case 100: // oneof_field.oneof_enum
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.OneofField = &TestAllTypes_OneofEnum{TestAllTypes_NestedEnum(x)}
		return true, err
	default:
		return false, nil
	}
}

func _TestAllTypes_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TestAllTypes)
	// oneof_field
	switch x := m.OneofField.(type) {
	case *TestAllTypes_OneofUint32:
		n += proto.SizeVarint(111<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.OneofUint32))
	case *TestAllTypes_OneofNestedMessage:
		s := proto.Size(x.OneofNestedMessage)
		n += proto.SizeVarint(112<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TestAllTypes_OneofString:
		n += proto.SizeVarint(113<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.OneofString)))
		n += len(x.OneofString)
	case *TestAllTypes_OneofBytes:
		n += proto.SizeVarint(114<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.OneofBytes)))
		n += len(x.OneofBytes)
	case *TestAllTypes_OneofEnum:
		n += proto.SizeVarint(100<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.OneofEnum))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TestAllTypes_NestedMessage struct {
	OptionalInt32 int32                                           `protobuf:"varint,1,opt,name=optional_int32,json=optionalInt32,proto3" json:"optional_int32,omitempty"`
	RepeatedInt32 []int32                                         `protobuf:"varint,2,rep,packed,name=repeated_int32,json=repeatedInt32" json:"repeated_int32,omitempty"`
	Msg           *TestAllTypes_NestedMessage_DoubleNestedMessage `protobuf:"bytes,3,opt,name=msg" json:"msg,omitempty"`
	OptionalInt64 int64                                           `protobuf:"varint,4,opt,name=optional_int64,json=optionalInt64,proto3" json:"optional_int64,omitempty"`
}

func (m *TestAllTypes_NestedMessage) Reset()      { *m = TestAllTypes_NestedMessage{} }
func (*TestAllTypes_NestedMessage) ProtoMessage() {}
func (*TestAllTypes_NestedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorTest, []int{0, 0}
}

func (m *TestAllTypes_NestedMessage) GetOptionalInt32() int32 {
	if m != nil {
		return m.OptionalInt32
	}
	return 0
}

func (m *TestAllTypes_NestedMessage) GetRepeatedInt32() []int32 {
	if m != nil {
		return m.RepeatedInt32
	}
	return nil
}

func (m *TestAllTypes_NestedMessage) GetMsg() *TestAllTypes_NestedMessage_DoubleNestedMessage {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *TestAllTypes_NestedMessage) GetOptionalInt64() int64 {
	if m != nil {
		return m.OptionalInt64
	}
	return 0
}

type TestAllTypes_NestedMessage_DoubleNestedMessage struct {
	OptionalString string `protobuf:"bytes,1,opt,name=optional_string,json=optionalString,proto3" json:"optional_string,omitempty"`
}

func (m *TestAllTypes_NestedMessage_DoubleNestedMessage) Reset() {
	*m = TestAllTypes_NestedMessage_DoubleNestedMessage{}
}
func (*TestAllTypes_NestedMessage_DoubleNestedMessage) ProtoMessage() {}
func (*TestAllTypes_NestedMessage_DoubleNestedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorTest, []int{0, 0, 0}
}

func (m *TestAllTypes_NestedMessage_DoubleNestedMessage) GetOptionalString() string {
	if m != nil {
		return m.OptionalString
	}
	return ""
}

// A recursive message.
type NestedTestAllTypes struct {
	Child            *NestedTestAllTypes `protobuf:"bytes,1,opt,name=child" json:"child,omitempty"`
	Payload          *TestAllTypes       `protobuf:"bytes,2,opt,name=payload" json:"payload,omitempty"`
	MapStringToInt64 map[string]int64    `protobuf:"bytes,3,rep,name=map_string_to_int64,json=mapStringToInt64" json:"map_string_to_int64,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *NestedTestAllTypes) Reset()                    { *m = NestedTestAllTypes{} }
func (*NestedTestAllTypes) ProtoMessage()               {}
func (*NestedTestAllTypes) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{1} }

func (m *NestedTestAllTypes) GetChild() *NestedTestAllTypes {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *NestedTestAllTypes) GetPayload() *TestAllTypes {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *NestedTestAllTypes) GetMapStringToInt64() map[string]int64 {
	if m != nil {
		return m.MapStringToInt64
	}
	return nil
}

type ForeignMessage struct {
	C int32 `protobuf:"varint,1,opt,name=c,proto3" json:"c,omitempty"`
}

func (m *ForeignMessage) Reset()                    { *m = ForeignMessage{} }
func (*ForeignMessage) ProtoMessage()               {}
func (*ForeignMessage) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{2} }

func (m *ForeignMessage) GetC() int32 {
	if m != nil {
		return m.C
	}
	return 0
}

type TestEmptyMessage struct {
}

func (m *TestEmptyMessage) Reset()                    { *m = TestEmptyMessage{} }
func (*TestEmptyMessage) ProtoMessage()               {}
func (*TestEmptyMessage) Descriptor() ([]byte, []int) { return fileDescriptorTest, []int{3} }

func init() {
	proto.RegisterType((*TestAllTypes)(nil), "tensorflow.test.TestAllTypes")
	proto.RegisterType((*TestAllTypes_NestedMessage)(nil), "tensorflow.test.TestAllTypes.NestedMessage")
	proto.RegisterType((*TestAllTypes_NestedMessage_DoubleNestedMessage)(nil), "tensorflow.test.TestAllTypes.NestedMessage.DoubleNestedMessage")
	proto.RegisterType((*NestedTestAllTypes)(nil), "tensorflow.test.NestedTestAllTypes")
	proto.RegisterType((*ForeignMessage)(nil), "tensorflow.test.ForeignMessage")
	proto.RegisterType((*TestEmptyMessage)(nil), "tensorflow.test.TestEmptyMessage")
	proto.RegisterEnum("tensorflow.test.ForeignEnum", ForeignEnum_name, ForeignEnum_value)
	proto.RegisterEnum("tensorflow.test.TestAllTypes_NestedEnum", TestAllTypes_NestedEnum_name, TestAllTypes_NestedEnum_value)
}
func (x ForeignEnum) String() string {
	s, ok := ForeignEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TestAllTypes_NestedEnum) String() string {
	s, ok := TestAllTypes_NestedEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TestAllTypes) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestAllTypes)
	if !ok {
		that2, ok := that.(TestAllTypes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.OptionalInt32 != that1.OptionalInt32 {
		return false
	}
	if this.OptionalInt64 != that1.OptionalInt64 {
		return false
	}
	if this.OptionalUint32 != that1.OptionalUint32 {
		return false
	}
	if this.OptionalUint64 != that1.OptionalUint64 {
		return false
	}
	if this.OptionalSint32 != that1.OptionalSint32 {
		return false
	}
	if this.OptionalSint64 != that1.OptionalSint64 {
		return false
	}
	if this.OptionalFixed32 != that1.OptionalFixed32 {
		return false
	}
	if this.OptionalFixed64 != that1.OptionalFixed64 {
		return false
	}
	if this.OptionalSfixed32 != that1.OptionalSfixed32 {
		return false
	}
	if this.OptionalSfixed64 != that1.OptionalSfixed64 {
		return false
	}
	if this.OptionalFloat != that1.OptionalFloat {
		return false
	}
	if this.OptionalDouble != that1.OptionalDouble {
		return false
	}
	if this.OptionalBool != that1.OptionalBool {
		return false
	}
	if this.OptionalString != that1.OptionalString {
		return false
	}
	if !bytes.Equal(this.OptionalBytes, that1.OptionalBytes) {
		return false
	}
	if !this.OptionalNestedMessage.Equal(that1.OptionalNestedMessage) {
		return false
	}
	if !this.OptionalForeignMessage.Equal(that1.OptionalForeignMessage) {
		return false
	}
	if this.OptionalNestedEnum != that1.OptionalNestedEnum {
		return false
	}
	if this.OptionalForeignEnum != that1.OptionalForeignEnum {
		return false
	}
	if this.OptionalCord != that1.OptionalCord {
		return false
	}
	if len(this.RepeatedInt32) != len(that1.RepeatedInt32) {
		return false
	}
	for i := range this.RepeatedInt32 {
		if this.RepeatedInt32[i] != that1.RepeatedInt32[i] {
			return false
		}
	}
	if len(this.RepeatedInt64) != len(that1.RepeatedInt64) {
		return false
	}
	for i := range this.RepeatedInt64 {
		if this.RepeatedInt64[i] != that1.RepeatedInt64[i] {
			return false
		}
	}
	if len(this.RepeatedUint32) != len(that1.RepeatedUint32) {
		return false
	}
	for i := range this.RepeatedUint32 {
		if this.RepeatedUint32[i] != that1.RepeatedUint32[i] {
			return false
		}
	}
	if len(this.RepeatedUint64) != len(that1.RepeatedUint64) {
		return false
	}
	for i := range this.RepeatedUint64 {
		if this.RepeatedUint64[i] != that1.RepeatedUint64[i] {
			return false
		}
	}
	if len(this.RepeatedSint32) != len(that1.RepeatedSint32) {
		return false
	}
	for i := range this.RepeatedSint32 {
		if this.RepeatedSint32[i] != that1.RepeatedSint32[i] {
			return false
		}
	}
	if len(this.RepeatedSint64) != len(that1.RepeatedSint64) {
		return false
	}
	for i := range this.RepeatedSint64 {
		if this.RepeatedSint64[i] != that1.RepeatedSint64[i] {
			return false
		}
	}
	if len(this.RepeatedFixed32) != len(that1.RepeatedFixed32) {
		return false
	}
	for i := range this.RepeatedFixed32 {
		if this.RepeatedFixed32[i] != that1.RepeatedFixed32[i] {
			return false
		}
	}
	if len(this.RepeatedFixed64) != len(that1.RepeatedFixed64) {
		return false
	}
	for i := range this.RepeatedFixed64 {
		if this.RepeatedFixed64[i] != that1.RepeatedFixed64[i] {
			return false
		}
	}
	if len(this.RepeatedSfixed32) != len(that1.RepeatedSfixed32) {
		return false
	}
	for i := range this.RepeatedSfixed32 {
		if this.RepeatedSfixed32[i] != that1.RepeatedSfixed32[i] {
			return false
		}
	}
	if len(this.RepeatedSfixed64) != len(that1.RepeatedSfixed64) {
		return false
	}
	for i := range this.RepeatedSfixed64 {
		if this.RepeatedSfixed64[i] != that1.RepeatedSfixed64[i] {
			return false
		}
	}
	if len(this.RepeatedFloat) != len(that1.RepeatedFloat) {
		return false
	}
	for i := range this.RepeatedFloat {
		if this.RepeatedFloat[i] != that1.RepeatedFloat[i] {
			return false
		}
	}
	if len(this.RepeatedDouble) != len(that1.RepeatedDouble) {
		return false
	}
	for i := range this.RepeatedDouble {
		if this.RepeatedDouble[i] != that1.RepeatedDouble[i] {
			return false
		}
	}
	if len(this.RepeatedBool) != len(that1.RepeatedBool) {
		return false
	}
	for i := range this.RepeatedBool {
		if this.RepeatedBool[i] != that1.RepeatedBool[i] {
			return false
		}
	}
	if len(this.RepeatedString) != len(that1.RepeatedString) {
		return false
	}
	for i := range this.RepeatedString {
		if this.RepeatedString[i] != that1.RepeatedString[i] {
			return false
		}
	}
	if len(this.RepeatedBytes) != len(that1.RepeatedBytes) {
		return false
	}
	for i := range this.RepeatedBytes {
		if !bytes.Equal(this.RepeatedBytes[i], that1.RepeatedBytes[i]) {
			return false
		}
	}
	if len(this.RepeatedNestedMessage) != len(that1.RepeatedNestedMessage) {
		return false
	}
	for i := range this.RepeatedNestedMessage {
		if !this.RepeatedNestedMessage[i].Equal(that1.RepeatedNestedMessage[i]) {
			return false
		}
	}
	if len(this.RepeatedNestedEnum) != len(that1.RepeatedNestedEnum) {
		return false
	}
	for i := range this.RepeatedNestedEnum {
		if this.RepeatedNestedEnum[i] != that1.RepeatedNestedEnum[i] {
			return false
		}
	}
	if len(this.RepeatedCord) != len(that1.RepeatedCord) {
		return false
	}
	for i := range this.RepeatedCord {
		if this.RepeatedCord[i] != that1.RepeatedCord[i] {
			return false
		}
	}
	if that1.OneofField == nil {
		if this.OneofField != nil {
			return false
		}
	} else if this.OneofField == nil {
		return false
	} else if !this.OneofField.Equal(that1.OneofField) {
		return false
	}
	if len(this.MapStringToMessage) != len(that1.MapStringToMessage) {
		return false
	}
	for i := range this.MapStringToMessage {
		if !this.MapStringToMessage[i].Equal(that1.MapStringToMessage[i]) {
			return false
		}
	}
	if len(this.MapInt32ToMessage) != len(that1.MapInt32ToMessage) {
		return false
	}
	for i := range this.MapInt32ToMessage {
		if !this.MapInt32ToMessage[i].Equal(that1.MapInt32ToMessage[i]) {
			return false
		}
	}
	if len(this.MapInt64ToMessage) != len(that1.MapInt64ToMessage) {
		return false
	}
	for i := range this.MapInt64ToMessage {
		if !this.MapInt64ToMessage[i].Equal(that1.MapInt64ToMessage[i]) {
			return false
		}
	}
	if len(this.MapBoolToMessage) != len(that1.MapBoolToMessage) {
		return false
	}
	for i := range this.MapBoolToMessage {
		if !this.MapBoolToMessage[i].Equal(that1.MapBoolToMessage[i]) {
			return false
		}
	}
	if len(this.MapStringToInt64) != len(that1.MapStringToInt64) {
		return false
	}
	for i := range this.MapStringToInt64 {
		if this.MapStringToInt64[i] != that1.MapStringToInt64[i] {
			return false
		}
	}
	if len(this.MapInt64ToString) != len(that1.MapInt64ToString) {
		return false
	}
	for i := range this.MapInt64ToString {
		if this.MapInt64ToString[i] != that1.MapInt64ToString[i] {
			return false
		}
	}
	if len(this.AnotherMapStringToMessage) != len(that1.AnotherMapStringToMessage) {
		return false
	}
	for i := range this.AnotherMapStringToMessage {
		if !this.AnotherMapStringToMessage[i].Equal(that1.AnotherMapStringToMessage[i]) {
			return false
		}
	}
	if len(this.PackedRepeatedInt64) != len(that1.PackedRepeatedInt64) {
		return false
	}
	for i := range this.PackedRepeatedInt64 {
		if this.PackedRepeatedInt64[i] != that1.PackedRepeatedInt64[i] {
			return false
		}
	}
	return true
}
func (this *TestAllTypes_OneofUint32) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestAllTypes_OneofUint32)
	if !ok {
		that2, ok := that.(TestAllTypes_OneofUint32)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.OneofUint32 != that1.OneofUint32 {
		return false
	}
	return true
}
func (this *TestAllTypes_OneofNestedMessage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestAllTypes_OneofNestedMessage)
	if !ok {
		that2, ok := that.(TestAllTypes_OneofNestedMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OneofNestedMessage.Equal(that1.OneofNestedMessage) {
		return false
	}
	return true
}
func (this *TestAllTypes_OneofString) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestAllTypes_OneofString)
	if !ok {
		that2, ok := that.(TestAllTypes_OneofString)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.OneofString != that1.OneofString {
		return false
	}
	return true
}
func (this *TestAllTypes_OneofBytes) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestAllTypes_OneofBytes)
	if !ok {
		that2, ok := that.(TestAllTypes_OneofBytes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.OneofBytes, that1.OneofBytes) {
		return false
	}
	return true
}
func (this *TestAllTypes_OneofEnum) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestAllTypes_OneofEnum)
	if !ok {
		that2, ok := that.(TestAllTypes_OneofEnum)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.OneofEnum != that1.OneofEnum {
		return false
	}
	return true
}
func (this *TestAllTypes_NestedMessage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestAllTypes_NestedMessage)
	if !ok {
		that2, ok := that.(TestAllTypes_NestedMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.OptionalInt32 != that1.OptionalInt32 {
		return false
	}
	if len(this.RepeatedInt32) != len(that1.RepeatedInt32) {
		return false
	}
	for i := range this.RepeatedInt32 {
		if this.RepeatedInt32[i] != that1.RepeatedInt32[i] {
			return false
		}
	}
	if !this.Msg.Equal(that1.Msg) {
		return false
	}
	if this.OptionalInt64 != that1.OptionalInt64 {
		return false
	}
	return true
}
func (this *TestAllTypes_NestedMessage_DoubleNestedMessage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestAllTypes_NestedMessage_DoubleNestedMessage)
	if !ok {
		that2, ok := that.(TestAllTypes_NestedMessage_DoubleNestedMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.OptionalString != that1.OptionalString {
		return false
	}
	return true
}
func (this *NestedTestAllTypes) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NestedTestAllTypes)
	if !ok {
		that2, ok := that.(NestedTestAllTypes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Child.Equal(that1.Child) {
		return false
	}
	if !this.Payload.Equal(that1.Payload) {
		return false
	}
	if len(this.MapStringToInt64) != len(that1.MapStringToInt64) {
		return false
	}
	for i := range this.MapStringToInt64 {
		if this.MapStringToInt64[i] != that1.MapStringToInt64[i] {
			return false
		}
	}
	return true
}
func (this *ForeignMessage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ForeignMessage)
	if !ok {
		that2, ok := that.(ForeignMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.C != that1.C {
		return false
	}
	return true
}
func (this *TestEmptyMessage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TestEmptyMessage)
	if !ok {
		that2, ok := that.(TestEmptyMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *TestAllTypes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 55)
	s = append(s, "&tensorflow_test.TestAllTypes{")
	s = append(s, "OptionalInt32: "+fmt.Sprintf("%#v", this.OptionalInt32)+",\n")
	s = append(s, "OptionalInt64: "+fmt.Sprintf("%#v", this.OptionalInt64)+",\n")
	s = append(s, "OptionalUint32: "+fmt.Sprintf("%#v", this.OptionalUint32)+",\n")
	s = append(s, "OptionalUint64: "+fmt.Sprintf("%#v", this.OptionalUint64)+",\n")
	s = append(s, "OptionalSint32: "+fmt.Sprintf("%#v", this.OptionalSint32)+",\n")
	s = append(s, "OptionalSint64: "+fmt.Sprintf("%#v", this.OptionalSint64)+",\n")
	s = append(s, "OptionalFixed32: "+fmt.Sprintf("%#v", this.OptionalFixed32)+",\n")
	s = append(s, "OptionalFixed64: "+fmt.Sprintf("%#v", this.OptionalFixed64)+",\n")
	s = append(s, "OptionalSfixed32: "+fmt.Sprintf("%#v", this.OptionalSfixed32)+",\n")
	s = append(s, "OptionalSfixed64: "+fmt.Sprintf("%#v", this.OptionalSfixed64)+",\n")
	s = append(s, "OptionalFloat: "+fmt.Sprintf("%#v", this.OptionalFloat)+",\n")
	s = append(s, "OptionalDouble: "+fmt.Sprintf("%#v", this.OptionalDouble)+",\n")
	s = append(s, "OptionalBool: "+fmt.Sprintf("%#v", this.OptionalBool)+",\n")
	s = append(s, "OptionalString: "+fmt.Sprintf("%#v", this.OptionalString)+",\n")
	s = append(s, "OptionalBytes: "+fmt.Sprintf("%#v", this.OptionalBytes)+",\n")
	if this.OptionalNestedMessage != nil {
		s = append(s, "OptionalNestedMessage: "+fmt.Sprintf("%#v", this.OptionalNestedMessage)+",\n")
	}
	if this.OptionalForeignMessage != nil {
		s = append(s, "OptionalForeignMessage: "+fmt.Sprintf("%#v", this.OptionalForeignMessage)+",\n")
	}
	s = append(s, "OptionalNestedEnum: "+fmt.Sprintf("%#v", this.OptionalNestedEnum)+",\n")
	s = append(s, "OptionalForeignEnum: "+fmt.Sprintf("%#v", this.OptionalForeignEnum)+",\n")
	s = append(s, "OptionalCord: "+fmt.Sprintf("%#v", this.OptionalCord)+",\n")
	s = append(s, "RepeatedInt32: "+fmt.Sprintf("%#v", this.RepeatedInt32)+",\n")
	s = append(s, "RepeatedInt64: "+fmt.Sprintf("%#v", this.RepeatedInt64)+",\n")
	s = append(s, "RepeatedUint32: "+fmt.Sprintf("%#v", this.RepeatedUint32)+",\n")
	s = append(s, "RepeatedUint64: "+fmt.Sprintf("%#v", this.RepeatedUint64)+",\n")
	s = append(s, "RepeatedSint32: "+fmt.Sprintf("%#v", this.RepeatedSint32)+",\n")
	s = append(s, "RepeatedSint64: "+fmt.Sprintf("%#v", this.RepeatedSint64)+",\n")
	s = append(s, "RepeatedFixed32: "+fmt.Sprintf("%#v", this.RepeatedFixed32)+",\n")
	s = append(s, "RepeatedFixed64: "+fmt.Sprintf("%#v", this.RepeatedFixed64)+",\n")
	s = append(s, "RepeatedSfixed32: "+fmt.Sprintf("%#v", this.RepeatedSfixed32)+",\n")
	s = append(s, "RepeatedSfixed64: "+fmt.Sprintf("%#v", this.RepeatedSfixed64)+",\n")
	s = append(s, "RepeatedFloat: "+fmt.Sprintf("%#v", this.RepeatedFloat)+",\n")
	s = append(s, "RepeatedDouble: "+fmt.Sprintf("%#v", this.RepeatedDouble)+",\n")
	s = append(s, "RepeatedBool: "+fmt.Sprintf("%#v", this.RepeatedBool)+",\n")
	s = append(s, "RepeatedString: "+fmt.Sprintf("%#v", this.RepeatedString)+",\n")
	s = append(s, "RepeatedBytes: "+fmt.Sprintf("%#v", this.RepeatedBytes)+",\n")
	if this.RepeatedNestedMessage != nil {
		s = append(s, "RepeatedNestedMessage: "+fmt.Sprintf("%#v", this.RepeatedNestedMessage)+",\n")
	}
	s = append(s, "RepeatedNestedEnum: "+fmt.Sprintf("%#v", this.RepeatedNestedEnum)+",\n")
	s = append(s, "RepeatedCord: "+fmt.Sprintf("%#v", this.RepeatedCord)+",\n")
	if this.OneofField != nil {
		s = append(s, "OneofField: "+fmt.Sprintf("%#v", this.OneofField)+",\n")
	}
	keysForMapStringToMessage := make([]string, 0, len(this.MapStringToMessage))
	for k, _ := range this.MapStringToMessage {
		keysForMapStringToMessage = append(keysForMapStringToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMapStringToMessage)
	mapStringForMapStringToMessage := "map[string]*TestAllTypes_NestedMessage{"
	for _, k := range keysForMapStringToMessage {
		mapStringForMapStringToMessage += fmt.Sprintf("%#v: %#v,", k, this.MapStringToMessage[k])
	}
	mapStringForMapStringToMessage += "}"
	if this.MapStringToMessage != nil {
		s = append(s, "MapStringToMessage: "+mapStringForMapStringToMessage+",\n")
	}
	keysForMapInt32ToMessage := make([]int32, 0, len(this.MapInt32ToMessage))
	for k, _ := range this.MapInt32ToMessage {
		keysForMapInt32ToMessage = append(keysForMapInt32ToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForMapInt32ToMessage)
	mapStringForMapInt32ToMessage := "map[int32]*TestAllTypes_NestedMessage{"
	for _, k := range keysForMapInt32ToMessage {
		mapStringForMapInt32ToMessage += fmt.Sprintf("%#v: %#v,", k, this.MapInt32ToMessage[k])
	}
	mapStringForMapInt32ToMessage += "}"
	if this.MapInt32ToMessage != nil {
		s = append(s, "MapInt32ToMessage: "+mapStringForMapInt32ToMessage+",\n")
	}
	keysForMapInt64ToMessage := make([]int64, 0, len(this.MapInt64ToMessage))
	for k, _ := range this.MapInt64ToMessage {
		keysForMapInt64ToMessage = append(keysForMapInt64ToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForMapInt64ToMessage)
	mapStringForMapInt64ToMessage := "map[int64]*TestAllTypes_NestedMessage{"
	for _, k := range keysForMapInt64ToMessage {
		mapStringForMapInt64ToMessage += fmt.Sprintf("%#v: %#v,", k, this.MapInt64ToMessage[k])
	}
	mapStringForMapInt64ToMessage += "}"
	if this.MapInt64ToMessage != nil {
		s = append(s, "MapInt64ToMessage: "+mapStringForMapInt64ToMessage+",\n")
	}
	keysForMapBoolToMessage := make([]bool, 0, len(this.MapBoolToMessage))
	for k, _ := range this.MapBoolToMessage {
		keysForMapBoolToMessage = append(keysForMapBoolToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForMapBoolToMessage)
	mapStringForMapBoolToMessage := "map[bool]*TestAllTypes_NestedMessage{"
	for _, k := range keysForMapBoolToMessage {
		mapStringForMapBoolToMessage += fmt.Sprintf("%#v: %#v,", k, this.MapBoolToMessage[k])
	}
	mapStringForMapBoolToMessage += "}"
	if this.MapBoolToMessage != nil {
		s = append(s, "MapBoolToMessage: "+mapStringForMapBoolToMessage+",\n")
	}
	keysForMapStringToInt64 := make([]string, 0, len(this.MapStringToInt64))
	for k, _ := range this.MapStringToInt64 {
		keysForMapStringToInt64 = append(keysForMapStringToInt64, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMapStringToInt64)
	mapStringForMapStringToInt64 := "map[string]int64{"
	for _, k := range keysForMapStringToInt64 {
		mapStringForMapStringToInt64 += fmt.Sprintf("%#v: %#v,", k, this.MapStringToInt64[k])
	}
	mapStringForMapStringToInt64 += "}"
	if this.MapStringToInt64 != nil {
		s = append(s, "MapStringToInt64: "+mapStringForMapStringToInt64+",\n")
	}
	keysForMapInt64ToString := make([]int64, 0, len(this.MapInt64ToString))
	for k, _ := range this.MapInt64ToString {
		keysForMapInt64ToString = append(keysForMapInt64ToString, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForMapInt64ToString)
	mapStringForMapInt64ToString := "map[int64]string{"
	for _, k := range keysForMapInt64ToString {
		mapStringForMapInt64ToString += fmt.Sprintf("%#v: %#v,", k, this.MapInt64ToString[k])
	}
	mapStringForMapInt64ToString += "}"
	if this.MapInt64ToString != nil {
		s = append(s, "MapInt64ToString: "+mapStringForMapInt64ToString+",\n")
	}
	keysForAnotherMapStringToMessage := make([]string, 0, len(this.AnotherMapStringToMessage))
	for k, _ := range this.AnotherMapStringToMessage {
		keysForAnotherMapStringToMessage = append(keysForAnotherMapStringToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnotherMapStringToMessage)
	mapStringForAnotherMapStringToMessage := "map[string]*TestAllTypes_NestedMessage{"
	for _, k := range keysForAnotherMapStringToMessage {
		mapStringForAnotherMapStringToMessage += fmt.Sprintf("%#v: %#v,", k, this.AnotherMapStringToMessage[k])
	}
	mapStringForAnotherMapStringToMessage += "}"
	if this.AnotherMapStringToMessage != nil {
		s = append(s, "AnotherMapStringToMessage: "+mapStringForAnotherMapStringToMessage+",\n")
	}
	s = append(s, "PackedRepeatedInt64: "+fmt.Sprintf("%#v", this.PackedRepeatedInt64)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TestAllTypes_OneofUint32) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_test.TestAllTypes_OneofUint32{` +
		`OneofUint32:` + fmt.Sprintf("%#v", this.OneofUint32) + `}`}, ", ")
	return s
}
func (this *TestAllTypes_OneofNestedMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_test.TestAllTypes_OneofNestedMessage{` +
		`OneofNestedMessage:` + fmt.Sprintf("%#v", this.OneofNestedMessage) + `}`}, ", ")
	return s
}
func (this *TestAllTypes_OneofString) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_test.TestAllTypes_OneofString{` +
		`OneofString:` + fmt.Sprintf("%#v", this.OneofString) + `}`}, ", ")
	return s
}
func (this *TestAllTypes_OneofBytes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_test.TestAllTypes_OneofBytes{` +
		`OneofBytes:` + fmt.Sprintf("%#v", this.OneofBytes) + `}`}, ", ")
	return s
}
func (this *TestAllTypes_OneofEnum) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_test.TestAllTypes_OneofEnum{` +
		`OneofEnum:` + fmt.Sprintf("%#v", this.OneofEnum) + `}`}, ", ")
	return s
}
func (this *TestAllTypes_NestedMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_test.TestAllTypes_NestedMessage{")
	s = append(s, "OptionalInt32: "+fmt.Sprintf("%#v", this.OptionalInt32)+",\n")
	s = append(s, "RepeatedInt32: "+fmt.Sprintf("%#v", this.RepeatedInt32)+",\n")
	if this.Msg != nil {
		s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	}
	s = append(s, "OptionalInt64: "+fmt.Sprintf("%#v", this.OptionalInt64)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TestAllTypes_NestedMessage_DoubleNestedMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_test.TestAllTypes_NestedMessage_DoubleNestedMessage{")
	s = append(s, "OptionalString: "+fmt.Sprintf("%#v", this.OptionalString)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NestedTestAllTypes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_test.NestedTestAllTypes{")
	if this.Child != nil {
		s = append(s, "Child: "+fmt.Sprintf("%#v", this.Child)+",\n")
	}
	if this.Payload != nil {
		s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	}
	keysForMapStringToInt64 := make([]string, 0, len(this.MapStringToInt64))
	for k, _ := range this.MapStringToInt64 {
		keysForMapStringToInt64 = append(keysForMapStringToInt64, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMapStringToInt64)
	mapStringForMapStringToInt64 := "map[string]int64{"
	for _, k := range keysForMapStringToInt64 {
		mapStringForMapStringToInt64 += fmt.Sprintf("%#v: %#v,", k, this.MapStringToInt64[k])
	}
	mapStringForMapStringToInt64 += "}"
	if this.MapStringToInt64 != nil {
		s = append(s, "MapStringToInt64: "+mapStringForMapStringToInt64+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ForeignMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_test.ForeignMessage{")
	s = append(s, "C: "+fmt.Sprintf("%#v", this.C)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TestEmptyMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&tensorflow_test.TestEmptyMessage{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTest(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TestAllTypes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OptionalInt64 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalInt64))
	}
	if m.OptionalUint32 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalUint32))
	}
	if m.OptionalSint32 != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTest(dAtA, i, uint64((uint32(m.OptionalSint32)<<1)^uint32((m.OptionalSint32>>31))))
	}
	if m.OptionalSint64 != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTest(dAtA, i, uint64((uint64(m.OptionalSint64)<<1)^uint64((m.OptionalSint64>>63))))
	}
	if m.OptionalFixed32 != 0 {
		dAtA[i] = 0x3d
		i++
		i = encodeFixed32Test(dAtA, i, uint32(m.OptionalFixed32))
	}
	if m.OptionalFixed64 != 0 {
		dAtA[i] = 0x41
		i++
		i = encodeFixed64Test(dAtA, i, uint64(m.OptionalFixed64))
	}
	if m.OptionalSfixed32 != 0 {
		dAtA[i] = 0x4d
		i++
		i = encodeFixed32Test(dAtA, i, uint32(m.OptionalSfixed32))
	}
	if m.OptionalSfixed64 != 0 {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64Test(dAtA, i, uint64(m.OptionalSfixed64))
	}
	if m.OptionalFloat != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Test(dAtA, i, uint32(math.Float32bits(float32(m.OptionalFloat))))
	}
	if m.OptionalDouble != 0 {
		dAtA[i] = 0x61
		i++
		i = encodeFixed64Test(dAtA, i, uint64(math.Float64bits(float64(m.OptionalDouble))))
	}
	if m.OptionalBool {
		dAtA[i] = 0x68
		i++
		if m.OptionalBool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.OptionalString) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.OptionalString)))
		i += copy(dAtA[i:], m.OptionalString)
	}
	if len(m.OptionalBytes) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.OptionalBytes)))
		i += copy(dAtA[i:], m.OptionalBytes)
	}
	if m.OptionalNestedMessage != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalNestedMessage.Size()))
		n1, err := m.OptionalNestedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.OptionalForeignMessage != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalForeignMessage.Size()))
		n2, err := m.OptionalForeignMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.OptionalNestedEnum != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalNestedEnum))
	}
	if m.OptionalForeignEnum != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalForeignEnum))
	}
	if len(m.OptionalCord) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.OptionalCord)))
		i += copy(dAtA[i:], m.OptionalCord)
	}
	if len(m.RepeatedInt32) > 0 {
		dAtA4 := make([]byte, len(m.RepeatedInt32)*10)
		var j3 int
		for _, num1 := range m.RepeatedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTest(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.RepeatedInt64) > 0 {
		dAtA6 := make([]byte, len(m.RepeatedInt64)*10)
		var j5 int
		for _, num1 := range m.RepeatedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.RepeatedUint32) > 0 {
		dAtA8 := make([]byte, len(m.RepeatedUint32)*10)
		var j7 int
		for _, num := range m.RepeatedUint32 {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.RepeatedUint64) > 0 {
		dAtA10 := make([]byte, len(m.RepeatedUint64)*10)
		var j9 int
		for _, num := range m.RepeatedUint64 {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if len(m.RepeatedSint32) > 0 {
		dAtA11 := make([]byte, len(m.RepeatedSint32)*5)
		var j12 int
		for _, num := range m.RepeatedSint32 {
			x13 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x13 >= 1<<7 {
				dAtA11[j12] = uint8(uint64(x13)&0x7f | 0x80)
				j12++
				x13 >>= 7
			}
			dAtA11[j12] = uint8(x13)
			j12++
		}
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA11[:j12])
	}
	if len(m.RepeatedSint64) > 0 {
		var j14 int
		dAtA16 := make([]byte, len(m.RepeatedSint64)*10)
		for _, num := range m.RepeatedSint64 {
			x15 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x15 >= 1<<7 {
				dAtA16[j14] = uint8(uint64(x15)&0x7f | 0x80)
				j14++
				x15 >>= 7
			}
			dAtA16[j14] = uint8(x15)
			j14++
		}
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA16[:j14])
	}
	if len(m.RepeatedFixed32) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.RepeatedFixed32)*4))
		for _, num := range m.RepeatedFixed32 {
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
		}
	}
	if len(m.RepeatedFixed64) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.RepeatedFixed64)*8))
		for _, num := range m.RepeatedFixed64 {
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.RepeatedSfixed32) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.RepeatedSfixed32)*4))
		for _, num := range m.RepeatedSfixed32 {
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
		}
	}
	if len(m.RepeatedSfixed64) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.RepeatedSfixed64)*8))
		for _, num := range m.RepeatedSfixed64 {
			dAtA[i] = uint8(num)
			i++
			dAtA[i] = uint8(num >> 8)
			i++
			dAtA[i] = uint8(num >> 16)
			i++
			dAtA[i] = uint8(num >> 24)
			i++
			dAtA[i] = uint8(num >> 32)
			i++
			dAtA[i] = uint8(num >> 40)
			i++
			dAtA[i] = uint8(num >> 48)
			i++
			dAtA[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.RepeatedFloat) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.RepeatedFloat)*4))
		for _, num := range m.RepeatedFloat {
			f17 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f17)
			i++
			dAtA[i] = uint8(f17 >> 8)
			i++
			dAtA[i] = uint8(f17 >> 16)
			i++
			dAtA[i] = uint8(f17 >> 24)
			i++
		}
	}
	if len(m.RepeatedDouble) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.RepeatedDouble)*8))
		for _, num := range m.RepeatedDouble {
			f18 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f18)
			i++
			dAtA[i] = uint8(f18 >> 8)
			i++
			dAtA[i] = uint8(f18 >> 16)
			i++
			dAtA[i] = uint8(f18 >> 24)
			i++
			dAtA[i] = uint8(f18 >> 32)
			i++
			dAtA[i] = uint8(f18 >> 40)
			i++
			dAtA[i] = uint8(f18 >> 48)
			i++
			dAtA[i] = uint8(f18 >> 56)
			i++
		}
	}
	if len(m.RepeatedBool) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.RepeatedBool)))
		for _, b := range m.RepeatedBool {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.RepeatedString) > 0 {
		for _, s := range m.RepeatedString {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for _, b := range m.RepeatedBytes {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for _, msg := range m.RepeatedNestedMessage {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintTest(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RepeatedNestedEnum) > 0 {
		dAtA20 := make([]byte, len(m.RepeatedNestedEnum)*10)
		var j19 int
		for _, num := range m.RepeatedNestedEnum {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintTest(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if len(m.RepeatedCord) > 0 {
		for _, s := range m.RepeatedCord {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x3
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.MapStringToMessage) > 0 {
		for k, _ := range m.MapStringToMessage {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x3
			i++
			v := m.MapStringToMessage[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTest(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + msgSize
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTest(dAtA, i, uint64(v.Size()))
				n21, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n21
			}
		}
	}
	if len(m.MapInt32ToMessage) > 0 {
		for k, _ := range m.MapInt32ToMessage {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x3
			i++
			v := m.MapInt32ToMessage[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTest(uint64(msgSize))
			}
			mapSize := 1 + sovTest(uint64(k)) + msgSize
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTest(dAtA, i, uint64(v.Size()))
				n22, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n22
			}
		}
	}
	if len(m.MapInt64ToMessage) > 0 {
		for k, _ := range m.MapInt64ToMessage {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x3
			i++
			v := m.MapInt64ToMessage[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTest(uint64(msgSize))
			}
			mapSize := 1 + sovTest(uint64(k)) + msgSize
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTest(dAtA, i, uint64(v.Size()))
				n23, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n23
			}
		}
	}
	if len(m.MapBoolToMessage) > 0 {
		for k, _ := range m.MapBoolToMessage {
			dAtA[i] = 0xea
			i++
			dAtA[i] = 0x3
			i++
			v := m.MapBoolToMessage[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTest(uint64(msgSize))
			}
			mapSize := 1 + 1 + msgSize
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			if k {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTest(dAtA, i, uint64(v.Size()))
				n24, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n24
			}
		}
	}
	if len(m.MapStringToInt64) > 0 {
		for k, _ := range m.MapStringToInt64 {
			dAtA[i] = 0xf2
			i++
			dAtA[i] = 0x3
			i++
			v := m.MapStringToInt64[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	if len(m.MapInt64ToString) > 0 {
		for k, _ := range m.MapInt64ToString {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x3
			i++
			v := m.MapInt64ToString[k]
			mapSize := 1 + sovTest(uint64(k)) + 1 + len(v) + sovTest(uint64(len(v)))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTest(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.PackedRepeatedInt64) > 0 {
		dAtA26 := make([]byte, len(m.PackedRepeatedInt64)*10)
		var j25 int
		for _, num1 := range m.PackedRepeatedInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x4
		i++
		i = encodeVarintTest(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if len(m.AnotherMapStringToMessage) > 0 {
		for k, _ := range m.AnotherMapStringToMessage {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x4
			i++
			v := m.AnotherMapStringToMessage[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTest(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + msgSize
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTest(dAtA, i, uint64(v.Size()))
				n27, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n27
			}
		}
	}
	if m.OneofField != nil {
		nn28, err := m.OneofField.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	if m.OptionalUint64 != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalUint64))
	}
	if m.OptionalInt32 != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalInt32))
	}
	return i, nil
}

func (m *TestAllTypes_OneofEnum) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintTest(dAtA, i, uint64(m.OneofEnum))
	return i, nil
}
func (m *TestAllTypes_OneofUint32) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xf8
	i++
	dAtA[i] = 0x6
	i++
	i = encodeVarintTest(dAtA, i, uint64(m.OneofUint32))
	return i, nil
}
func (m *TestAllTypes_OneofNestedMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OneofNestedMessage != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OneofNestedMessage.Size()))
		n29, err := m.OneofNestedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *TestAllTypes_OneofString) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x7
	i++
	i = encodeVarintTest(dAtA, i, uint64(len(m.OneofString)))
	i += copy(dAtA[i:], m.OneofString)
	return i, nil
}
func (m *TestAllTypes_OneofBytes) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OneofBytes != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x7
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.OneofBytes)))
		i += copy(dAtA[i:], m.OneofBytes)
	}
	return i, nil
}
func (m *TestAllTypes_NestedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypes_NestedMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OptionalInt32 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalInt32))
	}
	if len(m.RepeatedInt32) > 0 {
		dAtA31 := make([]byte, len(m.RepeatedInt32)*10)
		var j30 int
		for _, num1 := range m.RepeatedInt32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTest(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	if m.Msg != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.Msg.Size()))
		n32, err := m.Msg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.OptionalInt64 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.OptionalInt64))
	}
	return i, nil
}

func (m *TestAllTypes_NestedMessage_DoubleNestedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestAllTypes_NestedMessage_DoubleNestedMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OptionalString) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(len(m.OptionalString)))
		i += copy(dAtA[i:], m.OptionalString)
	}
	return i, nil
}

func (m *NestedTestAllTypes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NestedTestAllTypes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Child != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.Child.Size()))
		n33, err := m.Child.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Payload != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.Payload.Size()))
		n34, err := m.Payload.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.MapStringToInt64) > 0 {
		for k, _ := range m.MapStringToInt64 {
			dAtA[i] = 0x1a
			i++
			v := m.MapStringToInt64[k]
			mapSize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			i = encodeVarintTest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintTest(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ForeignMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.C != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTest(dAtA, i, uint64(m.C))
	}
	return i, nil
}

func (m *TestEmptyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestEmptyMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Test(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Test(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTest(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TestAllTypes) Size() (n int) {
	var l int
	_ = l
	if m.OptionalInt64 != 0 {
		n += 1 + sovTest(uint64(m.OptionalInt64))
	}
	if m.OptionalUint32 != 0 {
		n += 1 + sovTest(uint64(m.OptionalUint32))
	}
	if m.OptionalSint32 != 0 {
		n += 1 + sozTest(uint64(m.OptionalSint32))
	}
	if m.OptionalSint64 != 0 {
		n += 1 + sozTest(uint64(m.OptionalSint64))
	}
	if m.OptionalFixed32 != 0 {
		n += 5
	}
	if m.OptionalFixed64 != 0 {
		n += 9
	}
	if m.OptionalSfixed32 != 0 {
		n += 5
	}
	if m.OptionalSfixed64 != 0 {
		n += 9
	}
	if m.OptionalFloat != 0 {
		n += 5
	}
	if m.OptionalDouble != 0 {
		n += 9
	}
	if m.OptionalBool {
		n += 2
	}
	l = len(m.OptionalString)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	l = len(m.OptionalBytes)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	if m.OptionalNestedMessage != nil {
		l = m.OptionalNestedMessage.Size()
		n += 2 + l + sovTest(uint64(l))
	}
	if m.OptionalForeignMessage != nil {
		l = m.OptionalForeignMessage.Size()
		n += 2 + l + sovTest(uint64(l))
	}
	if m.OptionalNestedEnum != 0 {
		n += 2 + sovTest(uint64(m.OptionalNestedEnum))
	}
	if m.OptionalForeignEnum != 0 {
		n += 2 + sovTest(uint64(m.OptionalForeignEnum))
	}
	l = len(m.OptionalCord)
	if l > 0 {
		n += 2 + l + sovTest(uint64(l))
	}
	if len(m.RepeatedInt32) > 0 {
		l = 0
		for _, e := range m.RepeatedInt32 {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if len(m.RepeatedInt64) > 0 {
		l = 0
		for _, e := range m.RepeatedInt64 {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if len(m.RepeatedUint32) > 0 {
		l = 0
		for _, e := range m.RepeatedUint32 {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if len(m.RepeatedUint64) > 0 {
		l = 0
		for _, e := range m.RepeatedUint64 {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if len(m.RepeatedSint32) > 0 {
		l = 0
		for _, e := range m.RepeatedSint32 {
			l += sozTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if len(m.RepeatedSint64) > 0 {
		l = 0
		for _, e := range m.RepeatedSint64 {
			l += sozTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if len(m.RepeatedFixed32) > 0 {
		n += 2 + sovTest(uint64(len(m.RepeatedFixed32)*4)) + len(m.RepeatedFixed32)*4
	}
	if len(m.RepeatedFixed64) > 0 {
		n += 2 + sovTest(uint64(len(m.RepeatedFixed64)*8)) + len(m.RepeatedFixed64)*8
	}
	if len(m.RepeatedSfixed32) > 0 {
		n += 2 + sovTest(uint64(len(m.RepeatedSfixed32)*4)) + len(m.RepeatedSfixed32)*4
	}
	if len(m.RepeatedSfixed64) > 0 {
		n += 2 + sovTest(uint64(len(m.RepeatedSfixed64)*8)) + len(m.RepeatedSfixed64)*8
	}
	if len(m.RepeatedFloat) > 0 {
		n += 2 + sovTest(uint64(len(m.RepeatedFloat)*4)) + len(m.RepeatedFloat)*4
	}
	if len(m.RepeatedDouble) > 0 {
		n += 2 + sovTest(uint64(len(m.RepeatedDouble)*8)) + len(m.RepeatedDouble)*8
	}
	if len(m.RepeatedBool) > 0 {
		n += 2 + sovTest(uint64(len(m.RepeatedBool))) + len(m.RepeatedBool)*1
	}
	if len(m.RepeatedString) > 0 {
		for _, s := range m.RepeatedString {
			l = len(s)
			n += 2 + l + sovTest(uint64(l))
		}
	}
	if len(m.RepeatedBytes) > 0 {
		for _, b := range m.RepeatedBytes {
			l = len(b)
			n += 2 + l + sovTest(uint64(l))
		}
	}
	if len(m.RepeatedNestedMessage) > 0 {
		for _, e := range m.RepeatedNestedMessage {
			l = e.Size()
			n += 2 + l + sovTest(uint64(l))
		}
	}
	if len(m.RepeatedNestedEnum) > 0 {
		l = 0
		for _, e := range m.RepeatedNestedEnum {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if len(m.RepeatedCord) > 0 {
		for _, s := range m.RepeatedCord {
			l = len(s)
			n += 2 + l + sovTest(uint64(l))
		}
	}
	if len(m.MapStringToMessage) > 0 {
		for k, v := range m.MapStringToMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTest(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt32ToMessage) > 0 {
		for k, v := range m.MapInt32ToMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTest(uint64(l))
			}
			mapEntrySize := 1 + sovTest(uint64(k)) + l
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt64ToMessage) > 0 {
		for k, v := range m.MapInt64ToMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTest(uint64(l))
			}
			mapEntrySize := 1 + sovTest(uint64(k)) + l
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MapBoolToMessage) > 0 {
		for k, v := range m.MapBoolToMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTest(uint64(l))
			}
			mapEntrySize := 1 + 1 + l
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MapStringToInt64) > 0 {
		for k, v := range m.MapStringToInt64 {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.MapInt64ToString) > 0 {
		for k, v := range m.MapInt64ToString {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTest(uint64(k)) + 1 + len(v) + sovTest(uint64(len(v)))
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if len(m.PackedRepeatedInt64) > 0 {
		l = 0
		for _, e := range m.PackedRepeatedInt64 {
			l += sovTest(uint64(e))
		}
		n += 2 + sovTest(uint64(l)) + l
	}
	if len(m.AnotherMapStringToMessage) > 0 {
		for k, v := range m.AnotherMapStringToMessage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTest(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovTest(uint64(mapEntrySize))
		}
	}
	if m.OneofField != nil {
		n += m.OneofField.Size()
	}
	if m.OptionalUint64 != 0 {
		n += 2 + sovTest(uint64(m.OptionalUint64))
	}
	if m.OptionalInt32 != 0 {
		n += 2 + sovTest(uint64(m.OptionalInt32))
	}
	return n
}

func (m *TestAllTypes_OneofEnum) Size() (n int) {
	var l int
	_ = l
	n += 2 + sovTest(uint64(m.OneofEnum))
	return n
}
func (m *TestAllTypes_OneofUint32) Size() (n int) {
	var l int
	_ = l
	n += 2 + sovTest(uint64(m.OneofUint32))
	return n
}
func (m *TestAllTypes_OneofNestedMessage) Size() (n int) {
	var l int
	_ = l
	if m.OneofNestedMessage != nil {
		l = m.OneofNestedMessage.Size()
		n += 2 + l + sovTest(uint64(l))
	}
	return n
}
func (m *TestAllTypes_OneofString) Size() (n int) {
	var l int
	_ = l
	l = len(m.OneofString)
	n += 2 + l + sovTest(uint64(l))
	return n
}
func (m *TestAllTypes_OneofBytes) Size() (n int) {
	var l int
	_ = l
	if m.OneofBytes != nil {
		l = len(m.OneofBytes)
		n += 2 + l + sovTest(uint64(l))
	}
	return n
}
func (m *TestAllTypes_NestedMessage) Size() (n int) {
	var l int
	_ = l
	if m.OptionalInt32 != 0 {
		n += 1 + sovTest(uint64(m.OptionalInt32))
	}
	if len(m.RepeatedInt32) > 0 {
		l = 0
		for _, e := range m.RepeatedInt32 {
			l += sovTest(uint64(e))
		}
		n += 1 + sovTest(uint64(l)) + l
	}
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.OptionalInt64 != 0 {
		n += 1 + sovTest(uint64(m.OptionalInt64))
	}
	return n
}

func (m *TestAllTypes_NestedMessage_DoubleNestedMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.OptionalString)
	if l > 0 {
		n += 1 + l + sovTest(uint64(l))
	}
	return n
}

func (m *NestedTestAllTypes) Size() (n int) {
	var l int
	_ = l
	if m.Child != nil {
		l = m.Child.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovTest(uint64(l))
	}
	if len(m.MapStringToInt64) > 0 {
		for k, v := range m.MapStringToInt64 {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTest(uint64(len(k))) + 1 + sovTest(uint64(v))
			n += mapEntrySize + 1 + sovTest(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ForeignMessage) Size() (n int) {
	var l int
	_ = l
	if m.C != 0 {
		n += 1 + sovTest(uint64(m.C))
	}
	return n
}

func (m *TestEmptyMessage) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovTest(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTest(x uint64) (n int) {
	return sovTest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TestAllTypes) String() string {
	if this == nil {
		return "nil"
	}
	keysForMapStringToMessage := make([]string, 0, len(this.MapStringToMessage))
	for k, _ := range this.MapStringToMessage {
		keysForMapStringToMessage = append(keysForMapStringToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMapStringToMessage)
	mapStringForMapStringToMessage := "map[string]*TestAllTypes_NestedMessage{"
	for _, k := range keysForMapStringToMessage {
		mapStringForMapStringToMessage += fmt.Sprintf("%v: %v,", k, this.MapStringToMessage[k])
	}
	mapStringForMapStringToMessage += "}"
	keysForMapInt32ToMessage := make([]int32, 0, len(this.MapInt32ToMessage))
	for k, _ := range this.MapInt32ToMessage {
		keysForMapInt32ToMessage = append(keysForMapInt32ToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForMapInt32ToMessage)
	mapStringForMapInt32ToMessage := "map[int32]*TestAllTypes_NestedMessage{"
	for _, k := range keysForMapInt32ToMessage {
		mapStringForMapInt32ToMessage += fmt.Sprintf("%v: %v,", k, this.MapInt32ToMessage[k])
	}
	mapStringForMapInt32ToMessage += "}"
	keysForMapInt64ToMessage := make([]int64, 0, len(this.MapInt64ToMessage))
	for k, _ := range this.MapInt64ToMessage {
		keysForMapInt64ToMessage = append(keysForMapInt64ToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForMapInt64ToMessage)
	mapStringForMapInt64ToMessage := "map[int64]*TestAllTypes_NestedMessage{"
	for _, k := range keysForMapInt64ToMessage {
		mapStringForMapInt64ToMessage += fmt.Sprintf("%v: %v,", k, this.MapInt64ToMessage[k])
	}
	mapStringForMapInt64ToMessage += "}"
	keysForMapBoolToMessage := make([]bool, 0, len(this.MapBoolToMessage))
	for k, _ := range this.MapBoolToMessage {
		keysForMapBoolToMessage = append(keysForMapBoolToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForMapBoolToMessage)
	mapStringForMapBoolToMessage := "map[bool]*TestAllTypes_NestedMessage{"
	for _, k := range keysForMapBoolToMessage {
		mapStringForMapBoolToMessage += fmt.Sprintf("%v: %v,", k, this.MapBoolToMessage[k])
	}
	mapStringForMapBoolToMessage += "}"
	keysForMapStringToInt64 := make([]string, 0, len(this.MapStringToInt64))
	for k, _ := range this.MapStringToInt64 {
		keysForMapStringToInt64 = append(keysForMapStringToInt64, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMapStringToInt64)
	mapStringForMapStringToInt64 := "map[string]int64{"
	for _, k := range keysForMapStringToInt64 {
		mapStringForMapStringToInt64 += fmt.Sprintf("%v: %v,", k, this.MapStringToInt64[k])
	}
	mapStringForMapStringToInt64 += "}"
	keysForMapInt64ToString := make([]int64, 0, len(this.MapInt64ToString))
	for k, _ := range this.MapInt64ToString {
		keysForMapInt64ToString = append(keysForMapInt64ToString, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForMapInt64ToString)
	mapStringForMapInt64ToString := "map[int64]string{"
	for _, k := range keysForMapInt64ToString {
		mapStringForMapInt64ToString += fmt.Sprintf("%v: %v,", k, this.MapInt64ToString[k])
	}
	mapStringForMapInt64ToString += "}"
	keysForAnotherMapStringToMessage := make([]string, 0, len(this.AnotherMapStringToMessage))
	for k, _ := range this.AnotherMapStringToMessage {
		keysForAnotherMapStringToMessage = append(keysForAnotherMapStringToMessage, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnotherMapStringToMessage)
	mapStringForAnotherMapStringToMessage := "map[string]*TestAllTypes_NestedMessage{"
	for _, k := range keysForAnotherMapStringToMessage {
		mapStringForAnotherMapStringToMessage += fmt.Sprintf("%v: %v,", k, this.AnotherMapStringToMessage[k])
	}
	mapStringForAnotherMapStringToMessage += "}"
	s := strings.Join([]string{`&TestAllTypes{`,
		`OptionalInt64:` + fmt.Sprintf("%v", this.OptionalInt64) + `,`,
		`OptionalUint32:` + fmt.Sprintf("%v", this.OptionalUint32) + `,`,
		`OptionalSint32:` + fmt.Sprintf("%v", this.OptionalSint32) + `,`,
		`OptionalSint64:` + fmt.Sprintf("%v", this.OptionalSint64) + `,`,
		`OptionalFixed32:` + fmt.Sprintf("%v", this.OptionalFixed32) + `,`,
		`OptionalFixed64:` + fmt.Sprintf("%v", this.OptionalFixed64) + `,`,
		`OptionalSfixed32:` + fmt.Sprintf("%v", this.OptionalSfixed32) + `,`,
		`OptionalSfixed64:` + fmt.Sprintf("%v", this.OptionalSfixed64) + `,`,
		`OptionalFloat:` + fmt.Sprintf("%v", this.OptionalFloat) + `,`,
		`OptionalDouble:` + fmt.Sprintf("%v", this.OptionalDouble) + `,`,
		`OptionalBool:` + fmt.Sprintf("%v", this.OptionalBool) + `,`,
		`OptionalString:` + fmt.Sprintf("%v", this.OptionalString) + `,`,
		`OptionalBytes:` + fmt.Sprintf("%v", this.OptionalBytes) + `,`,
		`OptionalNestedMessage:` + strings.Replace(fmt.Sprintf("%v", this.OptionalNestedMessage), "TestAllTypes_NestedMessage", "TestAllTypes_NestedMessage", 1) + `,`,
		`OptionalForeignMessage:` + strings.Replace(fmt.Sprintf("%v", this.OptionalForeignMessage), "ForeignMessage", "ForeignMessage", 1) + `,`,
		`OptionalNestedEnum:` + fmt.Sprintf("%v", this.OptionalNestedEnum) + `,`,
		`OptionalForeignEnum:` + fmt.Sprintf("%v", this.OptionalForeignEnum) + `,`,
		`OptionalCord:` + fmt.Sprintf("%v", this.OptionalCord) + `,`,
		`RepeatedInt32:` + fmt.Sprintf("%v", this.RepeatedInt32) + `,`,
		`RepeatedInt64:` + fmt.Sprintf("%v", this.RepeatedInt64) + `,`,
		`RepeatedUint32:` + fmt.Sprintf("%v", this.RepeatedUint32) + `,`,
		`RepeatedUint64:` + fmt.Sprintf("%v", this.RepeatedUint64) + `,`,
		`RepeatedSint32:` + fmt.Sprintf("%v", this.RepeatedSint32) + `,`,
		`RepeatedSint64:` + fmt.Sprintf("%v", this.RepeatedSint64) + `,`,
		`RepeatedFixed32:` + fmt.Sprintf("%v", this.RepeatedFixed32) + `,`,
		`RepeatedFixed64:` + fmt.Sprintf("%v", this.RepeatedFixed64) + `,`,
		`RepeatedSfixed32:` + fmt.Sprintf("%v", this.RepeatedSfixed32) + `,`,
		`RepeatedSfixed64:` + fmt.Sprintf("%v", this.RepeatedSfixed64) + `,`,
		`RepeatedFloat:` + fmt.Sprintf("%v", this.RepeatedFloat) + `,`,
		`RepeatedDouble:` + fmt.Sprintf("%v", this.RepeatedDouble) + `,`,
		`RepeatedBool:` + fmt.Sprintf("%v", this.RepeatedBool) + `,`,
		`RepeatedString:` + fmt.Sprintf("%v", this.RepeatedString) + `,`,
		`RepeatedBytes:` + fmt.Sprintf("%v", this.RepeatedBytes) + `,`,
		`RepeatedNestedMessage:` + strings.Replace(fmt.Sprintf("%v", this.RepeatedNestedMessage), "TestAllTypes_NestedMessage", "TestAllTypes_NestedMessage", 1) + `,`,
		`RepeatedNestedEnum:` + fmt.Sprintf("%v", this.RepeatedNestedEnum) + `,`,
		`RepeatedCord:` + fmt.Sprintf("%v", this.RepeatedCord) + `,`,
		`MapStringToMessage:` + mapStringForMapStringToMessage + `,`,
		`MapInt32ToMessage:` + mapStringForMapInt32ToMessage + `,`,
		`MapInt64ToMessage:` + mapStringForMapInt64ToMessage + `,`,
		`MapBoolToMessage:` + mapStringForMapBoolToMessage + `,`,
		`MapStringToInt64:` + mapStringForMapStringToInt64 + `,`,
		`MapInt64ToString:` + mapStringForMapInt64ToString + `,`,
		`PackedRepeatedInt64:` + fmt.Sprintf("%v", this.PackedRepeatedInt64) + `,`,
		`AnotherMapStringToMessage:` + mapStringForAnotherMapStringToMessage + `,`,
		`OneofField:` + fmt.Sprintf("%v", this.OneofField) + `,`,
		`OptionalUint64:` + fmt.Sprintf("%v", this.OptionalUint64) + `,`,
		`OptionalInt32:` + fmt.Sprintf("%v", this.OptionalInt32) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestAllTypes_OneofEnum) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestAllTypes_OneofEnum{`,
		`OneofEnum:` + fmt.Sprintf("%v", this.OneofEnum) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestAllTypes_OneofUint32) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestAllTypes_OneofUint32{`,
		`OneofUint32:` + fmt.Sprintf("%v", this.OneofUint32) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestAllTypes_OneofNestedMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestAllTypes_OneofNestedMessage{`,
		`OneofNestedMessage:` + strings.Replace(fmt.Sprintf("%v", this.OneofNestedMessage), "TestAllTypes_NestedMessage", "TestAllTypes_NestedMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestAllTypes_OneofString) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestAllTypes_OneofString{`,
		`OneofString:` + fmt.Sprintf("%v", this.OneofString) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestAllTypes_OneofBytes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestAllTypes_OneofBytes{`,
		`OneofBytes:` + fmt.Sprintf("%v", this.OneofBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestAllTypes_NestedMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestAllTypes_NestedMessage{`,
		`OptionalInt32:` + fmt.Sprintf("%v", this.OptionalInt32) + `,`,
		`RepeatedInt32:` + fmt.Sprintf("%v", this.RepeatedInt32) + `,`,
		`Msg:` + strings.Replace(fmt.Sprintf("%v", this.Msg), "TestAllTypes_NestedMessage_DoubleNestedMessage", "TestAllTypes_NestedMessage_DoubleNestedMessage", 1) + `,`,
		`OptionalInt64:` + fmt.Sprintf("%v", this.OptionalInt64) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestAllTypes_NestedMessage_DoubleNestedMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestAllTypes_NestedMessage_DoubleNestedMessage{`,
		`OptionalString:` + fmt.Sprintf("%v", this.OptionalString) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NestedTestAllTypes) String() string {
	if this == nil {
		return "nil"
	}
	keysForMapStringToInt64 := make([]string, 0, len(this.MapStringToInt64))
	for k, _ := range this.MapStringToInt64 {
		keysForMapStringToInt64 = append(keysForMapStringToInt64, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMapStringToInt64)
	mapStringForMapStringToInt64 := "map[string]int64{"
	for _, k := range keysForMapStringToInt64 {
		mapStringForMapStringToInt64 += fmt.Sprintf("%v: %v,", k, this.MapStringToInt64[k])
	}
	mapStringForMapStringToInt64 += "}"
	s := strings.Join([]string{`&NestedTestAllTypes{`,
		`Child:` + strings.Replace(fmt.Sprintf("%v", this.Child), "NestedTestAllTypes", "NestedTestAllTypes", 1) + `,`,
		`Payload:` + strings.Replace(fmt.Sprintf("%v", this.Payload), "TestAllTypes", "TestAllTypes", 1) + `,`,
		`MapStringToInt64:` + mapStringForMapStringToInt64 + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForeignMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForeignMessage{`,
		`C:` + fmt.Sprintf("%v", this.C) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TestEmptyMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TestEmptyMessage{`,
		`}`,
	}, "")
	return s
}
func valueToStringTest(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TestAllTypes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestAllTypes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestAllTypes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64", wireType)
			}
			m.OptionalInt64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt64 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint32", wireType)
			}
			m.OptionalUint32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint32 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.OptionalSint32 = v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.OptionalSint64 = int64(v)
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed32", wireType)
			}
			m.OptionalFixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.OptionalFixed32 = uint32(dAtA[iNdEx-4])
			m.OptionalFixed32 |= uint32(dAtA[iNdEx-3]) << 8
			m.OptionalFixed32 |= uint32(dAtA[iNdEx-2]) << 16
			m.OptionalFixed32 |= uint32(dAtA[iNdEx-1]) << 24
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFixed64", wireType)
			}
			m.OptionalFixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.OptionalFixed64 = uint64(dAtA[iNdEx-8])
			m.OptionalFixed64 |= uint64(dAtA[iNdEx-7]) << 8
			m.OptionalFixed64 |= uint64(dAtA[iNdEx-6]) << 16
			m.OptionalFixed64 |= uint64(dAtA[iNdEx-5]) << 24
			m.OptionalFixed64 |= uint64(dAtA[iNdEx-4]) << 32
			m.OptionalFixed64 |= uint64(dAtA[iNdEx-3]) << 40
			m.OptionalFixed64 |= uint64(dAtA[iNdEx-2]) << 48
			m.OptionalFixed64 |= uint64(dAtA[iNdEx-1]) << 56
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed32", wireType)
			}
			m.OptionalSfixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			m.OptionalSfixed32 = int32(dAtA[iNdEx-4])
			m.OptionalSfixed32 |= int32(dAtA[iNdEx-3]) << 8
			m.OptionalSfixed32 |= int32(dAtA[iNdEx-2]) << 16
			m.OptionalSfixed32 |= int32(dAtA[iNdEx-1]) << 24
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalSfixed64", wireType)
			}
			m.OptionalSfixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.OptionalSfixed64 = int64(dAtA[iNdEx-8])
			m.OptionalSfixed64 |= int64(dAtA[iNdEx-7]) << 8
			m.OptionalSfixed64 |= int64(dAtA[iNdEx-6]) << 16
			m.OptionalSfixed64 |= int64(dAtA[iNdEx-5]) << 24
			m.OptionalSfixed64 |= int64(dAtA[iNdEx-4]) << 32
			m.OptionalSfixed64 |= int64(dAtA[iNdEx-3]) << 40
			m.OptionalSfixed64 |= int64(dAtA[iNdEx-2]) << 48
			m.OptionalSfixed64 |= int64(dAtA[iNdEx-1]) << 56
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalFloat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.OptionalFloat = float32(math.Float32frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalDouble", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.OptionalDouble = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptionalBool = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalBytes = append(m.OptionalBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.OptionalBytes == nil {
				m.OptionalBytes = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalNestedMessage == nil {
				m.OptionalNestedMessage = &TestAllTypes_NestedMessage{}
			}
			if err := m.OptionalNestedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalForeignMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptionalForeignMessage == nil {
				m.OptionalForeignMessage = &ForeignMessage{}
			}
			if err := m.OptionalForeignMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalNestedEnum", wireType)
			}
			m.OptionalNestedEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalNestedEnum |= (TestAllTypes_NestedEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalForeignEnum", wireType)
			}
			m.OptionalForeignEnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalForeignEnum |= (ForeignEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalCord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalCord = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt32 = append(m.RepeatedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt32 = append(m.RepeatedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32", wireType)
			}
		case 32:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt64 = append(m.RepeatedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt64 = append(m.RepeatedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt64", wireType)
			}
		case 33:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint32 = append(m.RepeatedUint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint32 = append(m.RepeatedUint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint32", wireType)
			}
		case 34:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedUint64 = append(m.RepeatedUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedUint64 = append(m.RepeatedUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedUint64", wireType)
			}
		case 35:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.RepeatedSint32 = append(m.RepeatedSint32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.RepeatedSint32 = append(m.RepeatedSint32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint32", wireType)
			}
		case 36:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.RepeatedSint64 = append(m.RepeatedSint64, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSint64", wireType)
			}
		case 37:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					m.RepeatedFixed32 = append(m.RepeatedFixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed32", wireType)
			}
		case 38:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					m.RepeatedFixed64 = append(m.RepeatedFixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFixed64", wireType)
			}
		case 39:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = int32(dAtA[iNdEx-4])
				v |= int32(dAtA[iNdEx-3]) << 8
				v |= int32(dAtA[iNdEx-2]) << 16
				v |= int32(dAtA[iNdEx-1]) << 24
				m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = int32(dAtA[iNdEx-4])
					v |= int32(dAtA[iNdEx-3]) << 8
					v |= int32(dAtA[iNdEx-2]) << 16
					v |= int32(dAtA[iNdEx-1]) << 24
					m.RepeatedSfixed32 = append(m.RepeatedSfixed32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed32", wireType)
			}
		case 40:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = int64(dAtA[iNdEx-8])
				v |= int64(dAtA[iNdEx-7]) << 8
				v |= int64(dAtA[iNdEx-6]) << 16
				v |= int64(dAtA[iNdEx-5]) << 24
				v |= int64(dAtA[iNdEx-4]) << 32
				v |= int64(dAtA[iNdEx-3]) << 40
				v |= int64(dAtA[iNdEx-2]) << 48
				v |= int64(dAtA[iNdEx-1]) << 56
				m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = int64(dAtA[iNdEx-8])
					v |= int64(dAtA[iNdEx-7]) << 8
					v |= int64(dAtA[iNdEx-6]) << 16
					v |= int64(dAtA[iNdEx-5]) << 24
					v |= int64(dAtA[iNdEx-4]) << 32
					v |= int64(dAtA[iNdEx-3]) << 40
					v |= int64(dAtA[iNdEx-2]) << 48
					v |= int64(dAtA[iNdEx-1]) << 56
					m.RepeatedSfixed64 = append(m.RepeatedSfixed64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedSfixed64", wireType)
			}
		case 41:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.RepeatedFloat = append(m.RepeatedFloat, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.RepeatedFloat = append(m.RepeatedFloat, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedFloat", wireType)
			}
		case 42:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.RepeatedDouble = append(m.RepeatedDouble, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.RepeatedDouble = append(m.RepeatedDouble, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedDouble", wireType)
			}
		case 43:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedBool = append(m.RepeatedBool, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBool", wireType)
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedString = append(m.RepeatedString, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedBytes = append(m.RepeatedBytes, make([]byte, postIndex-iNdEx))
			copy(m.RepeatedBytes[len(m.RepeatedBytes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedNestedMessage = append(m.RepeatedNestedMessage, &TestAllTypes_NestedMessage{})
			if err := m.RepeatedNestedMessage[len(m.RepeatedNestedMessage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType == 0 {
				var v TestAllTypes_NestedEnum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (TestAllTypes_NestedEnum(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v TestAllTypes_NestedEnum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (TestAllTypes_NestedEnum(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedNestedEnum = append(m.RepeatedNestedEnum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedNestedEnum", wireType)
			}
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedCord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepeatedCord = append(m.RepeatedCord, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 58:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringToMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringToMessage == nil {
				m.MapStringToMessage = make(map[string]*TestAllTypes_NestedMessage)
			}
			var mapkey string
			var mapvalue *TestAllTypes_NestedMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TestAllTypes_NestedMessage{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringToMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 59:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt32ToMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt32ToMessage == nil {
				m.MapInt32ToMessage = make(map[int32]*TestAllTypes_NestedMessage)
			}
			var mapkey int32
			var mapvalue *TestAllTypes_NestedMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TestAllTypes_NestedMessage{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt32ToMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64ToMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt64ToMessage == nil {
				m.MapInt64ToMessage = make(map[int64]*TestAllTypes_NestedMessage)
			}
			var mapkey int64
			var mapvalue *TestAllTypes_NestedMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TestAllTypes_NestedMessage{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt64ToMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBoolToMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBoolToMessage == nil {
				m.MapBoolToMessage = make(map[bool]*TestAllTypes_NestedMessage)
			}
			var mapkey bool
			var mapvalue *TestAllTypes_NestedMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkey = bool(mapkeytemp != 0)
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TestAllTypes_NestedMessage{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBoolToMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringToInt64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringToInt64 == nil {
				m.MapStringToInt64 = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringToInt64[mapkey] = mapvalue
			iNdEx = postIndex
		case 63:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInt64ToString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInt64ToString == nil {
				m.MapInt64ToString = make(map[int64]string)
			}
			var mapkey int64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapInt64ToString[mapkey] = mapvalue
			iNdEx = postIndex
		case 64:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PackedRepeatedInt64 = append(m.PackedRepeatedInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PackedRepeatedInt64 = append(m.PackedRepeatedInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PackedRepeatedInt64", wireType)
			}
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnotherMapStringToMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnotherMapStringToMessage == nil {
				m.AnotherMapStringToMessage = make(map[string]*TestAllTypes_NestedMessage)
			}
			var mapkey string
			var mapvalue *TestAllTypes_NestedMessage
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TestAllTypes_NestedMessage{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AnotherMapStringToMessage[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofEnum", wireType)
			}
			var v TestAllTypes_NestedEnum
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TestAllTypes_NestedEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypes_OneofEnum{v}
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofUint32", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofField = &TestAllTypes_OneofUint32{v}
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofNestedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestAllTypes_NestedMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OneofField = &TestAllTypes_OneofNestedMessage{v}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneofField = &TestAllTypes_OneofString{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.OneofField = &TestAllTypes_OneofBytes{v}
			iNdEx = postIndex
		case 999:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalUint64", wireType)
			}
			m.OptionalUint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalUint64 |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1000:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32", wireType)
			}
			m.OptionalInt32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt32 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypes_NestedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt32", wireType)
			}
			m.OptionalInt32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt32 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RepeatedInt32 = append(m.RepeatedInt32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTest
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RepeatedInt32 = append(m.RepeatedInt32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RepeatedInt32", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &TestAllTypes_NestedMessage_DoubleNestedMessage{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalInt64", wireType)
			}
			m.OptionalInt64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptionalInt64 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestAllTypes_NestedMessage_DoubleNestedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleNestedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleNestedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionalString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptionalString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NestedTestAllTypes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedTestAllTypes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedTestAllTypes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &NestedTestAllTypes{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &TestAllTypes{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapStringToInt64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTest
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapStringToInt64 == nil {
				m.MapStringToInt64 = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapStringToInt64[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			m.C = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.C |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestEmptyMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestEmptyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestEmptyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTest
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTest
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTest(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTest = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTest   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("protobuf/tensorflow/tools/proto_text/test.proto", fileDescriptorTest) }

var fileDescriptorTest = []byte{
	// 1395 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4d, 0x73, 0x13, 0x37,
	0x18, 0xb6, 0xac, 0x38, 0x1f, 0xb2, 0x93, 0x2c, 0x4a, 0x02, 0x4b, 0xa6, 0x2c, 0x22, 0x14, 0x58,
	0x3e, 0x9a, 0x74, 0xec, 0xed, 0x52, 0x28, 0x85, 0x26, 0x34, 0x21, 0x39, 0x40, 0xda, 0x85, 0x1e,
	0x9a, 0x8b, 0xc7, 0x89, 0x37, 0x89, 0x87, 0xf5, 0xca, 0xd8, 0x9b, 0x16, 0x5f, 0x3a, 0xfd, 0x09,
	0xbd, 0xf5, 0x2f, 0xf4, 0x1f, 0xf4, 0x2f, 0x74, 0xa6, 0x17, 0x8e, 0x3d, 0x16, 0xf7, 0x50, 0x8e,
	0xfc, 0x83, 0x76, 0x24, 0xad, 0xb4, 0xab, 0xf5, 0x26, 0xc4, 0x33, 0x90, 0x93, 0xfd, 0xf8, 0xd1,
	0xfb, 0xbc, 0x7a, 0xa5, 0xe7, 0x95, 0x14, 0xb4, 0xd2, 0xe9, 0xd2, 0x88, 0xee, 0x1e, 0xed, 0xaf,
	0x44, 0x7e, 0xd8, 0xa3, 0xdd, 0xfd, 0x80, 0xfe, 0xb8, 0x12, 0x51, 0x1a, 0xf4, 0xc4, 0x2f, 0xf5,
	0xc8, 0x7f, 0x19, 0xad, 0x44, 0x7e, 0x2f, 0x5a, 0xe6, 0xdf, 0xf1, 0x6c, 0xc2, 0x5b, 0x66, 0xf0,
	0xd2, 0x9f, 0x17, 0x51, 0xe5, 0x99, 0xdf, 0x8b, 0x56, 0x83, 0xe0, 0x59, 0xbf, 0xe3, 0xf7, 0xf0,
	0x15, 0x34, 0x43, 0x3b, 0x51, 0x8b, 0x86, 0x8d, 0xa0, 0xde, 0x0a, 0x23, 0xd7, 0x31, 0x8b, 0x04,
	0xd8, 0xd0, 0x9b, 0x96, 0xe8, 0x16, 0x03, 0xf1, 0x35, 0x34, 0xab, 0x68, 0x47, 0xad, 0x30, 0xaa,
	0x55, 0x4d, 0x48, 0x80, 0x3d, 0xed, 0xa9, 0xd1, 0xdf, 0x71, 0x54, 0x23, 0xf6, 0x04, 0xb1, 0x44,
	0x80, 0x7d, 0x26, 0x21, 0x3e, 0xcd, 0x27, 0xba, 0x8e, 0x39, 0x4e, 0x80, 0x8d, 0x75, 0xa2, 0xeb,
	0xe0, 0xeb, 0xc8, 0x50, 0xc4, 0xfd, 0xd6, 0x4b, 0xbf, 0x59, 0xab, 0x9a, 0x13, 0x04, 0xd8, 0x13,
	0x9e, 0x0a, 0xb0, 0x21, 0xe0, 0x61, 0xaa, 0xeb, 0x98, 0x93, 0x04, 0xd8, 0xe3, 0x19, 0xaa, 0xeb,
	0xe0, 0x9b, 0xe8, 0x4c, 0x22, 0x2f, 0xc3, 0x4e, 0x11, 0x60, 0xcf, 0x7a, 0x2a, 0xc6, 0xd3, 0x18,
	0xcf, 0x21, 0xbb, 0x8e, 0x89, 0x08, 0xb0, 0x8d, 0x2c, 0xd9, 0x75, 0xb4, 0x8a, 0xee, 0x07, 0xb4,
	0x11, 0x99, 0x65, 0x02, 0xec, 0x62, 0x52, 0xd1, 0x0d, 0x06, 0x6a, 0xf3, 0x6f, 0xd2, 0xa3, 0xdd,
	0xc0, 0x37, 0x2b, 0x04, 0xd8, 0x20, 0x99, 0xff, 0xd7, 0x1c, 0xc5, 0x97, 0x91, 0x1a, 0x59, 0xdf,
	0xa5, 0x34, 0x30, 0xa7, 0x09, 0xb0, 0x27, 0xbd, 0x8a, 0x04, 0xd7, 0x28, 0x0d, 0xf4, 0x6a, 0x46,
	0xdd, 0x56, 0x78, 0x60, 0xce, 0x10, 0x60, 0x4f, 0xa5, 0xaa, 0xc9, 0x51, 0x2d, 0xbb, 0xdd, 0x7e,
	0xe4, 0xf7, 0xcc, 0x59, 0x02, 0xec, 0x4a, 0x92, 0xdd, 0x1a, 0x03, 0xf1, 0x1e, 0x3a, 0xa7, 0x68,
	0xa1, 0xdf, 0x8b, 0xfc, 0x66, 0xbd, 0xed, 0xf7, 0x7a, 0x8d, 0x03, 0xdf, 0xc4, 0x04, 0xd8, 0xe5,
	0xea, 0xcd, 0xe5, 0xcc, 0xd6, 0x5a, 0x4e, 0x6f, 0xab, 0xe5, 0x27, 0x7c, 0xcc, 0x63, 0x31, 0xc4,
	0x5b, 0x90, 0xb1, 0x34, 0x18, 0x7f, 0x8f, 0xcc, 0xa4, 0x52, 0xb4, 0xeb, 0xb7, 0x0e, 0x42, 0xa5,
	0x32, 0xc7, 0x55, 0x2e, 0x0e, 0xa9, 0x6c, 0x08, 0x9e, 0x8c, 0x7c, 0x56, 0x15, 0x55, 0xc3, 0xf1,
	0x0e, 0x9a, 0xcf, 0xe6, 0xef, 0x87, 0x47, 0x6d, 0x73, 0x81, 0x00, 0x7b, 0xa6, 0x6a, 0x9f, 0x26,
	0xf9, 0xf5, 0xf0, 0xa8, 0xed, 0x61, 0x3d, 0x73, 0x86, 0xe1, 0x6f, 0xd0, 0xc2, 0x50, 0xda, 0x3c,
	0xf8, 0x59, 0x1e, 0xfc, 0xa3, 0xe3, 0x72, 0xe6, 0x01, 0xe7, 0x32, 0x09, 0xf3, 0x88, 0xe9, 0x25,
	0xde, 0xa3, 0xdd, 0xa6, 0x79, 0x9e, 0xaf, 0x9d, 0x5a, 0xe2, 0x87, 0xb4, 0xdb, 0x64, 0x2b, 0xd7,
	0xf5, 0x3b, 0x7e, 0x83, 0xcd, 0x45, 0x18, 0xeb, 0x22, 0x81, 0x76, 0xc9, 0x9b, 0x96, 0xe8, 0x16,
	0xf7, 0x55, 0x86, 0xe6, 0x3a, 0x26, 0x21, 0x90, 0x19, 0x3a, 0x45, 0x13, 0x86, 0x56, 0xb4, 0xd8,
	0xd0, 0x97, 0x08, 0x64, 0x86, 0x96, 0x70, 0x62, 0x68, 0x8d, 0xe8, 0x3a, 0xe6, 0x12, 0x81, 0xf6,
	0x98, 0x4e, 0xcc, 0x44, 0x8c, 0x9d, 0x7f, 0x99, 0x40, 0xe6, 0x7c, 0x09, 0x3f, 0x1d, 0x8e, 0x18,
	0x3b, 0xff, 0x63, 0x02, 0x99, 0xf3, 0xd3, 0x44, 0xe1, 0x7c, 0x45, 0x94, 0x16, 0xbd, 0x42, 0x20,
	0x73, 0xbe, 0xc4, 0x53, 0xce, 0xd7, 0xa9, 0xae, 0x63, 0x5e, 0x25, 0x90, 0x39, 0x5f, 0xa3, 0x0a,
	0xe7, 0x27, 0xf2, 0x32, 0xec, 0x35, 0x02, 0x99, 0xf3, 0x55, 0x02, 0x29, 0xe7, 0x67, 0xc8, 0xae,
	0x63, 0xda, 0x04, 0x32, 0xe7, 0xeb, 0x64, 0xe1, 0xfc, 0x24, 0x09, 0xee, 0xfc, 0xeb, 0x04, 0x32,
	0xe7, 0xab, 0x14, 0xa4, 0xf3, 0x15, 0x2d, 0x76, 0xfe, 0x0d, 0x02, 0x99, 0xf3, 0x25, 0x9c, 0x38,
	0x5f, 0x11, 0xb9, 0xf3, 0x6f, 0x12, 0xc8, 0x9c, 0x2f, 0x41, 0xe9, 0xfc, 0x24, 0x43, 0xe1, 0xfc,
	0x5b, 0x04, 0x32, 0xe7, 0xab, 0xfc, 0x94, 0xf3, 0x93, 0x68, 0xdc, 0xf9, 0x9f, 0x10, 0xc8, 0x9c,
	0xaf, 0xc2, 0x49, 0xe7, 0x2b, 0x5a, 0xc6, 0xf9, 0x9f, 0x12, 0x38, 0xb2, 0xf3, 0x65, 0x2c, 0xdd,
	0xf9, 0x3b, 0x68, 0x3e, 0x2b, 0xc2, 0x1d, 0x54, 0x23, 0x70, 0x34, 0x7b, 0xea, 0xe1, 0xa5, 0x99,
	0x54, 0x6c, 0x6e, 0xa6, 0xdb, 0xbc, 0x1c, 0xaa, 0x6a, 0xdc, 0x4c, 0x87, 0x68, 0xa1, 0xdd, 0xe8,
	0xc4, 0x05, 0xab, 0x47, 0x54, 0xcd, 0xf1, 0x2e, 0x9f, 0xe3, 0x67, 0x27, 0x67, 0xf0, 0xb8, 0xd1,
	0x11, 0x45, 0x7d, 0x46, 0xe3, 0x19, 0xad, 0x87, 0x51, 0xb7, 0xef, 0xe1, 0xf6, 0xd0, 0x0f, 0xd8,
	0x47, 0xf3, 0x4c, 0x89, 0x6f, 0xfd, 0xb4, 0xd0, 0x17, 0x5c, 0xc8, 0x79, 0xa7, 0x10, 0x77, 0x75,
	0x46, 0xe7, 0x4c, 0x3b, 0x8b, 0xa7, 0x64, 0x5c, 0x27, 0x2d, 0x73, 0xef, 0xf4, 0x32, 0xae, 0x93,
	0x2f, 0x93, 0xc2, 0xf1, 0x2e, 0x9a, 0x63, 0x32, 0x6c, 0x37, 0xa6, 0x55, 0xbe, 0xe4, 0x2a, 0xb5,
	0x77, 0xaa, 0xb0, 0x1d, 0x9b, 0x11, 0x31, 0xda, 0x19, 0x58, 0x6a, 0x24, 0x6b, 0x23, 0x7a, 0xc4,
	0xfd, 0x53, 0x6a, 0xc8, 0x05, 0xe0, 0x99, 0x27, 0x1a, 0x1a, 0x2c, 0x35, 0x54, 0xb9, 0x62, 0xe7,
	0x3c, 0x38, 0xa5, 0x46, 0x5c, 0x15, 0x11, 0x33, 0xd1, 0xd0, 0x60, 0xec, 0xa2, 0x85, 0x4e, 0x63,
	0xef, 0xb9, 0xdf, 0xac, 0x67, 0x1a, 0xf2, 0x57, 0xac, 0x21, 0xaf, 0x15, 0x0d, 0xe0, 0xcd, 0x09,
	0x82, 0xa7, 0xb5, 0xe6, 0x9f, 0xd0, 0x85, 0x46, 0x48, 0xa3, 0x43, 0xbf, 0x5b, 0xcf, 0xdf, 0xa3,
	0xab, 0x3c, 0xcb, 0x7b, 0x27, 0x67, 0xb9, 0x2a, 0x42, 0x1c, 0xb7, 0x55, 0xcf, 0x37, 0x8e, 0xfb,
	0x1d, 0x6f, 0x21, 0x44, 0x43, 0x9f, 0xee, 0x0b, 0x4b, 0x36, 0x47, 0x3b, 0x31, 0x37, 0x0b, 0xde,
	0x14, 0x1f, 0x1d, 0x7b, 0xb1, 0x22, 0x42, 0xc5, 0x47, 0x0c, 0x65, 0x77, 0xc6, 0xcd, 0x82, 0x57,
	0xe6, 0x68, 0x7c, 0xc2, 0xd4, 0xd1, 0xbc, 0x20, 0x65, 0xda, 0x4d, 0x67, 0xe4, 0x8b, 0xc6, 0x66,
	0xc1, 0xc3, 0x3c, 0x94, 0xde, 0x6d, 0x54, 0x16, 0xf1, 0x2a, 0xbf, 0x60, 0xa7, 0xab, 0xca, 0x22,
	0x5e, 0xad, 0x4b, 0x48, 0x7c, 0x8d, 0x7b, 0x63, 0x97, 0xdd, 0x8a, 0x36, 0x0b, 0x9e, 0x28, 0x85,
	0x68, 0x8d, 0x76, 0xe6, 0x12, 0xec, 0x3a, 0xe6, 0xbf, 0xec, 0x26, 0x3a, 0xa6, 0xdf, 0x82, 0x5d,
	0x07, 0x5f, 0xd5, 0x6f, 0xd5, 0xb5, 0xaa, 0xf9, 0x86, 0x11, 0x4b, 0xda, 0xb5, 0xba, 0x56, 0x5d,
	0xfc, 0xb5, 0x88, 0xa6, 0xf5, 0x5c, 0xaf, 0x0c, 0x8d, 0x04, 0x39, 0x03, 0x73, 0x2e, 0x03, 0xc5,
	0xbc, 0xcb, 0xc0, 0xb7, 0x08, 0xb6, 0x7b, 0x07, 0xfc, 0xaa, 0x5e, 0xae, 0x3e, 0x18, 0xa1, 0x92,
	0xcb, 0xe2, 0x08, 0xd2, 0x9b, 0x39, 0x8b, 0x95, 0xf3, 0x60, 0x18, 0xcb, 0x79, 0x30, 0x2c, 0xde,
	0x47, 0x73, 0x39, 0x21, 0xf2, 0xee, 0xa9, 0x20, 0xef, 0x9e, 0xba, 0xd8, 0x45, 0xe7, 0x8e, 0xd9,
	0xba, 0xd8, 0x40, 0xf0, 0xb9, 0xdf, 0x8f, 0xc7, 0xb1, 0x8f, 0x78, 0x15, 0x95, 0x7e, 0x68, 0x04,
	0x47, 0x3e, 0x7f, 0xbb, 0x8c, 0x78, 0x42, 0x89, 0x91, 0x77, 0x8b, 0x9f, 0x83, 0xc5, 0x17, 0xe8,
	0x6c, 0x7e, 0xc3, 0x4d, 0x4b, 0x96, 0x3e, 0x8c, 0x64, 0xb6, 0xf9, 0xa6, 0x25, 0xe1, 0x7b, 0x95,
	0xec, 0xa0, 0x85, 0xdc, 0x4e, 0x9c, 0x56, 0x9c, 0x7c, 0xaf, 0x8a, 0x0f, 0xb9, 0xe2, 0x70, 0x5f,
	0xce, 0x59, 0xc9, 0xf9, 0xb4, 0x22, 0x1c, 0x0e, 0x32, 0xdc, 0x78, 0x73, 0x0a, 0xa5, 0x05, 0x99,
	0x4a, 0x07, 0xe9, 0x23, 0xeb, 0xe4, 0xbe, 0xf8, 0xc1, 0x36, 0xd7, 0xd2, 0x43, 0x84, 0x52, 0x97,
	0x94, 0x49, 0x34, 0xb6, 0xb3, 0xee, 0x6d, 0x1b, 0x05, 0x3c, 0x81, 0xe0, 0xc6, 0xf6, 0xb6, 0x01,
	0xd8, 0x87, 0xb5, 0x55, 0xcf, 0x28, 0x8a, 0x0f, 0x3b, 0x06, 0x64, 0xb9, 0x3c, 0x59, 0x7f, 0x64,
	0xfc, 0x27, 0xff, 0xc0, 0xda, 0xb4, 0x6c, 0x52, 0xfb, 0x2d, 0x3f, 0x68, 0x2e, 0xfd, 0x5e, 0x44,
	0x58, 0x04, 0xd5, 0xde, 0xf4, 0x77, 0x50, 0x69, 0xef, 0xb0, 0x15, 0x34, 0xf9, 0x2c, 0xca, 0xd5,
	0xcb, 0x43, 0x19, 0x0f, 0x8f, 0xf1, 0xc4, 0x08, 0x7c, 0x1b, 0x4d, 0x74, 0x1a, 0xfd, 0x80, 0x36,
	0x9a, 0xf1, 0x74, 0x2f, 0x9c, 0x38, 0x5d, 0x4f, 0xb2, 0xf1, 0x61, 0xfe, 0xa1, 0x0d, 0xf9, 0x51,
	0x75, 0xe7, 0x14, 0x19, 0x9c, 0xf6, 0xe8, 0x7e, 0x2f, 0xbb, 0x69, 0xc9, 0x42, 0x33, 0x99, 0x17,
	0x63, 0x05, 0x81, 0xbd, 0xd8, 0xe0, 0x60, 0x6f, 0x09, 0x23, 0x83, 0x25, 0xb7, 0xde, 0xee, 0x44,
	0xfd, 0x98, 0x71, 0xc3, 0x43, 0xe5, 0xf4, 0xa3, 0xcd, 0x40, 0x95, 0x8d, 0x6d, 0x6f, 0x7d, 0xeb,
	0xd1, 0x93, 0x7a, 0xbc, 0x94, 0xb3, 0xa8, 0x2c, 0x11, 0xb6, 0xa4, 0x63, 0x69, 0x80, 0x2d, 0x6d,
	0x49, 0x07, 0x76, 0x8c, 0xf1, 0xb5, 0x5b, 0xaf, 0x5e, 0x5b, 0x85, 0xbf, 0x5e, 0x5b, 0x85, 0xb7,
	0xaf, 0x2d, 0xf0, 0xf3, 0xc0, 0x02, 0xbf, 0x0d, 0x2c, 0xf0, 0xc7, 0xc0, 0x02, 0xaf, 0x06, 0x16,
	0xf8, 0x7b, 0x60, 0x81, 0x37, 0x03, 0xab, 0xf0, 0x76, 0x60, 0x81, 0x5f, 0xfe, 0xb1, 0x0a, 0xbb,
	0xe3, 0xfc, 0xbf, 0x3a, 0xb5, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x40, 0x7a, 0x89, 0xf3, 0x08,
	0x12, 0x00, 0x00,
}
