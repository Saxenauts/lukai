// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/compiler/xla/service/hlo.proto

/*
	Package xla is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/compiler/xla/service/hlo.proto

	It has these top-level messages:
		HloInstructionProto
		HloComputationProto
		HloModuleProto
		HloOrderingProto
		LogicalBufferProto
		BufferAllocationProto
		HeapSimulatorTrace
		BufferAssignmentProto
		HloProto
*/
package xla

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import xla1 "github.com/d4l3k/pok/protobuf/tensorflow/compiler/xla"

import strconv "strconv"

import fmt "fmt"
import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type HeapSimulatorTrace_Event_Kind int32

const (
	ALLOC HeapSimulatorTrace_Event_Kind = 0
	FREE  HeapSimulatorTrace_Event_Kind = 1
	// A buffer was shared with another (canonical) buffer. This is similar to
	// ALLOC, except that instead of allocating a new region of memory, the
	// memory region of the canonical buffer is directly re-used. Multiple
	// buffers may share with the same canonical buffer. The lifetime of the
	// canonical buffer is extended to the union of all lifetimes.
	SHARE_WITH HeapSimulatorTrace_Event_Kind = 2
)

var HeapSimulatorTrace_Event_Kind_name = map[int32]string{
	0: "ALLOC",
	1: "FREE",
	2: "SHARE_WITH",
}
var HeapSimulatorTrace_Event_Kind_value = map[string]int32{
	"ALLOC":      0,
	"FREE":       1,
	"SHARE_WITH": 2,
}

func (HeapSimulatorTrace_Event_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHlo, []int{6, 0, 0}
}

// Serialization of HloInstruction.
type HloInstructionProto struct {
	Name                    string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Opcode                  string           `protobuf:"bytes,2,opt,name=opcode,proto3" json:"opcode,omitempty"`
	Shape                   *xla1.Shape      `protobuf:"bytes,3,opt,name=shape" json:"shape,omitempty"`
	OperandNames            []string         `protobuf:"bytes,4,rep,name=operand_names,json=operandNames" json:"operand_names,omitempty"`
	ControlPredecessorNames []string         `protobuf:"bytes,5,rep,name=control_predecessor_names,json=controlPredecessorNames" json:"control_predecessor_names,omitempty"`
	CalledComputationNames  []string         `protobuf:"bytes,6,rep,name=called_computation_names,json=calledComputationNames" json:"called_computation_names,omitempty"`
	Metadata                *xla1.OpMetadata `protobuf:"bytes,7,opt,name=metadata" json:"metadata,omitempty"`
	// Literal, only present for kConstant.
	Literal *xla1.LiteralProto `protobuf:"bytes,8,opt,name=literal" json:"literal,omitempty"`
	// Parameter info, only present for kParameter.
	ParameterNumber int64  `protobuf:"varint,9,opt,name=parameter_number,json=parameterNumber,proto3" json:"parameter_number,omitempty"`
	ParameterName   string `protobuf:"bytes,10,opt,name=parameter_name,json=parameterName,proto3" json:"parameter_name,omitempty"`
	// Fusion state, only present for kFusion.
	FusionKind                   string               `protobuf:"bytes,11,opt,name=fusion_kind,json=fusionKind,proto3" json:"fusion_kind,omitempty"`
	FusedInstructionsComputation *HloComputationProto `protobuf:"bytes,12,opt,name=fused_instructions_computation,json=fusedInstructionsComputation" json:"fused_instructions_computation,omitempty"`
	// Index for kGetTupleElement.
	TupleIndex int64 `protobuf:"varint,13,opt,name=tuple_index,json=tupleIndex,proto3" json:"tuple_index,omitempty"`
}

func (m *HloInstructionProto) Reset()                    { *m = HloInstructionProto{} }
func (*HloInstructionProto) ProtoMessage()               {}
func (*HloInstructionProto) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{0} }

func (m *HloInstructionProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HloInstructionProto) GetOpcode() string {
	if m != nil {
		return m.Opcode
	}
	return ""
}

func (m *HloInstructionProto) GetShape() *xla1.Shape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *HloInstructionProto) GetOperandNames() []string {
	if m != nil {
		return m.OperandNames
	}
	return nil
}

func (m *HloInstructionProto) GetControlPredecessorNames() []string {
	if m != nil {
		return m.ControlPredecessorNames
	}
	return nil
}

func (m *HloInstructionProto) GetCalledComputationNames() []string {
	if m != nil {
		return m.CalledComputationNames
	}
	return nil
}

func (m *HloInstructionProto) GetMetadata() *xla1.OpMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *HloInstructionProto) GetLiteral() *xla1.LiteralProto {
	if m != nil {
		return m.Literal
	}
	return nil
}

func (m *HloInstructionProto) GetParameterNumber() int64 {
	if m != nil {
		return m.ParameterNumber
	}
	return 0
}

func (m *HloInstructionProto) GetParameterName() string {
	if m != nil {
		return m.ParameterName
	}
	return ""
}

func (m *HloInstructionProto) GetFusionKind() string {
	if m != nil {
		return m.FusionKind
	}
	return ""
}

func (m *HloInstructionProto) GetFusedInstructionsComputation() *HloComputationProto {
	if m != nil {
		return m.FusedInstructionsComputation
	}
	return nil
}

func (m *HloInstructionProto) GetTupleIndex() int64 {
	if m != nil {
		return m.TupleIndex
	}
	return 0
}

// Serialization of HloComputation.
type HloComputationProto struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The array of instructions is always in a valid dependency order, where
	// operands appear before their users.
	Instructions []*HloInstructionProto `protobuf:"bytes,2,rep,name=instructions" json:"instructions,omitempty"`
}

func (m *HloComputationProto) Reset()                    { *m = HloComputationProto{} }
func (*HloComputationProto) ProtoMessage()               {}
func (*HloComputationProto) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{1} }

func (m *HloComputationProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HloComputationProto) GetInstructions() []*HloInstructionProto {
	if m != nil {
		return m.Instructions
	}
	return nil
}

// Serialization of HloModule.
type HloModuleProto struct {
	Name                 string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	EntryComputationName string `protobuf:"bytes,2,opt,name=entry_computation_name,json=entryComputationName,proto3" json:"entry_computation_name,omitempty"`
	// The array of computations is always in a valid dependency order, where
	// callees appear before their callers.
	Computations []*HloComputationProto `protobuf:"bytes,3,rep,name=computations" json:"computations,omitempty"`
}

func (m *HloModuleProto) Reset()                    { *m = HloModuleProto{} }
func (*HloModuleProto) ProtoMessage()               {}
func (*HloModuleProto) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{2} }

func (m *HloModuleProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HloModuleProto) GetEntryComputationName() string {
	if m != nil {
		return m.EntryComputationName
	}
	return ""
}

func (m *HloModuleProto) GetComputations() []*HloComputationProto {
	if m != nil {
		return m.Computations
	}
	return nil
}

// Serialization of HloOrdering.
type HloOrderingProto struct {
	SequentialComputations []*HloOrderingProto_SequentialComputation `protobuf:"bytes,1,rep,name=sequential_computations,json=sequentialComputations" json:"sequential_computations,omitempty"`
}

func (m *HloOrderingProto) Reset()                    { *m = HloOrderingProto{} }
func (*HloOrderingProto) ProtoMessage()               {}
func (*HloOrderingProto) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{3} }

func (m *HloOrderingProto) GetSequentialComputations() []*HloOrderingProto_SequentialComputation {
	if m != nil {
		return m.SequentialComputations
	}
	return nil
}

// NOTE: currently only sequential orderings are serialized.
type HloOrderingProto_SequentialComputation struct {
	ComputationName  string   `protobuf:"bytes,1,opt,name=computation_name,json=computationName,proto3" json:"computation_name,omitempty"`
	InstructionNames []string `protobuf:"bytes,2,rep,name=instruction_names,json=instructionNames" json:"instruction_names,omitempty"`
}

func (m *HloOrderingProto_SequentialComputation) Reset() {
	*m = HloOrderingProto_SequentialComputation{}
}
func (*HloOrderingProto_SequentialComputation) ProtoMessage() {}
func (*HloOrderingProto_SequentialComputation) Descriptor() ([]byte, []int) {
	return fileDescriptorHlo, []int{3, 0}
}

func (m *HloOrderingProto_SequentialComputation) GetComputationName() string {
	if m != nil {
		return m.ComputationName
	}
	return ""
}

func (m *HloOrderingProto_SequentialComputation) GetInstructionNames() []string {
	if m != nil {
		return m.InstructionNames
	}
	return nil
}

// Serialization of LogicalBuffer.
type LogicalBufferProto struct {
	Id    int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Size_ int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// The location where the buffer is defined.
	DefinedAt *LogicalBufferProto_Location `protobuf:"bytes,3,opt,name=defined_at,json=definedAt" json:"defined_at,omitempty"`
	Color     int64                        `protobuf:"varint,4,opt,name=color,proto3" json:"color,omitempty"`
}

func (m *LogicalBufferProto) Reset()                    { *m = LogicalBufferProto{} }
func (*LogicalBufferProto) ProtoMessage()               {}
func (*LogicalBufferProto) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{4} }

func (m *LogicalBufferProto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LogicalBufferProto) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *LogicalBufferProto) GetDefinedAt() *LogicalBufferProto_Location {
	if m != nil {
		return m.DefinedAt
	}
	return nil
}

func (m *LogicalBufferProto) GetColor() int64 {
	if m != nil {
		return m.Color
	}
	return 0
}

// Location represents an instruction and its shape index, which uniquely
// identifies a point where a buffer is needed.
type LogicalBufferProto_Location struct {
	// NOTE: module_name isn't necessary, since all LogicalBuffers are
	// associated with a single HloModule.
	ComputationName string  `protobuf:"bytes,1,opt,name=computation_name,json=computationName,proto3" json:"computation_name,omitempty"`
	InstructionName string  `protobuf:"bytes,2,opt,name=instruction_name,json=instructionName,proto3" json:"instruction_name,omitempty"`
	ShapeIndex      []int64 `protobuf:"varint,3,rep,packed,name=shape_index,json=shapeIndex" json:"shape_index,omitempty"`
}

func (m *LogicalBufferProto_Location) Reset()      { *m = LogicalBufferProto_Location{} }
func (*LogicalBufferProto_Location) ProtoMessage() {}
func (*LogicalBufferProto_Location) Descriptor() ([]byte, []int) {
	return fileDescriptorHlo, []int{4, 0}
}

func (m *LogicalBufferProto_Location) GetComputationName() string {
	if m != nil {
		return m.ComputationName
	}
	return ""
}

func (m *LogicalBufferProto_Location) GetInstructionName() string {
	if m != nil {
		return m.InstructionName
	}
	return ""
}

func (m *LogicalBufferProto_Location) GetShapeIndex() []int64 {
	if m != nil {
		return m.ShapeIndex
	}
	return nil
}

// Serialization of BufferAllocation.
type BufferAllocationProto struct {
	Index                       int64                             `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Size_                       int64                             `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	IsThreadLocal               bool                              `protobuf:"varint,3,opt,name=is_thread_local,json=isThreadLocal,proto3" json:"is_thread_local,omitempty"`
	IsReusable                  bool                              `protobuf:"varint,4,opt,name=is_reusable,json=isReusable,proto3" json:"is_reusable,omitempty"`
	IsEntryComputationParameter bool                              `protobuf:"varint,5,opt,name=is_entry_computation_parameter,json=isEntryComputationParameter,proto3" json:"is_entry_computation_parameter,omitempty"`
	ParameterNumber             int64                             `protobuf:"varint,6,opt,name=parameter_number,json=parameterNumber,proto3" json:"parameter_number,omitempty"`
	MaybeLiveOut                bool                              `protobuf:"varint,7,opt,name=maybe_live_out,json=maybeLiveOut,proto3" json:"maybe_live_out,omitempty"`
	Color                       int64                             `protobuf:"varint,8,opt,name=color,proto3" json:"color,omitempty"`
	Assigned                    []*BufferAllocationProto_Assigned `protobuf:"bytes,9,rep,name=assigned" json:"assigned,omitempty"`
}

func (m *BufferAllocationProto) Reset()                    { *m = BufferAllocationProto{} }
func (*BufferAllocationProto) ProtoMessage()               {}
func (*BufferAllocationProto) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{5} }

func (m *BufferAllocationProto) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *BufferAllocationProto) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *BufferAllocationProto) GetIsThreadLocal() bool {
	if m != nil {
		return m.IsThreadLocal
	}
	return false
}

func (m *BufferAllocationProto) GetIsReusable() bool {
	if m != nil {
		return m.IsReusable
	}
	return false
}

func (m *BufferAllocationProto) GetIsEntryComputationParameter() bool {
	if m != nil {
		return m.IsEntryComputationParameter
	}
	return false
}

func (m *BufferAllocationProto) GetParameterNumber() int64 {
	if m != nil {
		return m.ParameterNumber
	}
	return 0
}

func (m *BufferAllocationProto) GetMaybeLiveOut() bool {
	if m != nil {
		return m.MaybeLiveOut
	}
	return false
}

func (m *BufferAllocationProto) GetColor() int64 {
	if m != nil {
		return m.Color
	}
	return 0
}

func (m *BufferAllocationProto) GetAssigned() []*BufferAllocationProto_Assigned {
	if m != nil {
		return m.Assigned
	}
	return nil
}

// Assigned represents a single LogicalBuffer that is assigned to this
// BufferAllocation.
type BufferAllocationProto_Assigned struct {
	LogicalBufferId int64 `protobuf:"varint,1,opt,name=logical_buffer_id,json=logicalBufferId,proto3" json:"logical_buffer_id,omitempty"`
	Offset          int64 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Size_           int64 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *BufferAllocationProto_Assigned) Reset()      { *m = BufferAllocationProto_Assigned{} }
func (*BufferAllocationProto_Assigned) ProtoMessage() {}
func (*BufferAllocationProto_Assigned) Descriptor() ([]byte, []int) {
	return fileDescriptorHlo, []int{5, 0}
}

func (m *BufferAllocationProto_Assigned) GetLogicalBufferId() int64 {
	if m != nil {
		return m.LogicalBufferId
	}
	return 0
}

func (m *BufferAllocationProto_Assigned) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *BufferAllocationProto_Assigned) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

// A trace of a HeapSimulator run.
type HeapSimulatorTrace struct {
	Events                []*HeapSimulatorTrace_Event `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
	WholeModuleSimulation bool                        `protobuf:"varint,2,opt,name=whole_module_simulation,json=wholeModuleSimulation,proto3" json:"whole_module_simulation,omitempty"`
}

func (m *HeapSimulatorTrace) Reset()                    { *m = HeapSimulatorTrace{} }
func (*HeapSimulatorTrace) ProtoMessage()               {}
func (*HeapSimulatorTrace) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{6} }

func (m *HeapSimulatorTrace) GetEvents() []*HeapSimulatorTrace_Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *HeapSimulatorTrace) GetWholeModuleSimulation() bool {
	if m != nil {
		return m.WholeModuleSimulation
	}
	return false
}

// The trace includes a list of events, where each event describes one action
// performed by the heap simulator.
type HeapSimulatorTrace_Event struct {
	Kind HeapSimulatorTrace_Event_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=xla.HeapSimulatorTrace_Event_Kind" json:"kind,omitempty"`
	// The id of the LogicalBuffer that the event applies to.
	BufferId int64 `protobuf:"varint,2,opt,name=buffer_id,json=bufferId,proto3" json:"buffer_id,omitempty"`
	// The HloInstruction that the simulation was processing that caused this
	// event to occur, identified by its computation and instruction name. E.g.
	// buffers defined by instruction A are allocated when processing A.
	ComputationName string `protobuf:"bytes,3,opt,name=computation_name,json=computationName,proto3" json:"computation_name,omitempty"`
	InstructionName string `protobuf:"bytes,4,opt,name=instruction_name,json=instructionName,proto3" json:"instruction_name,omitempty"`
	// The id of the canonical LogicalBuffer that the buffer shares with. Only
	// set for SHARE_WITH events.
	ShareWithCanonicalId int64 `protobuf:"varint,5,opt,name=share_with_canonical_id,json=shareWithCanonicalId,proto3" json:"share_with_canonical_id,omitempty"`
}

func (m *HeapSimulatorTrace_Event) Reset()                    { *m = HeapSimulatorTrace_Event{} }
func (*HeapSimulatorTrace_Event) ProtoMessage()               {}
func (*HeapSimulatorTrace_Event) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{6, 0} }

func (m *HeapSimulatorTrace_Event) GetKind() HeapSimulatorTrace_Event_Kind {
	if m != nil {
		return m.Kind
	}
	return ALLOC
}

func (m *HeapSimulatorTrace_Event) GetBufferId() int64 {
	if m != nil {
		return m.BufferId
	}
	return 0
}

func (m *HeapSimulatorTrace_Event) GetComputationName() string {
	if m != nil {
		return m.ComputationName
	}
	return ""
}

func (m *HeapSimulatorTrace_Event) GetInstructionName() string {
	if m != nil {
		return m.InstructionName
	}
	return ""
}

func (m *HeapSimulatorTrace_Event) GetShareWithCanonicalId() int64 {
	if m != nil {
		return m.ShareWithCanonicalId
	}
	return 0
}

// Serialization of BufferAssignment.
type BufferAssignmentProto struct {
	LogicalBuffers      []*LogicalBufferProto                `protobuf:"bytes,1,rep,name=logical_buffers,json=logicalBuffers" json:"logical_buffers,omitempty"`
	BufferAliases       []*BufferAssignmentProto_BufferAlias `protobuf:"bytes,2,rep,name=buffer_aliases,json=bufferAliases" json:"buffer_aliases,omitempty"`
	BufferAllocations   []*BufferAllocationProto             `protobuf:"bytes,3,rep,name=buffer_allocations,json=bufferAllocations" json:"buffer_allocations,omitempty"`
	HeapSimulatorTraces []*HeapSimulatorTrace                `protobuf:"bytes,4,rep,name=heap_simulator_traces,json=heapSimulatorTraces" json:"heap_simulator_traces,omitempty"`
}

func (m *BufferAssignmentProto) Reset()                    { *m = BufferAssignmentProto{} }
func (*BufferAssignmentProto) ProtoMessage()               {}
func (*BufferAssignmentProto) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{7} }

func (m *BufferAssignmentProto) GetLogicalBuffers() []*LogicalBufferProto {
	if m != nil {
		return m.LogicalBuffers
	}
	return nil
}

func (m *BufferAssignmentProto) GetBufferAliases() []*BufferAssignmentProto_BufferAlias {
	if m != nil {
		return m.BufferAliases
	}
	return nil
}

func (m *BufferAssignmentProto) GetBufferAllocations() []*BufferAllocationProto {
	if m != nil {
		return m.BufferAllocations
	}
	return nil
}

func (m *BufferAssignmentProto) GetHeapSimulatorTraces() []*HeapSimulatorTrace {
	if m != nil {
		return m.HeapSimulatorTraces
	}
	return nil
}

// Alias represents a source LogicalBuffer, and the buffer location that
// aliases it.
type BufferAssignmentProto_BufferAlias struct {
	SourceBufferId int64                        `protobuf:"varint,1,opt,name=source_buffer_id,json=sourceBufferId,proto3" json:"source_buffer_id,omitempty"`
	Location       *LogicalBufferProto_Location `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
}

func (m *BufferAssignmentProto_BufferAlias) Reset()      { *m = BufferAssignmentProto_BufferAlias{} }
func (*BufferAssignmentProto_BufferAlias) ProtoMessage() {}
func (*BufferAssignmentProto_BufferAlias) Descriptor() ([]byte, []int) {
	return fileDescriptorHlo, []int{7, 0}
}

func (m *BufferAssignmentProto_BufferAlias) GetSourceBufferId() int64 {
	if m != nil {
		return m.SourceBufferId
	}
	return 0
}

func (m *BufferAssignmentProto_BufferAlias) GetLocation() *LogicalBufferProto_Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// Grouping message that contains all of the information above.
type HloProto struct {
	HloModule        *HloModuleProto        `protobuf:"bytes,1,opt,name=hlo_module,json=hloModule" json:"hlo_module,omitempty"`
	HloOrdering      *HloOrderingProto      `protobuf:"bytes,2,opt,name=hlo_ordering,json=hloOrdering" json:"hlo_ordering,omitempty"`
	BufferAssignment *BufferAssignmentProto `protobuf:"bytes,3,opt,name=buffer_assignment,json=bufferAssignment" json:"buffer_assignment,omitempty"`
}

func (m *HloProto) Reset()                    { *m = HloProto{} }
func (*HloProto) ProtoMessage()               {}
func (*HloProto) Descriptor() ([]byte, []int) { return fileDescriptorHlo, []int{8} }

func (m *HloProto) GetHloModule() *HloModuleProto {
	if m != nil {
		return m.HloModule
	}
	return nil
}

func (m *HloProto) GetHloOrdering() *HloOrderingProto {
	if m != nil {
		return m.HloOrdering
	}
	return nil
}

func (m *HloProto) GetBufferAssignment() *BufferAssignmentProto {
	if m != nil {
		return m.BufferAssignment
	}
	return nil
}

func init() {
	proto.RegisterType((*HloInstructionProto)(nil), "xla.HloInstructionProto")
	proto.RegisterType((*HloComputationProto)(nil), "xla.HloComputationProto")
	proto.RegisterType((*HloModuleProto)(nil), "xla.HloModuleProto")
	proto.RegisterType((*HloOrderingProto)(nil), "xla.HloOrderingProto")
	proto.RegisterType((*HloOrderingProto_SequentialComputation)(nil), "xla.HloOrderingProto.SequentialComputation")
	proto.RegisterType((*LogicalBufferProto)(nil), "xla.LogicalBufferProto")
	proto.RegisterType((*LogicalBufferProto_Location)(nil), "xla.LogicalBufferProto.Location")
	proto.RegisterType((*BufferAllocationProto)(nil), "xla.BufferAllocationProto")
	proto.RegisterType((*BufferAllocationProto_Assigned)(nil), "xla.BufferAllocationProto.Assigned")
	proto.RegisterType((*HeapSimulatorTrace)(nil), "xla.HeapSimulatorTrace")
	proto.RegisterType((*HeapSimulatorTrace_Event)(nil), "xla.HeapSimulatorTrace.Event")
	proto.RegisterType((*BufferAssignmentProto)(nil), "xla.BufferAssignmentProto")
	proto.RegisterType((*BufferAssignmentProto_BufferAlias)(nil), "xla.BufferAssignmentProto.BufferAlias")
	proto.RegisterType((*HloProto)(nil), "xla.HloProto")
	proto.RegisterEnum("xla.HeapSimulatorTrace_Event_Kind", HeapSimulatorTrace_Event_Kind_name, HeapSimulatorTrace_Event_Kind_value)
}
func (x HeapSimulatorTrace_Event_Kind) String() string {
	s, ok := HeapSimulatorTrace_Event_Kind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *HloInstructionProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HloInstructionProto)
	if !ok {
		that2, ok := that.(HloInstructionProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Opcode != that1.Opcode {
		return false
	}
	if !this.Shape.Equal(that1.Shape) {
		return false
	}
	if len(this.OperandNames) != len(that1.OperandNames) {
		return false
	}
	for i := range this.OperandNames {
		if this.OperandNames[i] != that1.OperandNames[i] {
			return false
		}
	}
	if len(this.ControlPredecessorNames) != len(that1.ControlPredecessorNames) {
		return false
	}
	for i := range this.ControlPredecessorNames {
		if this.ControlPredecessorNames[i] != that1.ControlPredecessorNames[i] {
			return false
		}
	}
	if len(this.CalledComputationNames) != len(that1.CalledComputationNames) {
		return false
	}
	for i := range this.CalledComputationNames {
		if this.CalledComputationNames[i] != that1.CalledComputationNames[i] {
			return false
		}
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if !this.Literal.Equal(that1.Literal) {
		return false
	}
	if this.ParameterNumber != that1.ParameterNumber {
		return false
	}
	if this.ParameterName != that1.ParameterName {
		return false
	}
	if this.FusionKind != that1.FusionKind {
		return false
	}
	if !this.FusedInstructionsComputation.Equal(that1.FusedInstructionsComputation) {
		return false
	}
	if this.TupleIndex != that1.TupleIndex {
		return false
	}
	return true
}
func (this *HloComputationProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HloComputationProto)
	if !ok {
		that2, ok := that.(HloComputationProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Instructions) != len(that1.Instructions) {
		return false
	}
	for i := range this.Instructions {
		if !this.Instructions[i].Equal(that1.Instructions[i]) {
			return false
		}
	}
	return true
}
func (this *HloModuleProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HloModuleProto)
	if !ok {
		that2, ok := that.(HloModuleProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.EntryComputationName != that1.EntryComputationName {
		return false
	}
	if len(this.Computations) != len(that1.Computations) {
		return false
	}
	for i := range this.Computations {
		if !this.Computations[i].Equal(that1.Computations[i]) {
			return false
		}
	}
	return true
}
func (this *HloOrderingProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HloOrderingProto)
	if !ok {
		that2, ok := that.(HloOrderingProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.SequentialComputations) != len(that1.SequentialComputations) {
		return false
	}
	for i := range this.SequentialComputations {
		if !this.SequentialComputations[i].Equal(that1.SequentialComputations[i]) {
			return false
		}
	}
	return true
}
func (this *HloOrderingProto_SequentialComputation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HloOrderingProto_SequentialComputation)
	if !ok {
		that2, ok := that.(HloOrderingProto_SequentialComputation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ComputationName != that1.ComputationName {
		return false
	}
	if len(this.InstructionNames) != len(that1.InstructionNames) {
		return false
	}
	for i := range this.InstructionNames {
		if this.InstructionNames[i] != that1.InstructionNames[i] {
			return false
		}
	}
	return true
}
func (this *LogicalBufferProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LogicalBufferProto)
	if !ok {
		that2, ok := that.(LogicalBufferProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if !this.DefinedAt.Equal(that1.DefinedAt) {
		return false
	}
	if this.Color != that1.Color {
		return false
	}
	return true
}
func (this *LogicalBufferProto_Location) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LogicalBufferProto_Location)
	if !ok {
		that2, ok := that.(LogicalBufferProto_Location)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ComputationName != that1.ComputationName {
		return false
	}
	if this.InstructionName != that1.InstructionName {
		return false
	}
	if len(this.ShapeIndex) != len(that1.ShapeIndex) {
		return false
	}
	for i := range this.ShapeIndex {
		if this.ShapeIndex[i] != that1.ShapeIndex[i] {
			return false
		}
	}
	return true
}
func (this *BufferAllocationProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BufferAllocationProto)
	if !ok {
		that2, ok := that.(BufferAllocationProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.IsThreadLocal != that1.IsThreadLocal {
		return false
	}
	if this.IsReusable != that1.IsReusable {
		return false
	}
	if this.IsEntryComputationParameter != that1.IsEntryComputationParameter {
		return false
	}
	if this.ParameterNumber != that1.ParameterNumber {
		return false
	}
	if this.MaybeLiveOut != that1.MaybeLiveOut {
		return false
	}
	if this.Color != that1.Color {
		return false
	}
	if len(this.Assigned) != len(that1.Assigned) {
		return false
	}
	for i := range this.Assigned {
		if !this.Assigned[i].Equal(that1.Assigned[i]) {
			return false
		}
	}
	return true
}
func (this *BufferAllocationProto_Assigned) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BufferAllocationProto_Assigned)
	if !ok {
		that2, ok := that.(BufferAllocationProto_Assigned)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LogicalBufferId != that1.LogicalBufferId {
		return false
	}
	if this.Offset != that1.Offset {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	return true
}
func (this *HeapSimulatorTrace) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HeapSimulatorTrace)
	if !ok {
		that2, ok := that.(HeapSimulatorTrace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if !this.Events[i].Equal(that1.Events[i]) {
			return false
		}
	}
	if this.WholeModuleSimulation != that1.WholeModuleSimulation {
		return false
	}
	return true
}
func (this *HeapSimulatorTrace_Event) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HeapSimulatorTrace_Event)
	if !ok {
		that2, ok := that.(HeapSimulatorTrace_Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.BufferId != that1.BufferId {
		return false
	}
	if this.ComputationName != that1.ComputationName {
		return false
	}
	if this.InstructionName != that1.InstructionName {
		return false
	}
	if this.ShareWithCanonicalId != that1.ShareWithCanonicalId {
		return false
	}
	return true
}
func (this *BufferAssignmentProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BufferAssignmentProto)
	if !ok {
		that2, ok := that.(BufferAssignmentProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.LogicalBuffers) != len(that1.LogicalBuffers) {
		return false
	}
	for i := range this.LogicalBuffers {
		if !this.LogicalBuffers[i].Equal(that1.LogicalBuffers[i]) {
			return false
		}
	}
	if len(this.BufferAliases) != len(that1.BufferAliases) {
		return false
	}
	for i := range this.BufferAliases {
		if !this.BufferAliases[i].Equal(that1.BufferAliases[i]) {
			return false
		}
	}
	if len(this.BufferAllocations) != len(that1.BufferAllocations) {
		return false
	}
	for i := range this.BufferAllocations {
		if !this.BufferAllocations[i].Equal(that1.BufferAllocations[i]) {
			return false
		}
	}
	if len(this.HeapSimulatorTraces) != len(that1.HeapSimulatorTraces) {
		return false
	}
	for i := range this.HeapSimulatorTraces {
		if !this.HeapSimulatorTraces[i].Equal(that1.HeapSimulatorTraces[i]) {
			return false
		}
	}
	return true
}
func (this *BufferAssignmentProto_BufferAlias) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BufferAssignmentProto_BufferAlias)
	if !ok {
		that2, ok := that.(BufferAssignmentProto_BufferAlias)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.SourceBufferId != that1.SourceBufferId {
		return false
	}
	if !this.Location.Equal(that1.Location) {
		return false
	}
	return true
}
func (this *HloProto) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HloProto)
	if !ok {
		that2, ok := that.(HloProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.HloModule.Equal(that1.HloModule) {
		return false
	}
	if !this.HloOrdering.Equal(that1.HloOrdering) {
		return false
	}
	if !this.BufferAssignment.Equal(that1.BufferAssignment) {
		return false
	}
	return true
}
func (this *HloInstructionProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&xla.HloInstructionProto{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Opcode: "+fmt.Sprintf("%#v", this.Opcode)+",\n")
	if this.Shape != nil {
		s = append(s, "Shape: "+fmt.Sprintf("%#v", this.Shape)+",\n")
	}
	s = append(s, "OperandNames: "+fmt.Sprintf("%#v", this.OperandNames)+",\n")
	s = append(s, "ControlPredecessorNames: "+fmt.Sprintf("%#v", this.ControlPredecessorNames)+",\n")
	s = append(s, "CalledComputationNames: "+fmt.Sprintf("%#v", this.CalledComputationNames)+",\n")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Literal != nil {
		s = append(s, "Literal: "+fmt.Sprintf("%#v", this.Literal)+",\n")
	}
	s = append(s, "ParameterNumber: "+fmt.Sprintf("%#v", this.ParameterNumber)+",\n")
	s = append(s, "ParameterName: "+fmt.Sprintf("%#v", this.ParameterName)+",\n")
	s = append(s, "FusionKind: "+fmt.Sprintf("%#v", this.FusionKind)+",\n")
	if this.FusedInstructionsComputation != nil {
		s = append(s, "FusedInstructionsComputation: "+fmt.Sprintf("%#v", this.FusedInstructionsComputation)+",\n")
	}
	s = append(s, "TupleIndex: "+fmt.Sprintf("%#v", this.TupleIndex)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HloComputationProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&xla.HloComputationProto{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Instructions != nil {
		s = append(s, "Instructions: "+fmt.Sprintf("%#v", this.Instructions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HloModuleProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&xla.HloModuleProto{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "EntryComputationName: "+fmt.Sprintf("%#v", this.EntryComputationName)+",\n")
	if this.Computations != nil {
		s = append(s, "Computations: "+fmt.Sprintf("%#v", this.Computations)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HloOrderingProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&xla.HloOrderingProto{")
	if this.SequentialComputations != nil {
		s = append(s, "SequentialComputations: "+fmt.Sprintf("%#v", this.SequentialComputations)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HloOrderingProto_SequentialComputation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&xla.HloOrderingProto_SequentialComputation{")
	s = append(s, "ComputationName: "+fmt.Sprintf("%#v", this.ComputationName)+",\n")
	s = append(s, "InstructionNames: "+fmt.Sprintf("%#v", this.InstructionNames)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogicalBufferProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&xla.LogicalBufferProto{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	if this.DefinedAt != nil {
		s = append(s, "DefinedAt: "+fmt.Sprintf("%#v", this.DefinedAt)+",\n")
	}
	s = append(s, "Color: "+fmt.Sprintf("%#v", this.Color)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogicalBufferProto_Location) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&xla.LogicalBufferProto_Location{")
	s = append(s, "ComputationName: "+fmt.Sprintf("%#v", this.ComputationName)+",\n")
	s = append(s, "InstructionName: "+fmt.Sprintf("%#v", this.InstructionName)+",\n")
	s = append(s, "ShapeIndex: "+fmt.Sprintf("%#v", this.ShapeIndex)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BufferAllocationProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&xla.BufferAllocationProto{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "IsThreadLocal: "+fmt.Sprintf("%#v", this.IsThreadLocal)+",\n")
	s = append(s, "IsReusable: "+fmt.Sprintf("%#v", this.IsReusable)+",\n")
	s = append(s, "IsEntryComputationParameter: "+fmt.Sprintf("%#v", this.IsEntryComputationParameter)+",\n")
	s = append(s, "ParameterNumber: "+fmt.Sprintf("%#v", this.ParameterNumber)+",\n")
	s = append(s, "MaybeLiveOut: "+fmt.Sprintf("%#v", this.MaybeLiveOut)+",\n")
	s = append(s, "Color: "+fmt.Sprintf("%#v", this.Color)+",\n")
	if this.Assigned != nil {
		s = append(s, "Assigned: "+fmt.Sprintf("%#v", this.Assigned)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BufferAllocationProto_Assigned) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&xla.BufferAllocationProto_Assigned{")
	s = append(s, "LogicalBufferId: "+fmt.Sprintf("%#v", this.LogicalBufferId)+",\n")
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeapSimulatorTrace) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&xla.HeapSimulatorTrace{")
	if this.Events != nil {
		s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	}
	s = append(s, "WholeModuleSimulation: "+fmt.Sprintf("%#v", this.WholeModuleSimulation)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeapSimulatorTrace_Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&xla.HeapSimulatorTrace_Event{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "BufferId: "+fmt.Sprintf("%#v", this.BufferId)+",\n")
	s = append(s, "ComputationName: "+fmt.Sprintf("%#v", this.ComputationName)+",\n")
	s = append(s, "InstructionName: "+fmt.Sprintf("%#v", this.InstructionName)+",\n")
	s = append(s, "ShareWithCanonicalId: "+fmt.Sprintf("%#v", this.ShareWithCanonicalId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BufferAssignmentProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&xla.BufferAssignmentProto{")
	if this.LogicalBuffers != nil {
		s = append(s, "LogicalBuffers: "+fmt.Sprintf("%#v", this.LogicalBuffers)+",\n")
	}
	if this.BufferAliases != nil {
		s = append(s, "BufferAliases: "+fmt.Sprintf("%#v", this.BufferAliases)+",\n")
	}
	if this.BufferAllocations != nil {
		s = append(s, "BufferAllocations: "+fmt.Sprintf("%#v", this.BufferAllocations)+",\n")
	}
	if this.HeapSimulatorTraces != nil {
		s = append(s, "HeapSimulatorTraces: "+fmt.Sprintf("%#v", this.HeapSimulatorTraces)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BufferAssignmentProto_BufferAlias) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&xla.BufferAssignmentProto_BufferAlias{")
	s = append(s, "SourceBufferId: "+fmt.Sprintf("%#v", this.SourceBufferId)+",\n")
	if this.Location != nil {
		s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HloProto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&xla.HloProto{")
	if this.HloModule != nil {
		s = append(s, "HloModule: "+fmt.Sprintf("%#v", this.HloModule)+",\n")
	}
	if this.HloOrdering != nil {
		s = append(s, "HloOrdering: "+fmt.Sprintf("%#v", this.HloOrdering)+",\n")
	}
	if this.BufferAssignment != nil {
		s = append(s, "BufferAssignment: "+fmt.Sprintf("%#v", this.BufferAssignment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringHlo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *HloInstructionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HloInstructionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Opcode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.Opcode)))
		i += copy(dAtA[i:], m.Opcode)
	}
	if m.Shape != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Shape.Size()))
		n1, err := m.Shape.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.OperandNames) > 0 {
		for _, s := range m.OperandNames {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ControlPredecessorNames) > 0 {
		for _, s := range m.ControlPredecessorNames {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CalledComputationNames) > 0 {
		for _, s := range m.CalledComputationNames {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Metadata != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Metadata.Size()))
		n2, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Literal != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Literal.Size()))
		n3, err := m.Literal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ParameterNumber != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.ParameterNumber))
	}
	if len(m.ParameterName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.ParameterName)))
		i += copy(dAtA[i:], m.ParameterName)
	}
	if len(m.FusionKind) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.FusionKind)))
		i += copy(dAtA[i:], m.FusionKind)
	}
	if m.FusedInstructionsComputation != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.FusedInstructionsComputation.Size()))
		n4, err := m.FusedInstructionsComputation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.TupleIndex != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.TupleIndex))
	}
	return i, nil
}

func (m *HloComputationProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HloComputationProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Instructions) > 0 {
		for _, msg := range m.Instructions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HloModuleProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HloModuleProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.EntryComputationName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.EntryComputationName)))
		i += copy(dAtA[i:], m.EntryComputationName)
	}
	if len(m.Computations) > 0 {
		for _, msg := range m.Computations {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HloOrderingProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HloOrderingProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SequentialComputations) > 0 {
		for _, msg := range m.SequentialComputations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HloOrderingProto_SequentialComputation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HloOrderingProto_SequentialComputation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ComputationName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.ComputationName)))
		i += copy(dAtA[i:], m.ComputationName)
	}
	if len(m.InstructionNames) > 0 {
		for _, s := range m.InstructionNames {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LogicalBufferProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalBufferProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Id))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Size_))
	}
	if m.DefinedAt != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.DefinedAt.Size()))
		n5, err := m.DefinedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Color != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Color))
	}
	return i, nil
}

func (m *LogicalBufferProto_Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalBufferProto_Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ComputationName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.ComputationName)))
		i += copy(dAtA[i:], m.ComputationName)
	}
	if len(m.InstructionName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.InstructionName)))
		i += copy(dAtA[i:], m.InstructionName)
	}
	if len(m.ShapeIndex) > 0 {
		dAtA7 := make([]byte, len(m.ShapeIndex)*10)
		var j6 int
		for _, num1 := range m.ShapeIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHlo(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func (m *BufferAllocationProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferAllocationProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Index))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Size_))
	}
	if m.IsThreadLocal {
		dAtA[i] = 0x18
		i++
		if m.IsThreadLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsReusable {
		dAtA[i] = 0x20
		i++
		if m.IsReusable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsEntryComputationParameter {
		dAtA[i] = 0x28
		i++
		if m.IsEntryComputationParameter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ParameterNumber != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.ParameterNumber))
	}
	if m.MaybeLiveOut {
		dAtA[i] = 0x38
		i++
		if m.MaybeLiveOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Color != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Color))
	}
	if len(m.Assigned) > 0 {
		for _, msg := range m.Assigned {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BufferAllocationProto_Assigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferAllocationProto_Assigned) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LogicalBufferId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.LogicalBufferId))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Offset))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *HeapSimulatorTrace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeapSimulatorTrace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WholeModuleSimulation {
		dAtA[i] = 0x10
		i++
		if m.WholeModuleSimulation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HeapSimulatorTrace_Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeapSimulatorTrace_Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Kind))
	}
	if m.BufferId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.BufferId))
	}
	if len(m.ComputationName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.ComputationName)))
		i += copy(dAtA[i:], m.ComputationName)
	}
	if len(m.InstructionName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHlo(dAtA, i, uint64(len(m.InstructionName)))
		i += copy(dAtA[i:], m.InstructionName)
	}
	if m.ShareWithCanonicalId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.ShareWithCanonicalId))
	}
	return i, nil
}

func (m *BufferAssignmentProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferAssignmentProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LogicalBuffers) > 0 {
		for _, msg := range m.LogicalBuffers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BufferAliases) > 0 {
		for _, msg := range m.BufferAliases {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BufferAllocations) > 0 {
		for _, msg := range m.BufferAllocations {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HeapSimulatorTraces) > 0 {
		for _, msg := range m.HeapSimulatorTraces {
			dAtA[i] = 0x22
			i++
			i = encodeVarintHlo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BufferAssignmentProto_BufferAlias) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferAssignmentProto_BufferAlias) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceBufferId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.SourceBufferId))
	}
	if m.Location != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.Location.Size()))
		n8, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *HloProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HloProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HloModule != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.HloModule.Size()))
		n9, err := m.HloModule.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.HloOrdering != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.HloOrdering.Size()))
		n10, err := m.HloOrdering.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.BufferAssignment != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHlo(dAtA, i, uint64(m.BufferAssignment.Size()))
		n11, err := m.BufferAssignment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func encodeFixed64Hlo(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Hlo(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintHlo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HloInstructionProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	l = len(m.Opcode)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	if len(m.OperandNames) > 0 {
		for _, s := range m.OperandNames {
			l = len(s)
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	if len(m.ControlPredecessorNames) > 0 {
		for _, s := range m.ControlPredecessorNames {
			l = len(s)
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	if len(m.CalledComputationNames) > 0 {
		for _, s := range m.CalledComputationNames {
			l = len(s)
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.Literal != nil {
		l = m.Literal.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.ParameterNumber != 0 {
		n += 1 + sovHlo(uint64(m.ParameterNumber))
	}
	l = len(m.ParameterName)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	l = len(m.FusionKind)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.FusedInstructionsComputation != nil {
		l = m.FusedInstructionsComputation.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.TupleIndex != 0 {
		n += 1 + sovHlo(uint64(m.TupleIndex))
	}
	return n
}

func (m *HloComputationProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	if len(m.Instructions) > 0 {
		for _, e := range m.Instructions {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	return n
}

func (m *HloModuleProto) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	l = len(m.EntryComputationName)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	if len(m.Computations) > 0 {
		for _, e := range m.Computations {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	return n
}

func (m *HloOrderingProto) Size() (n int) {
	var l int
	_ = l
	if len(m.SequentialComputations) > 0 {
		for _, e := range m.SequentialComputations {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	return n
}

func (m *HloOrderingProto_SequentialComputation) Size() (n int) {
	var l int
	_ = l
	l = len(m.ComputationName)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	if len(m.InstructionNames) > 0 {
		for _, s := range m.InstructionNames {
			l = len(s)
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	return n
}

func (m *LogicalBufferProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHlo(uint64(m.Id))
	}
	if m.Size_ != 0 {
		n += 1 + sovHlo(uint64(m.Size_))
	}
	if m.DefinedAt != nil {
		l = m.DefinedAt.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.Color != 0 {
		n += 1 + sovHlo(uint64(m.Color))
	}
	return n
}

func (m *LogicalBufferProto_Location) Size() (n int) {
	var l int
	_ = l
	l = len(m.ComputationName)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	l = len(m.InstructionName)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	if len(m.ShapeIndex) > 0 {
		l = 0
		for _, e := range m.ShapeIndex {
			l += sovHlo(uint64(e))
		}
		n += 1 + sovHlo(uint64(l)) + l
	}
	return n
}

func (m *BufferAllocationProto) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovHlo(uint64(m.Index))
	}
	if m.Size_ != 0 {
		n += 1 + sovHlo(uint64(m.Size_))
	}
	if m.IsThreadLocal {
		n += 2
	}
	if m.IsReusable {
		n += 2
	}
	if m.IsEntryComputationParameter {
		n += 2
	}
	if m.ParameterNumber != 0 {
		n += 1 + sovHlo(uint64(m.ParameterNumber))
	}
	if m.MaybeLiveOut {
		n += 2
	}
	if m.Color != 0 {
		n += 1 + sovHlo(uint64(m.Color))
	}
	if len(m.Assigned) > 0 {
		for _, e := range m.Assigned {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	return n
}

func (m *BufferAllocationProto_Assigned) Size() (n int) {
	var l int
	_ = l
	if m.LogicalBufferId != 0 {
		n += 1 + sovHlo(uint64(m.LogicalBufferId))
	}
	if m.Offset != 0 {
		n += 1 + sovHlo(uint64(m.Offset))
	}
	if m.Size_ != 0 {
		n += 1 + sovHlo(uint64(m.Size_))
	}
	return n
}

func (m *HeapSimulatorTrace) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	if m.WholeModuleSimulation {
		n += 2
	}
	return n
}

func (m *HeapSimulatorTrace_Event) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovHlo(uint64(m.Kind))
	}
	if m.BufferId != 0 {
		n += 1 + sovHlo(uint64(m.BufferId))
	}
	l = len(m.ComputationName)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	l = len(m.InstructionName)
	if l > 0 {
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.ShareWithCanonicalId != 0 {
		n += 1 + sovHlo(uint64(m.ShareWithCanonicalId))
	}
	return n
}

func (m *BufferAssignmentProto) Size() (n int) {
	var l int
	_ = l
	if len(m.LogicalBuffers) > 0 {
		for _, e := range m.LogicalBuffers {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	if len(m.BufferAliases) > 0 {
		for _, e := range m.BufferAliases {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	if len(m.BufferAllocations) > 0 {
		for _, e := range m.BufferAllocations {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	if len(m.HeapSimulatorTraces) > 0 {
		for _, e := range m.HeapSimulatorTraces {
			l = e.Size()
			n += 1 + l + sovHlo(uint64(l))
		}
	}
	return n
}

func (m *BufferAssignmentProto_BufferAlias) Size() (n int) {
	var l int
	_ = l
	if m.SourceBufferId != 0 {
		n += 1 + sovHlo(uint64(m.SourceBufferId))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	return n
}

func (m *HloProto) Size() (n int) {
	var l int
	_ = l
	if m.HloModule != nil {
		l = m.HloModule.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.HloOrdering != nil {
		l = m.HloOrdering.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	if m.BufferAssignment != nil {
		l = m.BufferAssignment.Size()
		n += 1 + l + sovHlo(uint64(l))
	}
	return n
}

func sovHlo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHlo(x uint64) (n int) {
	return sovHlo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *HloInstructionProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HloInstructionProto{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Opcode:` + fmt.Sprintf("%v", this.Opcode) + `,`,
		`Shape:` + strings.Replace(fmt.Sprintf("%v", this.Shape), "Shape", "xla1.Shape", 1) + `,`,
		`OperandNames:` + fmt.Sprintf("%v", this.OperandNames) + `,`,
		`ControlPredecessorNames:` + fmt.Sprintf("%v", this.ControlPredecessorNames) + `,`,
		`CalledComputationNames:` + fmt.Sprintf("%v", this.CalledComputationNames) + `,`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "OpMetadata", "xla1.OpMetadata", 1) + `,`,
		`Literal:` + strings.Replace(fmt.Sprintf("%v", this.Literal), "LiteralProto", "xla1.LiteralProto", 1) + `,`,
		`ParameterNumber:` + fmt.Sprintf("%v", this.ParameterNumber) + `,`,
		`ParameterName:` + fmt.Sprintf("%v", this.ParameterName) + `,`,
		`FusionKind:` + fmt.Sprintf("%v", this.FusionKind) + `,`,
		`FusedInstructionsComputation:` + strings.Replace(fmt.Sprintf("%v", this.FusedInstructionsComputation), "HloComputationProto", "HloComputationProto", 1) + `,`,
		`TupleIndex:` + fmt.Sprintf("%v", this.TupleIndex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HloComputationProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HloComputationProto{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Instructions:` + strings.Replace(fmt.Sprintf("%v", this.Instructions), "HloInstructionProto", "HloInstructionProto", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HloModuleProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HloModuleProto{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`EntryComputationName:` + fmt.Sprintf("%v", this.EntryComputationName) + `,`,
		`Computations:` + strings.Replace(fmt.Sprintf("%v", this.Computations), "HloComputationProto", "HloComputationProto", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HloOrderingProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HloOrderingProto{`,
		`SequentialComputations:` + strings.Replace(fmt.Sprintf("%v", this.SequentialComputations), "HloOrderingProto_SequentialComputation", "HloOrderingProto_SequentialComputation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HloOrderingProto_SequentialComputation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HloOrderingProto_SequentialComputation{`,
		`ComputationName:` + fmt.Sprintf("%v", this.ComputationName) + `,`,
		`InstructionNames:` + fmt.Sprintf("%v", this.InstructionNames) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogicalBufferProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogicalBufferProto{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`DefinedAt:` + strings.Replace(fmt.Sprintf("%v", this.DefinedAt), "LogicalBufferProto_Location", "LogicalBufferProto_Location", 1) + `,`,
		`Color:` + fmt.Sprintf("%v", this.Color) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogicalBufferProto_Location) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogicalBufferProto_Location{`,
		`ComputationName:` + fmt.Sprintf("%v", this.ComputationName) + `,`,
		`InstructionName:` + fmt.Sprintf("%v", this.InstructionName) + `,`,
		`ShapeIndex:` + fmt.Sprintf("%v", this.ShapeIndex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BufferAllocationProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BufferAllocationProto{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`IsThreadLocal:` + fmt.Sprintf("%v", this.IsThreadLocal) + `,`,
		`IsReusable:` + fmt.Sprintf("%v", this.IsReusable) + `,`,
		`IsEntryComputationParameter:` + fmt.Sprintf("%v", this.IsEntryComputationParameter) + `,`,
		`ParameterNumber:` + fmt.Sprintf("%v", this.ParameterNumber) + `,`,
		`MaybeLiveOut:` + fmt.Sprintf("%v", this.MaybeLiveOut) + `,`,
		`Color:` + fmt.Sprintf("%v", this.Color) + `,`,
		`Assigned:` + strings.Replace(fmt.Sprintf("%v", this.Assigned), "BufferAllocationProto_Assigned", "BufferAllocationProto_Assigned", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BufferAllocationProto_Assigned) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BufferAllocationProto_Assigned{`,
		`LogicalBufferId:` + fmt.Sprintf("%v", this.LogicalBufferId) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeapSimulatorTrace) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeapSimulatorTrace{`,
		`Events:` + strings.Replace(fmt.Sprintf("%v", this.Events), "HeapSimulatorTrace_Event", "HeapSimulatorTrace_Event", 1) + `,`,
		`WholeModuleSimulation:` + fmt.Sprintf("%v", this.WholeModuleSimulation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeapSimulatorTrace_Event) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeapSimulatorTrace_Event{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`BufferId:` + fmt.Sprintf("%v", this.BufferId) + `,`,
		`ComputationName:` + fmt.Sprintf("%v", this.ComputationName) + `,`,
		`InstructionName:` + fmt.Sprintf("%v", this.InstructionName) + `,`,
		`ShareWithCanonicalId:` + fmt.Sprintf("%v", this.ShareWithCanonicalId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BufferAssignmentProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BufferAssignmentProto{`,
		`LogicalBuffers:` + strings.Replace(fmt.Sprintf("%v", this.LogicalBuffers), "LogicalBufferProto", "LogicalBufferProto", 1) + `,`,
		`BufferAliases:` + strings.Replace(fmt.Sprintf("%v", this.BufferAliases), "BufferAssignmentProto_BufferAlias", "BufferAssignmentProto_BufferAlias", 1) + `,`,
		`BufferAllocations:` + strings.Replace(fmt.Sprintf("%v", this.BufferAllocations), "BufferAllocationProto", "BufferAllocationProto", 1) + `,`,
		`HeapSimulatorTraces:` + strings.Replace(fmt.Sprintf("%v", this.HeapSimulatorTraces), "HeapSimulatorTrace", "HeapSimulatorTrace", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BufferAssignmentProto_BufferAlias) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BufferAssignmentProto_BufferAlias{`,
		`SourceBufferId:` + fmt.Sprintf("%v", this.SourceBufferId) + `,`,
		`Location:` + strings.Replace(fmt.Sprintf("%v", this.Location), "LogicalBufferProto_Location", "LogicalBufferProto_Location", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HloProto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HloProto{`,
		`HloModule:` + strings.Replace(fmt.Sprintf("%v", this.HloModule), "HloModuleProto", "HloModuleProto", 1) + `,`,
		`HloOrdering:` + strings.Replace(fmt.Sprintf("%v", this.HloOrdering), "HloOrderingProto", "HloOrderingProto", 1) + `,`,
		`BufferAssignment:` + strings.Replace(fmt.Sprintf("%v", this.BufferAssignment), "BufferAssignmentProto", "BufferAssignmentProto", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringHlo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *HloInstructionProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HloInstructionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HloInstructionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opcode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Opcode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &xla1.Shape{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperandNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperandNames = append(m.OperandNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlPredecessorNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlPredecessorNames = append(m.ControlPredecessorNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalledComputationNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CalledComputationNames = append(m.CalledComputationNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &xla1.OpMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Literal == nil {
				m.Literal = &xla1.LiteralProto{}
			}
			if err := m.Literal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterNumber", wireType)
			}
			m.ParameterNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParameterNumber |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FusionKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FusionKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FusedInstructionsComputation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FusedInstructionsComputation == nil {
				m.FusedInstructionsComputation = &HloComputationProto{}
			}
			if err := m.FusedInstructionsComputation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TupleIndex", wireType)
			}
			m.TupleIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TupleIndex |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HloComputationProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HloComputationProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HloComputationProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instructions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instructions = append(m.Instructions, &HloInstructionProto{})
			if err := m.Instructions[len(m.Instructions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HloModuleProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HloModuleProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HloModuleProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryComputationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryComputationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Computations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Computations = append(m.Computations, &HloComputationProto{})
			if err := m.Computations[len(m.Computations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HloOrderingProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HloOrderingProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HloOrderingProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequentialComputations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SequentialComputations = append(m.SequentialComputations, &HloOrderingProto_SequentialComputation{})
			if err := m.SequentialComputations[len(m.SequentialComputations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HloOrderingProto_SequentialComputation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequentialComputation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequentialComputation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComputationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstructionNames = append(m.InstructionNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalBufferProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalBufferProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalBufferProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefinedAt == nil {
				m.DefinedAt = &LogicalBufferProto_Location{}
			}
			if err := m.DefinedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalBufferProto_Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComputationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstructionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHlo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShapeIndex = append(m.ShapeIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHlo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHlo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHlo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShapeIndex = append(m.ShapeIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShapeIndex", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferAllocationProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferAllocationProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferAllocationProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsThreadLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsThreadLocal = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReusable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReusable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEntryComputationParameter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEntryComputationParameter = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterNumber", wireType)
			}
			m.ParameterNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParameterNumber |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaybeLiveOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaybeLiveOut = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assigned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assigned = append(m.Assigned, &BufferAllocationProto_Assigned{})
			if err := m.Assigned[len(m.Assigned)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferAllocationProto_Assigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalBufferId", wireType)
			}
			m.LogicalBufferId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicalBufferId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeapSimulatorTrace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeapSimulatorTrace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeapSimulatorTrace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &HeapSimulatorTrace_Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WholeModuleSimulation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WholeModuleSimulation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeapSimulatorTrace_Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (HeapSimulatorTrace_Event_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferId", wireType)
			}
			m.BufferId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComputationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstructionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareWithCanonicalId", wireType)
			}
			m.ShareWithCanonicalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareWithCanonicalId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferAssignmentProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferAssignmentProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferAssignmentProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalBuffers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicalBuffers = append(m.LogicalBuffers, &LogicalBufferProto{})
			if err := m.LogicalBuffers[len(m.LogicalBuffers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferAliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufferAliases = append(m.BufferAliases, &BufferAssignmentProto_BufferAlias{})
			if err := m.BufferAliases[len(m.BufferAliases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferAllocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BufferAllocations = append(m.BufferAllocations, &BufferAllocationProto{})
			if err := m.BufferAllocations[len(m.BufferAllocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeapSimulatorTraces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeapSimulatorTraces = append(m.HeapSimulatorTraces, &HeapSimulatorTrace{})
			if err := m.HeapSimulatorTraces[len(m.HeapSimulatorTraces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferAssignmentProto_BufferAlias) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferAlias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferAlias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceBufferId", wireType)
			}
			m.SourceBufferId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceBufferId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &LogicalBufferProto_Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HloProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HloProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HloProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HloModule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HloModule == nil {
				m.HloModule = &HloModuleProto{}
			}
			if err := m.HloModule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HloOrdering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HloOrdering == nil {
				m.HloOrdering = &HloOrderingProto{}
			}
			if err := m.HloOrdering.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferAssignment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHlo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferAssignment == nil {
				m.BufferAssignment = &BufferAssignmentProto{}
			}
			if err := m.BufferAssignment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHlo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHlo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHlo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHlo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHlo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHlo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHlo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHlo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHlo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHlo   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/compiler/xla/service/hlo.proto", fileDescriptorHlo)
}

var fileDescriptorHlo = []byte{
	// 1316 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcd, 0x6e, 0xdb, 0xc6,
	0x16, 0x36, 0x45, 0xd9, 0x91, 0x8e, 0x6d, 0x59, 0x9e, 0xf8, 0x87, 0x57, 0xb9, 0x57, 0x57, 0x50,
	0xee, 0x0d, 0x9c, 0x1a, 0x90, 0x01, 0xb7, 0x09, 0x82, 0x22, 0x40, 0xea, 0x18, 0x6e, 0x65, 0xc4,
	0x89, 0x83, 0x71, 0x80, 0xec, 0x4a, 0x8c, 0xc8, 0x91, 0x35, 0xe8, 0x88, 0xa3, 0x72, 0x48, 0xc7,
	0xe9, 0xaa, 0x7d, 0x83, 0x02, 0x05, 0x8a, 0x2e, 0xfa, 0x00, 0x7d, 0x83, 0xae, 0xbb, 0xeb, 0xa2,
	0x8b, 0x2c, 0x0b, 0x74, 0xd3, 0xa8, 0x9b, 0x76, 0x97, 0x65, 0x97, 0x05, 0xcf, 0x90, 0x12, 0xf5,
	0xe3, 0x22, 0xdd, 0x89, 0xdf, 0x7c, 0x67, 0xe6, 0xfc, 0x7c, 0xe7, 0x1c, 0xc1, 0xfe, 0x20, 0x54,
	0x91, 0xea, 0xc4, 0xdd, 0xbd, 0x88, 0x07, 0x5a, 0x85, 0x5d, 0xa9, 0x5e, 0xec, 0x79, 0xaa, 0x3f,
	0x10, 0x92, 0x87, 0x7b, 0x97, 0x92, 0xed, 0x69, 0x1e, 0x5e, 0x08, 0x8f, 0xef, 0xf5, 0xa4, 0x6a,
	0x21, 0x99, 0xd8, 0x97, 0x92, 0xd5, 0x6e, 0x5d, 0xc5, 0xbf, 0x94, 0xcc, 0xf5, 0x59, 0xc4, 0x0c,
	0xb9, 0xf9, 0x53, 0x11, 0xae, 0xb7, 0xa5, 0x3a, 0x0e, 0x74, 0x14, 0xc6, 0x5e, 0x24, 0x54, 0xf0,
	0x14, 0x2f, 0x21, 0x50, 0x0c, 0x58, 0x9f, 0x3b, 0x56, 0xc3, 0xda, 0x29, 0x53, 0xfc, 0x4d, 0xb6,
	0x60, 0x49, 0x0d, 0x3c, 0xe5, 0x73, 0xa7, 0x80, 0x68, 0xfa, 0x45, 0x1a, 0xb0, 0xa8, 0x7b, 0x6c,
	0xc0, 0x1d, 0xbb, 0x61, 0xed, 0x2c, 0xef, 0x43, 0xeb, 0x52, 0xb2, 0xd6, 0x59, 0x82, 0x50, 0x73,
	0x40, 0x6e, 0xc2, 0xaa, 0x1a, 0xf0, 0x90, 0x05, 0xbe, 0x9b, 0xdc, 0xa4, 0x9d, 0x62, 0xc3, 0xde,
	0x29, 0xd3, 0x95, 0x14, 0x7c, 0x92, 0x60, 0xe4, 0x7d, 0xf8, 0x97, 0xa7, 0x82, 0x28, 0x54, 0xd2,
	0x1d, 0x84, 0xdc, 0xe7, 0x1e, 0xd7, 0x5a, 0x85, 0xa9, 0xc1, 0x22, 0x1a, 0x6c, 0xa7, 0x84, 0xa7,
	0xe3, 0x73, 0x63, 0x7b, 0x0f, 0x1c, 0x8f, 0x49, 0xc9, 0x7d, 0x37, 0x09, 0x36, 0x8e, 0x58, 0x12,
	0x49, 0x6a, 0xba, 0x84, 0xa6, 0x5b, 0xe6, 0xfc, 0x70, 0x7c, 0x6c, 0x2c, 0x77, 0xa1, 0xd4, 0xe7,
	0x11, 0x4b, 0x52, 0xe2, 0x5c, 0x43, 0xff, 0xd7, 0xd0, 0xff, 0xd3, 0xc1, 0xe3, 0x14, 0xa6, 0x23,
	0x02, 0xd9, 0x85, 0x6b, 0x52, 0x44, 0x3c, 0x64, 0xd2, 0x29, 0x21, 0x77, 0x1d, 0xb9, 0x27, 0x06,
	0xc3, 0xcc, 0xd1, 0x8c, 0x41, 0x6e, 0x43, 0x75, 0xc0, 0x42, 0xd6, 0xe7, 0x11, 0x0f, 0xdd, 0x20,
	0xee, 0x77, 0x78, 0xe8, 0x94, 0x1b, 0xd6, 0x8e, 0x4d, 0xd7, 0x46, 0xf8, 0x13, 0x84, 0xc9, 0xff,
	0xa1, 0x92, 0xa3, 0x26, 0x79, 0x07, 0xcc, 0xf0, 0xea, 0x98, 0x98, 0x14, 0xe0, 0xbf, 0xb0, 0xdc,
	0x8d, 0x75, 0x12, 0xd9, 0x27, 0x22, 0xf0, 0x9d, 0x65, 0xe4, 0x80, 0x81, 0x1e, 0x89, 0xc0, 0x27,
	0x1f, 0x43, 0xbd, 0x1b, 0x6b, 0xee, 0xbb, 0x62, 0x5c, 0x4f, 0x9d, 0x4f, 0x89, 0xb3, 0x82, 0x6e,
	0x3b, 0xe8, 0x76, 0x5b, 0xaa, 0x5c, 0x3a, 0x8c, 0xf7, 0xff, 0x46, 0xfb, 0x9c, 0x1c, 0x74, 0x8e,
	0x92, 0x38, 0x10, 0xc5, 0x03, 0xc9, 0x5d, 0x11, 0xf8, 0xfc, 0xd2, 0x59, 0xc5, 0x68, 0x00, 0xa1,
	0xe3, 0x04, 0x69, 0x9e, 0xa3, 0x9a, 0xa6, 0x6f, 0x9d, 0xab, 0xa6, 0xfb, 0xb0, 0x92, 0xf7, 0xd2,
	0x29, 0x34, 0xec, 0xbc, 0x67, 0xd3, 0x8a, 0xa4, 0x13, 0xec, 0xe6, 0x37, 0x16, 0x54, 0xda, 0x52,
	0x3d, 0x56, 0x7e, 0x2c, 0xf9, 0xd5, 0x8f, 0xbc, 0x07, 0x5b, 0x3c, 0x88, 0xc2, 0x97, 0x33, 0xb2,
	0x48, 0x25, 0xbc, 0x81, 0xa7, 0x53, 0xa2, 0x48, 0x5c, 0xcb, 0xf1, 0xb5, 0x63, 0x4f, 0xba, 0x36,
	0x93, 0xb4, 0x09, 0x76, 0xf3, 0x0f, 0x0b, 0xaa, 0x6d, 0xa9, 0x4e, 0x43, 0x9f, 0x87, 0x22, 0x38,
	0x37, 0xce, 0xf9, 0xb0, 0xad, 0xf9, 0xa7, 0x31, 0x0f, 0x22, 0xc1, 0xa4, 0x3b, 0x71, 0xbb, 0x85,
	0xb7, 0xef, 0x66, 0xb7, 0x4f, 0xd8, 0xb5, 0xce, 0x46, 0x46, 0xb9, 0x57, 0xe9, 0x96, 0x9e, 0x07,
	0xeb, 0x9a, 0x82, 0xcd, 0xb9, 0x06, 0x89, 0x16, 0x67, 0x32, 0x60, 0xf2, 0xb4, 0xe6, 0x4d, 0x05,
	0xbf, 0x0b, 0xeb, 0xb9, 0x4c, 0xa7, 0x3d, 0x54, 0xc0, 0x1e, 0xaa, 0xe6, 0x0e, 0xb0, 0x7b, 0x9a,
	0x5f, 0x15, 0x80, 0x9c, 0xa8, 0x73, 0xe1, 0x31, 0xf9, 0x30, 0xee, 0x76, 0x79, 0x68, 0xa2, 0xad,
	0x40, 0x41, 0xf8, 0xf8, 0x80, 0x4d, 0x0b, 0xc2, 0x4f, 0x4a, 0xa3, 0xc5, 0x67, 0x26, 0xe9, 0x36,
	0xc5, 0xdf, 0xe4, 0x01, 0x80, 0xcf, 0xbb, 0x22, 0xe0, 0xbe, 0xcb, 0xa2, 0x74, 0x74, 0x34, 0x4c,
	0x3b, 0xcd, 0x5c, 0xd8, 0x3a, 0x51, 0x9e, 0x89, 0xbc, 0x9c, 0xda, 0x1c, 0x44, 0x64, 0x03, 0x16,
	0x3d, 0x25, 0x55, 0xe8, 0x14, 0xf1, 0x56, 0xf3, 0x51, 0xfb, 0xc2, 0x82, 0x52, 0xc6, 0xfe, 0x27,
	0x61, 0xdf, 0x86, 0xea, 0x74, 0xd8, 0xa9, 0x46, 0xd6, 0xa6, 0xa2, 0x4e, 0xba, 0x00, 0xc7, 0x5a,
	0xda, 0x05, 0x89, 0x3a, 0x6c, 0x0a, 0x08, 0x99, 0x2e, 0xf8, 0xc5, 0x86, 0x4d, 0xe3, 0xfd, 0x81,
	0x94, 0xa9, 0x2f, 0x26, 0x31, 0x1b, 0xb0, 0x68, 0x8c, 0x4c, 0x6e, 0xcc, 0xc7, 0xdc, 0xf4, 0xdc,
	0x82, 0x35, 0xa1, 0xdd, 0xa8, 0x17, 0x72, 0xe6, 0xbb, 0xc9, 0x25, 0x12, 0x73, 0x54, 0xa2, 0xab,
	0x42, 0x3f, 0x43, 0x34, 0x89, 0x52, 0x26, 0xce, 0x08, 0xed, 0x86, 0x3c, 0xd6, 0xac, 0x23, 0x39,
	0xe6, 0xa2, 0x44, 0x41, 0x68, 0x9a, 0x22, 0xe4, 0x10, 0xea, 0x42, 0xbb, 0xb3, 0x5d, 0x30, 0x1a,
	0x2d, 0xce, 0x22, 0xda, 0xdc, 0x10, 0xfa, 0x68, 0xaa, 0x19, 0x9e, 0x66, 0x94, 0xb9, 0xb3, 0x6c,
	0x69, 0xfe, 0x2c, 0xfb, 0x1f, 0x54, 0xfa, 0xec, 0x65, 0x87, 0xbb, 0x52, 0x5c, 0x70, 0x57, 0xc5,
	0x11, 0x8e, 0xd5, 0x12, 0x5d, 0x41, 0xf4, 0x44, 0x5c, 0xf0, 0xd3, 0x38, 0x57, 0xbc, 0x52, 0xae,
	0x78, 0xe4, 0x01, 0x94, 0x98, 0xd6, 0xe2, 0x3c, 0xe0, 0xbe, 0x53, 0xc6, 0xb6, 0xb8, 0x89, 0x8a,
	0x98, 0x9b, 0xcc, 0xd6, 0x41, 0x4a, 0xa5, 0x23, 0xa3, 0x5a, 0x07, 0x4a, 0x19, 0x4a, 0xde, 0x81,
	0x75, 0x69, 0x94, 0xe4, 0x76, 0xd0, 0xde, 0x1d, 0x69, 0x72, 0x4d, 0xe6, 0x25, 0x76, 0xec, 0xe3,
	0x6a, 0xeb, 0x76, 0x35, 0x8f, 0xd2, 0x1a, 0xa4, 0x5f, 0xa3, 0xca, 0xd8, 0xe3, 0xca, 0x34, 0xbf,
	0xb5, 0x81, 0xb4, 0x39, 0x1b, 0x9c, 0x89, 0x7e, 0x2c, 0x59, 0xa4, 0xc2, 0x67, 0x21, 0xf3, 0x38,
	0xb9, 0x03, 0x4b, 0xfc, 0x82, 0x07, 0x51, 0xd6, 0xd0, 0xff, 0x31, 0x0d, 0x3d, 0x43, 0x6c, 0x1d,
	0x25, 0x2c, 0x9a, 0x92, 0xc9, 0x5d, 0xd8, 0x7e, 0xd1, 0x53, 0x92, 0xbb, 0x7d, 0x1c, 0x65, 0xae,
	0x36, 0xe4, 0x64, 0x56, 0x17, 0x30, 0x6f, 0x9b, 0x78, 0x6c, 0x06, 0xdd, 0xd9, 0xe8, 0xb0, 0xf6,
	0x75, 0x01, 0x16, 0xf1, 0x26, 0x72, 0x17, 0x8a, 0xb8, 0x0e, 0x92, 0xd0, 0x2a, 0xfb, 0xcd, 0xbf,
	0x7d, 0xb6, 0x95, 0xac, 0x09, 0x8a, 0x7c, 0x72, 0x03, 0xca, 0xe3, 0xbc, 0x98, 0xb0, 0x4b, 0x9d,
	0x2c, 0x21, 0xf3, 0x3a, 0xc7, 0x7e, 0xfb, 0xce, 0x29, 0xce, 0xef, 0x9c, 0x3b, 0xb0, 0xad, 0x7b,
	0x2c, 0xe4, 0xee, 0x0b, 0x11, 0xf5, 0x5c, 0x8f, 0x05, 0x2a, 0xc0, 0xfa, 0x08, 0x1f, 0x45, 0x68,
	0xd3, 0x0d, 0x3c, 0x7e, 0x2e, 0xa2, 0xde, 0x61, 0x76, 0x78, 0xec, 0x37, 0x77, 0xa1, 0x88, 0xeb,
	0xad, 0x0c, 0x8b, 0x07, 0x27, 0x27, 0xa7, 0x87, 0xd5, 0x05, 0x52, 0x82, 0xe2, 0x87, 0xf4, 0xe8,
	0xa8, 0x6a, 0x91, 0x0a, 0xc0, 0x59, 0xfb, 0x80, 0x1e, 0xb9, 0xcf, 0x8f, 0x9f, 0xb5, 0xab, 0x85,
	0xe6, 0xf7, 0xe3, 0xe6, 0x43, 0x25, 0xf4, 0x79, 0x10, 0x99, 0xe6, 0xfb, 0x00, 0xd6, 0x26, 0x05,
	0x91, 0x95, 0x6a, 0xfb, 0x8a, 0xb1, 0x43, 0x2b, 0x13, 0x3a, 0xd1, 0xe4, 0x31, 0x54, 0xd2, 0x94,
	0x31, 0x29, 0x98, 0xe6, 0xd9, 0xd6, 0xba, 0x95, 0x57, 0xe9, 0xe4, 0xab, 0x23, 0xed, 0x0a, 0xa6,
	0xe9, 0x6a, 0x67, 0xfc, 0xc1, 0x35, 0x39, 0x06, 0x32, 0xba, 0x2e, 0x93, 0x76, 0xb6, 0x6d, 0x6a,
	0x57, 0x0b, 0x9f, 0xae, 0x77, 0xa6, 0x60, 0x4d, 0x1e, 0xc1, 0x66, 0x8f, 0xb3, 0x41, 0x26, 0x1f,
	0x15, 0xba, 0x51, 0x52, 0x75, 0xf3, 0x4f, 0x2b, 0x8b, 0x70, 0x56, 0x15, 0xf4, 0x7a, 0x6f, 0x06,
	0xd3, 0xb5, 0x18, 0x96, 0x73, 0x5e, 0x93, 0x1d, 0xa8, 0x6a, 0x15, 0x87, 0x1e, 0x9f, 0xe9, 0xa3,
	0x8a, 0xc1, 0x47, 0x6d, 0x74, 0x1f, 0x4a, 0x99, 0x4b, 0xa8, 0xa8, 0xb7, 0x99, 0xe8, 0x23, 0x8b,
	0xe6, 0x0f, 0x16, 0x94, 0xda, 0x52, 0x99, 0x62, 0xed, 0x03, 0xf4, 0xa4, 0x4a, 0xbb, 0x02, 0x9f,
	0x5b, 0xde, 0xbf, 0x9e, 0xed, 0xc8, 0xdc, 0xda, 0xa7, 0xe5, 0x5e, 0xf6, 0x4d, 0xee, 0xc1, 0x4a,
	0x62, 0xa3, 0xd2, 0x0d, 0x9a, 0xba, 0xb0, 0x39, 0x77, 0xb3, 0xd2, 0xe5, 0xde, 0x18, 0x21, 0x1f,
	0xc1, 0x7a, 0x56, 0x89, 0x51, 0xf9, 0xd2, 0x9d, 0x54, 0xbb, 0xba, 0xb6, 0xb4, 0xda, 0x99, 0x82,
	0x1f, 0xee, 0xbd, 0x7a, 0x5d, 0x5f, 0xf8, 0xf9, 0x75, 0x7d, 0xe1, 0xcd, 0xeb, 0xba, 0xf5, 0xf9,
	0xb0, 0x6e, 0x7d, 0x37, 0xac, 0x5b, 0x3f, 0x0e, 0xeb, 0xd6, 0xab, 0x61, 0xdd, 0xfa, 0x75, 0x58,
	0xb7, 0x7e, 0x1f, 0xd6, 0x17, 0xde, 0x0c, 0xeb, 0xd6, 0x97, 0xbf, 0xd5, 0x17, 0xfe, 0xb4, 0xac,
	0xce, 0x12, 0xfe, 0x0f, 0x7f, 0xf7, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x38, 0xd7, 0x92, 0x89,
	0xea, 0x0b, 0x00, 0x00,
}
